// tslint:disable:max-line-length

export class Content {

    public temas: Item[] = [...PRUEBAS, ...AGILES, ...ANALISIS, ...ARQUITECTURAS, ...BUENAS_PRACTICAS,
    ...CALIDAD, ...COMPILACION, ...META_CARACTERISTICAS, ...CONOCIMIENTOS_EMPIRICOS
    ];

}

export class Item {

    key = '';
    content: string[] = [];

    constructor(key: string, content: string[]) {
        this.key = key;
        this.content = content;
    }

}

export const PRUEBAS =
    [
        new Item('principios',
            ['- Las pruebas demuestran la presencia de defectos, por ende entre más pruebas halla mejor ',
                '- Es improductivo hacer pruebas exhaustivas, ademas de que es casi imposible de hacer ',
                '- Las pruebas tempranas ayudan a encontrar defectos con prontitud, y a su vez reducir tiempo y costos ',
                '- Agrupar defectos permite que las soluciones sean más especializadas, y las pruebas sean más efectivas ',
                '- La paradoja del pesticida, si nuestro software cambia, las pruebas tambien deben hacerlo, que sigan funcionando no siempre es buena señal ',
                '- Las pruebas dependen del contexto, entre más se parezca el entorno de pruebas al entorno de producción mejor ',
                '- Que no se presenten errores no significa que no se presentaran errores, solo que no se han dado las condiciones ',
            ]
        ),
        new Item('manifiesto',
            [
                '- El testing no es una fase más, siempre debe estar presente en todo el desarrollo ',
                '- La calidad no depende solo de las pruebas, es un proceso constante durante todo el ciclo de vida ',
                '',
                ' - Testing inicial <strong> SOBRE </strong> testing final ',
                ' - Prevenir bugs <strong> SOBRE </strong> encontrar bugs ',
                ' - Entender que se prueba <strong> SOBRE </strong> probar una funcionalidad ',
                ' - Construir un mejor sistema <strong> SOBRE </strong> destruir el sistema ',
                ' - Responsabilidad del equipo <strong> SOBRE </strong> la responsabilidad del tester ',

            ]),
        new Item('QAperson',
            [
                '- Quality Assurance (seguro de calidad) es un concepto donde todos los involucrados deben aportar, ',
                ' - aunque haya personas especificas para verificar su cumplimiento ',
                '- Todo proyecto deberia contar con un plan de pruebas que asegure la calidad del proyecto entregado ',
                '- La integración continua y los tests son herramientas con las que el proyecto deberia contar desde su inicio ',
                '- El encargado de estos aspectos debe ser el intermediario entre los clientes y sus espectativas y lo que ha sido elaborado ',
                '- Tambien es el encargado de crear ambientes de prueba que sean similares al ambiente de producción ',
            ]),
        new Item('tiposPruebas',
            [
                '- Funcionales    -> prueban las funcionalidades del sistema y suelen ser de caja negra, al validar el QUE más que el COMO ',
                '- No Funcionales -> estas validan cosas como carga, estres, rendimiento, confiabilidad, etc... ',
                '',
                '- Estructurales -> indagan la estructura interna del programa y sus relaciones, aca se pueden incluir las pruebas unitarias y de integración ',
                '- Estructurales -> estan son de tipo caja blanca, ya que es necesario conocer todo el sistema y como funciona para que sean bien planificadas ',
                '',
                '- Regresión -> basicamente es volver a correr todas la pruebas despues de que se cambien componentes ó se corrija un problema ',
                '- Regresión -> dependiendo de la cantidad de pruebas que hayan y de su complejidad puede ser una operación bastante demorada ',
            ]
        ),
        new Item('beneficios',
            [
                '- La calidad mejora al encontrar errores en etapas previas y durante el desarrollo, en vez de hacerlo en etapas finales ',
                '- Los cambios son hechos de manera más agil al inducir una mayor comunicación con todo el equipo ',
                '- Reducen el tiempo y los costos asociados a la mantenibilidad del software ',
                '- Los tests pueden tener documentación la cual no debe ser muy extensa, y tambien pueden servir como documentación ',
            ]),
        new Item('nombramiento',
            [
                '- Representa el intercambio de mensajes entre los diferentes componentes del sistema para lograr una funcionalidad ',
                '- El tiempo es importante ya que un mensaje debe terminar para que otro empieze (generalmente) ',
                '- Los objetos que interactuan puede ser simple clases, hasta modulos y sistemas completos ',
                '- El diablo esta en los detalles, saber nombrar los elementos que intervienen ayudara al analisis ',
                '',
                '- Clases -> deberian tener un indicador que las agrupe, como: (nombreClase)Test ',
                '- Metodos -> hay varias convenciones, pero generalmente deben incluir:  ',
                '  - nombre del metodo, estado a probar, comportamiento esperado; tambien se pueden incluir las palabras de given, when, should, test  ',
                '',
                '- Variables -> deben describir el proposito de cada variable, no deben ser resumidas ni genericas, algunos ejemplos pueden ser: ',
                '  - target, expected, actual, valid, invalid, Object(Mock)',
            ]),
        new Item('first',
            [
                ' Fast            -> los tests unitarios deben ser lo más rapido posible, ya que se suelen tener cientos de pruebas y ejecutarlas conlleva tiempo y recursos ',
                ' Independent     -> cada test debe ser independiente de los demás, de lo contrario habra un acoplamiento no deseado ',
                ' Repeatable      -> las pruebas deben funcionar en cualquier ambiente que se ejecuten, ya sea local o en un ambiente de integración ',
                ' Self-Validating -> las pruebas deben mostrar resultados concluyentes, estos no deben tener intervención humana para que sean validos ',
                ' Timely          -> toda prueba debe ser oportuna y debe tener una razon de ser, si no se pueden justificar, estas habran sido una perdida de tiempo ',
            ]),
        new Item('sutydoc',
            [
                '- System Under Test ',
                '  - Es aquello que se esta probando ya sea una clase, un componente, una funcionalidad ',
                '- Depend On Component ',
                '  - Es lo que necesita cada SUT para poder funcionar, y que la prueba pueda ser llevada a cabo ',
                '- Organización ',
                '  - Generalmente se organizan mediante una tabla que contiene el tipo de prueba, los SUTs y los DOCs ',
            ]),
        new Item('dobles',
            [
                '- Son objetos que se comportan de manera igual que el elemento que copian, pero son más simples de manejar ',
                ' - Dummy -> Es un objeto con valore concretos que solo sirve para que se cumplan ciertas precondiciones ',
                ' - Fake  -> son funcionales y se comportan igual que en producción, solo que de una manera más simple y limitada ',
                ' - Stub  -> Es un objeto que ya viene con una información predefinida, en vez de información real e impredecible ',
                ' - Mock  -> Son objetos que actuan de acuerdo a una llamada en especifico, de lo contrario no funcionaran debidamente ',
                ' - Spies -> Este objeto se encarga de visualizar todos los procesos y llamados internos, verificando que sean los desados ',
            ]),
        new Item('aaa',
            [
                '- Arrange -> en esta parte se organiza todo lo necesario y se deben establecer las condiciones del test ',
                '- Act     -> es la ejecución del fragmento a testear',
                '- Assert  -> ultimo paso de la prueba y es la comprobación de lo resultados ',
            ]),
        new Item('gwt',

            [
                '- Funciona de la misma manera que AAA, con algunas ventajas (Given, When, Then)',
                '- Puede ser usado con frameworks de BDD, es más que solo una estructura',
                '- Es obicuo por lo que más personas pueden entenderlo sin necesidad de un conocimiento completo del sistema ',
                '- Añade valor extra al negocio, al interconectar el codigo y las pruebas a un nivel mayor ',

            ]),
        new Item('piramide',
            [
                '        Exploracion                                                 ',
                '         GUI  Tests          Piramide de tests:                     ',
                '       API      Tests        La mayor parte de las pruebas deberian ',
                '     Integration  Tests      ser unitarias, y la menor parte        ',
                '   Component       Tests     deberian ser la interfaz grafica       ',
                ' Unit               Tests                                           ',
                '',
                '        Exploracion                                                 ',
                ' GUI                Tests    Cono de helado:                        ',
                '   API             Tests     Es un anti patron de pruebas           ',
                '     Integration  Tests      Donde la mayoria de pruebas son        ',
                '       Component Tests       de la interfaz graficas                ',
                '         Unit   Tests        y NO pruebas unitarias                 ',
            ]),
        new Item('triangulo',
            [
                '         Alcance              Alcance -> requisitos ó tareas a realizar            ',
                '                              Tiempo -> planificicación de la duración del proyecto ',
                '         Calidad              Costos -> recursos a gastar el proyecto              ',
                '                                                                                   ',
                '   Costo         Tiempo                                                            ',
            ]),
        new Item('cobertura',
            [
                '- La cobertura del codigo es fundamental para garantizar un alcance optimo de las pruebas ',
                '- No hay un numero magico para todos los proyectos, cada uno tendra una cobertura ideal',
                '- El 100% de esta cobertura no es garantia de ausencia de errores, como el 50% no es garantia de la calidad de las pruebas ',
                '- Esto es importante ya que se puede usar para hacer despliegues e integración continua, y encontrar codigo muerto ',
                '- Existen varios tipos de cobertura, pero el más usado es la cobertura de las lineas de codigo ',
            ]),
        new Item('falsos',
            [
                '- Falsos Positivos & Falsos Negativos ',
                '- Son comunes en ambientes inestables, ó poco hermeticos ',
                '',
                '- Falso Positivo -> ocurre cuando se detectan defectos, que no son culpa del componente inmediato ',
                '  - Esto puede ser debido a fuentes externas de error, inestabilidad del ambiente, errores de los datos ',
                '',
                '- Falso Negativo -> ocurre cuando no se detectan errores, que estan presentes en lo que se esta probando ',
                '  - Suelen suceder por pruebas mal desarrolladas, más que por el propio entorno ',
            ])
    ];

export const AGILES =
    [
        new Item('moscow',
            [
                '- Es una tecnica para la priorización de requisitos y funciones para lograr un alcance especificado ',
                '',
                '- M (Must Have)   -> debe tener:    este requisito debe estar implementado si ó si, si no, el producto es un fracaso ',
                '- S (Should have) -> deberia tener: requisito de alta prioridad que en la medida de lo posible deberia quedar en el producto final ',
                '- C (Could have)  -> podria tener:  caracteristica deseable, pero que no es necesaria y solo sera implementada si hay posibilidades ',
                '- W (Won´t have)  -> no tendra:     son requisitos que estan descartados por esta vez, pero seran incluidos a futuro ',
            ]),
        new Item('scoring',
            [
                '- Permite determinar la prioridad de las funcionalidades, basandose en diferentes criterios, que a su vez ',
                ' - constan con diferentes pesos, cada caracteristica de la Historia de Usuario tendra un valor ',
                '',
                '- Determinar el peso de las caracteristicas es más facil ya que se hace en base a una comparación, ',
                ' - Donde previamente se ha tomado una HU como punto base y las demás sr miden con esta base ',
            ]),
        new Item('muda',
            [
                '- El desperdicio en las empresas viene del termino japones MUDA, que es todo lo inutil, superfluo, despilfarro, residuos, ocioso ',
                '',
                '- Sobreproducción -> producir más de lo demandado, esperando que el mercado lo necesite es una mala praxis, ',
                ' - que despilfarra recursos que pudieron ser usados en otras areas ',
                '- Esperas -> son los famosos cuellos de botella, donde un proceso alenta a los demás, haciendoles perder tiempo ',
                '- Transporte -> todo movimiento innecesario de elementos que no aporta valor debe ser minimizado ',
                '- SobreProcesos -> son procesos que aunque pueden ser utiles, no van a volver ser usados, por eso su realización es un desperdicio ',
                '- Exceso de inventario -> puede conllevar a perdidad monetarias a la empresa, debido a que se pueden volver obsoletos, o nunca usarse ',
                '- Movimientos innecesarios -> todo movimiento que no aporte valor al producto es un despedicio, hasta caminar al trabajo puede serlo ',
                '- Defectos -> todo error consume tiempo para ser resuelto, independientemente de su tamaño, además de la insatisfacción del cliente ',
            ]),
        new Item('5s',
            [
                '- Seiri, Seiton, Seiso, Seiketsu, Shitsu ke; la base de la mejora continua ',
                '',
                '- Seieri -> clasifica y organizar de manera apropiada ',
                ' - es retirar del area o estación todo aquello que no es necesario ',
                '- Seiton -> orden ',
                ' - organizar los elementos necesarios de manera que sean de facil acceso ',
                '- Seiso  -> limpieza',
                ' - ya con un orden establecido y areas limpias, es más facil detectar malas practicas ',
                '- Seiketsu -> estandares',
                ' - este estado solo se obtiene cuando la limpieza y la organización se mantienen constantes ',
                '- Shitsuke -> disciplina',
                ' - es la creación de habitos que eviten el rompimiento de los conceptos anteriores ',
                '',
                '- ¿ Porque no la aplican algunas empresas ? ',
                '',
                '- La maquinaria no puede parar -> los cronogramas no dan tiempo de mantenimiento de la maquinaria ',
                '- La limpieza como perdida de tiempo -> algunos empleadores pagan para trabajar, no para limpiar su area de trabajo ',
                '- Costumbre -> crear nuevos habitos y cambiar los viejos es un cambio fuerte y prolongado de paradigma ',
                '',
                '- Beneficios ',
                '- Mayor seguridad de los empleados ',
                '- Reducción de las perdidas y mermas por defectos ',
                '- Mayor calidad, y menos tiempo de respuesta ',
                '- Genera una cultura organizacional ',
            ]),
        new Item('muda#1',
            [
                ' 1 -> Trabajo hecho a medias: desplegar sin probar y tener errores conocidos más no solucionados, ',
                '  - daran problemas a futuro, de manera que aveces es mejor un nuevo desarrollo que corregir lo existente ',
                ' 2 -> Funcionalidad extra: toda funcionalidad que no haya sido pedida significa, ',
                '  - recursos gastados que no tendran redito alguno ',
                ' 3 -> Reaprendizaje: nuestra memoria no es absoluta, por lo que inevitablemente olvidaremos cosas, ',
                '  - y gastaremos tiempo volviendolas a aprender, tambien aplica para personas expertas ',
                '  - que ya tienen el conocimiento, pero nos empeñamos por aprenderlo nosotros mismos, sumando tiempo al desperdicio ',
            ]),
        new Item('muda#2',
            [
                ' 4 -> Transferencia de conocimiento: todo proceso de comunicación es ineficiente ya que, ',
                '  - durante el proceso se suelen perder datos u omitir detalles importantes, y asi entre más niveles ',
                '  - haya que permear, de las mejores manera para evitar esto son la comunicación cara a cara ',
                ' 5 -> Retrasos: algunas funcionalidades requieren que sean lineales, por lo que si la etapa previa se retrasa, ',
                '  - las etapas subsiguientes tambien lo haran, por lo que estas situaciones deben ser evitadas lo más posible ',
                ' 6 -> Cambios de contexto: cuando tenemos varias cosas por hacer de manera inmediata, tendemos a ser multitarea, ',
                '  - esto no es más que un cambio de contexto que requiere tiempo y esfuerzo, y que entre más se hagan, más desperdicio habra ',
                ' 7 -> Defectos: uno de los más peligrosos, ya que entre más tarde se encuentre un error, más costoso sera corregirlo ',
                '  - estos errores se pueden disminuir por medio de las pruebas, e integración continua ',
            ]),
        new Item('planningPoker',
            [
                '- Las estimaciones son de mucha ayuda, para definir tiempo, costos y esfuerzos ',
                ' - independientemente de certeza, ya que generalmente casi nunca se cumplen ',
                '- Ayuda a visualizar desde diferentes puntos de vista, esto es bastante util para analizar un problema ',
                '-Los riesgos pueden ser detectados de manera previa, además de prever posibles obstaculos ',
                '-Todo el equipo involucrado deberia estar presente en este evento, ya que todos pueden aportar desde sus areas ',
                '',
                '- Material necesario',
                '- Cada participante debe tener su propia baraja ',
                '- La baraja en si es una secuencia de Fibonacci modificada, junto a ciertas cartas especiales: ',
                ' - infinito   -> es una HU que es demasiado grande para ser estimada, por lo que debera ser dividida y reorganizada ',
                ' - cero       -> significa que la HU ya fue realizada ',
                ' - coffee cup -> puede significar una actividad de esfuerzo minimo o simplemente la necesidad de realizar una pausa ',
                '',
                '- Trabajo previo',
                ' - es necesario indicar que indica cada numero antes de realizar el ejercicio, (horas, dias, esfuerzo, etc...)',
                ' - indicar que incluye y que no la HU, documentación, tests unitarios, tests de integración ',
                '',
                '- Dinamica',
                ' - se especifica todo lo que se va a estimar y se hacen las preguntas y respuestas pertinentes ',
                ' - se leen la historia de usuario y se vota por medio de la baraja ',
                ' - si no hay consenso se abre una breve discusión y se vuelve a votar, ',
                '  - si no vuelve a haber concenso se podra realizar un promedio o escoger un extremo ',
                ' - se repite el proceso hasta completar todas las HU ',
            ])
    ];

export const ANALISIS =
    [
        new Item('comportamiento',
            [
                '- Estos modelos se usan para describir a profundidad el comportamiento de un sistema ',
                '',
                '  - Flujos de datos -> modelan el procesamiento de los datos del sistema ',
                '   - No solo sirven para saber las entradas y salidad del sistema, tambien para validaciones con los usuarios ',
                '   - Y que estos validen los datos y los procesos a nivel interno ',
                '',
                '  - Maquinas de estado -> modelan la reacción del evento en cuanto a los estimulos externos/internos ',
                '   - Estos indican los posibles estados de un sistema, y que puede suceder cuando paso un estimulo en especifico ',
                '   - Se usan para sistemas en tiempo real mas que todo, ya que estos son sumamente dependientes de su ambiente ',
                '   - Para sistemas grandes se recomienda usar diferentes niveles de estados de mayor a menor complejidad ',
            ]),
        new Item('dominio',
            [
                '- Estudio de los dominios de conocimientos de las sociedades ',
                '- De esta manera el enfoque socio-cognitivo no es el unico usado para la toma de información ',
                '- Tambien se ha de tener en cuenta el contexto presente y lo que motiva sus acciones ',
                '- Esto tambien da un conocimiento más profundo del entorno, y una mayor calidad de la información recolectada ',
            ]),
        new Item('case',
            [
                '- Ingeniería asistida por computador, que es el desarrollo y mantenimiento de proyectos de software por medio de herramientas de software ',
                '',
                '- Documentación -> crea documentos de cualquiera de las etapas del proyecto y para diferentes tipos de personas; como DrExplain',
                '- Configuración -> son utiles para el control de versiones y la evolución del software; como Git',
                '- Diseño -> ayudan a la creación de la estructura del programa y de su desglose para detallarlos y refinarlos; como Star UML ',
                '- Analisis -> ayuda a cumplir con los requisitos al analizar los diagramas por posibles falencias, omisiones ó redundancias; como casecomplete ',
                '- Implementación -> en esta categoria se encuentran los IDEs como Eclipe y herramientas para hacer prototipos; como Mockup Builder',
                '- Pruebas -> son herramientas para realizar pruebas de software como y aumentar la calidad; como Jmeter',
                '- Mantenimiento -> sirven para documentar errores y seguimiento de defectos; como HP Quality Center ',
            ]),
        new Item('divide',
            [
                '- Generalmente es una tecnica aplicada a algoritmos, pero puede usarse en ambientes de mayor embergadura ',
                '- Suelen se problemas capaces de descomponerse en subproblemas y ser resueltos de manera recursiva ',
                '',
                ' - Divide -> dividir el problema en subproblemas más pequeños ',
                ' - Vence -> resolver los problemas de manera individual y de manera acotada ',
                ' - Combina -> las soluciones de los subproblemas en la solución del problema original ',
            ]),
        new Item('diseño',
            [
                '- Un buen analisis desemboca en un buen Diseño (generalmente) ',
                '- Esta etapa es fundamental para llegar a una solución optima que cumpla los requisitos funcionales y no funcionales, ',
                ' - basandose en la creatividad y experiencia de los profesionales a cargo ',
                '',
                ' - Entendimiento de los requisitos -> sean funcionales o NO funcionales estos deben ser claros y sin ambiguedades ',
                ' - Usar patrones de diseño -> No reinventes la rueda, sabiendo que hay soluciones a tus mismos problemas, documentadas y confiables ',
                ' - Calidad -> esta debe ser un objetivo a alcanzar en tu proyecto, no una fase más ',
                ' - Modularidad -> al ser modular esto facilitara la reutilización y que las futuras modificaciones afectan el menos codigo posible ',
                ' - A la medida -> el diseño puede crecer y cambiar de acuerdo a las especificaciones de cliente, no necesariamente debe nacer completo ',
                ' - Documentación -> la documentación debe existir en cualquier proyecto, para ayudar a la compresión del sistema, sea a nivel general ó especifico ',
            ]),
        new Item('crc',
            [
                '- Ayuda a los equipos a entender los procesos de una manera más facil y concisa ',
                '- Al tener todos las posibles parte del sistema a la disposición se reduce la redundancia y se asignan mejor las responsabilidades ',
                '- Es ideal hacer esto mediante una lluvia de ideas, donde todos participen ',
                '- Cuando hay demasiadas tarjetas, estas empiezan a añadir complejidad al entendimiento del modelado, ',
                '  - para esto se desarrollaron los casos de uso, y explorar diferentes flujos y especializaciones ',
                '',
                ' - Constan de 3 partes: ',
                ' - Clase -> Nombre de la clase en si, el cual debe ser diciente y que ayude a entender el porque de su creación ',
                ' - Responsabilidad -> cual es la función ó funciones de la clase, entre más especifica mejor ',
                ' - Colaborador -> son otras clases ó entidades que son necesarias para el correcto funcionamiento de la clase ',
            ]),
        new Item('avestruz',
            [
                '- Es una estrategia donde se ignora un problema, en vez de buscar una solución para este ',
                '- Esto es debido a la premisa de suponer de que son problemas increiblemente raros ',
                '- Al ser problemas raros, es más costoso y complejo evitar que sucedan a controlarlos cuando suceden ',
                '- Además de que se agregaria complejidad extra por un esceneario poco probable ',
            ]),
    ];

export const ARQUITECTURAS =
    [
        new Item('definicion',
            [
                ' -  Representa la estructura del sistema ',
                ' -  Las responsabilidades de cada uno de sus partes ',
                ' -  La organización y jerarquización de sus componentes ',
                ' -  Las propiedades visibles externamente y las relaciones entre ellas ',
            ]),
        new Item('capas',
            [
                ' - Se basa en la distribución de roles y responsabilidades de forma jerarquica ',
                ' - Puede tener n - capas, generalmente son 3 -> MVC ',
                ' - La abstracción la reutilizacion, el desacople y la integración mejoran considerablemente ',
                ' - El alto grado de abstracción alcanzado puede aislar ciertas capas y hacerlas independientes de las tecnologias ',
                ' - Los cambios tienen bajo impacto y la matenibilidad es más facil ',
            ]),
        new Item('cliente',
            [
                ' - Existen 2 elementos principales, de las arquitecturas más usadas debido a su simplicidad ',
                ' Servidor -> quien responde las peticiones y almacena la información ',
                ' Red -> medio para la comunicación en doble sentido constantemente ',
                ' Cliente -> Dispositivos que hacen solicitudes, para guardar o consultar datos ',

            ]),
        new Item('intermediario',
            [
                ' - Un componente central maneja diferentes sistemas distribuidos coordinando las respuestas ',
                ' - Los clientes solicitan el intermediario y este a su vez solicita los servicios expuestos indicados ',

            ]),
        new Item('servicios',
            [
                ' - Se pasa de un nucleo central y robusto a diferentes partes más pequeñas y ligeras ',
                ' - Las partes se intercomunican entre si y funcionan de manera separada, aumentando la tolerancia a fallos ',
                ' - Los servicios pueden ser independientes de las tecnologias, además de que se pueden subdividir tambien ',
                ' - Tambien se pueden escalar de manera individual significando una mejora en el uso de recursos ',

            ]),
        new Item('hexagonal',
            [
                ' - Aisla el dominio de las tecnologias, la comunicación se da por medio de puertos(interfaces) ',
                ' - Cualquier dispositivo puede consultarla y la información sera la misma ',
                ' - Las capas son idependientes y más faciles de testear ',

            ]),
        new Item('otrasArquitecturas',
            [
                ' - Bus de Eventos -> Una fuente emite eventos donde un bus los direcciona a los receptores indicados ',
                ' - MVC -> Consta de 3 capas bien definidas, modelo, vista y controlador, cada una con una función especifica ',
                ' - Tuberia -> Es un flujo donde los datos son transformados a medida que van desde su origen hasta su destino ',

            ]),
        new Item('monolitos',
            [
                ' MONOLITO                        MICROSERVICIOS                         MICROLITOS ',
                ' ',
                ' Separación de            Acoplamiento alto y mayor        Entregadas por la plataforma          Acoplamiento alto y mayor ',
                ' funciones tecnica        dependencia del framework        usada, reduce el acoplamiento         dependencia del framework ',
                ' ',
                ' Latencia                 Casi nula                        Puede ser alta                        casi nula ',
                ' ',
                ' Consistencia             Transaccional                    Eventual, requiere más atención       Eventual ',
                ' ',
                ' Evolución                Complicada por proceso           Sencilla por proceso                  Sencilla ',
                ' ',
                ' Especialización          Alta variedad de                 Alta especialización, Alta especialización, ',
                ' de los equipos           conocimientos                    conocimiento del negocio              conocimiento del negocio ',
                ' ',
                ' Automatización           Pocos despliegues                Muchos despliegues                    pocos despliegues ',
                ' ',
                ' Tamaño                   Grande                           Pequeño                               Pequeño ',
                ' ',
                ' Observalidad             Relativamente facil              Más complicada                        Punto intermedio ',
                ' ',
                ' Monitarización           Complicado separar               Sencillez para identificar            Sencillez para identificar ',
                ' tecnica                  los problemas                    problemas de rendimiento              problemas de rendimiento ',

            ]),
    ];

export const BUENAS_PRACTICAS =
    [
        new Item('practicas1',
            [
                '- Definir el alcance, establecer limites con el cliente acerca del trabajo a realizar ',
                '- Dividir el desarrollo en fases o entregables que sean factibles',
                '- Elegir el mejor IDE de acuerdo a los conocimientos o las necesidades',
                '- Reutiliza código y comentalo cuando sea necesario',
                '- Documenta lo que haz hecho, asi es más facil integrar personal y sera util para futuros desarrollos ',
            ]),
        new Item('practicas2',
            [
                '- Presencia activa de los clientes en el desarollo',
                '- Definir los requerimientos y sus prioridades con el cliente',
                '- Adaptar el lenguaje de acuerdo a los tipos de clientes',
                '- Nunca dejar funciones al azar, que las pruebas demuestren su funcionamiento ',
            ]),
        new Item('practicas3',
            [
                '- Escoger un ciclo de vida adecuado segun cada desarrollo',
                '- Estimar y presupuestar correctamente (más facil decirlo que hacerlo) ',
                '- Control de calidad y revisiones de código periodicas',
                '- Planificar el matenimiento el soporte y posibles mejoras',
            ]),
        new Item('practicas4',
            [
                '- Usar tecnologias y frameworks consolidados',
                '- Promover que el uso de la aplicación sea intuitivo y accesible ',
                '- Distribución de tareas, no hay equipos de un solo hombre',
            ]),
        new Item('demeter',
            [
                '- No aceptar caramelos de extraños',
                '- El encadenamiento de muchos metodos puede significar un alto acoplamiento',
                '- Entre más grande sea una pila de llamadas, sera más propensa a futuras refactorizaciones ',
            ]),
        new Item('complejidad',
            [
                '- Es una metrica del software que proporciona una medida cuantitativa de la complejidad logica del programa ',
                '- Son los diferentes caminos que puede seguir una aplicación desde la entrada hasta la salida, ',
                ' - teniendo en cuenta condiciones, parametros, funciones y atributos ',
                '',
                '- Lo ideal es tener la menor complejidad ciclomatica posible ya que: ',
                ' - Facilita el mantenimiento del codigo ',
                ' - Simplifica la refactorización ',
                ' - El codigo es más facil de entender ',
                ' - La escabilidad del proyecto se puede facilitar ',
                '',
                '- Para reducirla se pueden aplicar los siguientes concejos: ',
                ' - No abusar de la identación ',
                ' - Evitar las sentencias switch ',
                ' - Metodos pequeños para funcionalidades más desacopladas ',
            ]),
        new Item('logging',
            [
                ' “Depurar es como ser el detective de una película policial en la que también eres el asesino. ”- Filipe Fortes ',
                '',
                '- Depurar es recomendable cuando la pila de llamadas es demasiado extensa y compleja',
                '- Registrar es util cuando la aplicación ó funcionalidad es pequeña y de baja complejidad ',
                '- Esta elección tambien depende de la comodiad de cada programador y de su eficiencia con cada herramienta ',
            ]),
        new Item('complejidadCognitiva',
            [
                '- Es una metrica de software complementaria a la complejidad ciclomatica ',
                '- Esta metrica trata sobre que tan dificil es de entender un fragmento de codigo ',
                '- Esta metrica aumenta de acuerdo a ciertas condiciones ',
                ' - Anidamiento',
                ' - Condicionales',
                ' - try/catch y retrasmision de excepciones',
                ' - Estructuras switch-case ',
                ' - sequencias largas de operadores logicos ',
                ' - recursividad ',
                ' - ciclos',
                '',
                '- Un codigo con una alta complejidad cognitiva es dificil de mantener, por lo que siempre se busca simplificarla, ',
                ' - sin cambiar su comportamiento, para ser más facil de comprender y de modificar ',
            ]),
        new Item('complejidadAlgoritmica',
            [
                '- Un algoritmo es una manera de hallar un dato desconocido, o una secuencia de pasos para obtener un resultado ',
                '- Los problemas pueden ser resueltos de diversas maneras, sin embargo no todas son optimas o viables ',
                '- Esto nos permite medir un algoritmo mediante los recursos y el tiempo necesario para su ejecución ',
                '- Tambien se suelen describir mediante el tamaño del conjunto de datos ',
                ' - y el crecimiento de las instrucciones para poder cumplir el objetivo ',
                '- Para medir la complejidad cada instrucción suele tener un peso determinado, ',
                ' - despues de sumarlas y tener el mayor termino, este es el indicativo de la complejidad ',
                '',
                '- Grados de complejidad comunes: ',
                '- O(1)       -> constante         - O(n<sup>2</sup>) -> cuadratico  ',
                '- O(log n)   -> logaritmico       - O(n<sup>3</sup>) -> cubico      ',
                '- O(n)       -> lineal            - O(n<sup>a</sup>) -> polinomico  ',
                '- O(n log n) -> cuasi-lineal      - O(2<sup>n</sup>) -> exponencial ',
                '- O(n!)      -> factorial                                           ',
                '',
                '- Sabiendo analizar estas caracteristicas, se puede suponer el costo de los algoritmos, e intentar optimizarlos ',
                '- Si la optimización no es prioridad algunos de estos conceptos pierden relevancia, sin embargo',
                ' - conocerlos permite generar mejores soluciones, al tener más perspectivas a la hora de resolver un problema ',
            ]),
        new Item('estandaresNombramiento',
            [
                '- Cada lenguaje de programación tiene sus convenciones para nombrar metodos, clases, variables, constantes, etc... ',
                '- Se recomienda seguir estas convenciones para aumentar la legibilidad de nuestro codigo y facilitar el mantenimiento ',
                '',
                '- camelCase -> se usan mayusculas para diferenciar una palabra de otra ',
                ' - UpperCamelCase  -> la primera letra de las palabras es mayuscula: MiPaginaDeConceptos ',
                ' - lowerCammelCase -> igual al anterior pero la primera letra es minuscula: miPaginaDeConceptos ',
                '- Generalmente usada para nombres de variables en diversos lenguajes ',
                '',
                '- snake_case -> las palabras estan separadas por guion bajo: mi_pagina_de_conceptos ',
                ' - SCREAMING_SNAKE_CASE -> igual que snake case pero en mayusculas: MI_PAGINA_DE_CONCEPTOS ',
                '- Utilizado para nombre de constantes y de variables en lenguajes más antiguos ',
                '',
                '- kebab-case -> como snake case pero con guion medio: mi-pagina-de-conceptos ',
                ' - Train-Case -> variedad de kebab case pero mayuscula inicial: Mi-Pagina-De-Conceptos ',
                '- Se encuentra generalmente en nombres de paquetes o de urls ',
                '',
                '- leetspeak ó 1337 -> consiste en remplazar caracteres por otros similares o su reflexion: M1P4G1N4D3C0NC3P70$ ',
                '- Usada ampliamente en internet, además de diversas comunidades en este ',
                '',
                '- Notacion hungara -> se usa para crear nombres de variables que indiquen su tipo: nContador ó bActivo ',
                '- Tambien usada en la programación, más que todo en lenguajes no tipados '
            ]),
    ];

export const CALIDAD =
    [
        new Item('artesanos',
            [
                '- Se puede considerar el siguiente nivel del desarrollo profesional, no solo mejorando nosotros mismo, sino a los demás ',
                '- Los 4 principios que este expone son: ',
                '',
                '- No sólo software que funciona, <strong>SINO</strong> también software bien diseñado',
                '- No sólo responder al cambio, <strong>SINO</strong> también agregar valor constantemente',
                '- No sólo individuos e interacciones, <strong>SINO</strong> también una comunidad de profesionales',
                '- No sólo colaboración con el cliente, <strong>SINO</strong> también asociaciones productivas',
            ]),
        new Item('metricas',
            [
                '- Además de revelar el desempeño del equipo de desarrollo, puede ser indicativo de la efectividad del equipo ',
                '- Metricas de productividad ',
                ' - Tiempo de entrega -> tiempo que se tarda de inicio a fin para entregar un proyecto ',
                ' - Cantidad de codigo -> lineas de codigo de la aplicación, esto puede ser un indicativo de la productividad, ',
                '   - más no de la calidad ',
                ' - Trabajo en curso -> trabajo empezado y que se compara con lo anteriormente hecho para tener una idea del progreso ',
                ' - Velocidad agil -> basandose en los sprints previos y cuantos puntos se han hecho, se puede estimar el proximo sprint ',
                ' - Tasa de exito -> calcula el porcentaje de exito del sprint, esto no significa necesariamente completar los puntos, ',
                '   - pero si las tareas del sprint ',
                ' - Numero de versiones -> los equipos agiles dan prioridad a las nuevas versiones con nuevas caracteristicas que den valor ',
                '',
                '- Metricas de rendimiento ',
                ' - Rendimiento -> cantidad de unidades que procesa un sistema en un periodo de tiempo ',
                ' - Tiempo de respuesta -> tiempo que se tarda en responder a una consulta ',
                ' - Fiabilidad y disponibilidad -> capacidad del software para cumplir con sus especificaciones ',
                '',
                '- Metricas de defectos ',
                ' - Cobertura de codigo -> proporcion del codigo que cubren las pruebas en relación a toda su extension ',
                ' - Deteccion de defectos ->  es un porcentaje calculado entre los defectos encontrados antes y despues del lanzamiento ',
                ' - Deuda tecnica -> es el costo de ignorar problemas que a la larga se podran convertir en errores ',
                ' - Vulnerabilidades de seguridad -> entre menos brechas y defectos se encuentren, más seguro sera la aplicación ',
                ' - Incidentes de seguridad -> recuento de las veces en que una aplicación fue vulnerada y la gravedad del ataque ',
                '',
                '- Metricas de usabilidad ',
                ' - UX -> suelen ser cualitativas e incluyen las respuestas objetivas y subjetivas del usuario ',
                ' - Usabilidad -> mide que tan bien el software permite alcanzar sus objetivos ',
                ' - Net Promoter Score -> es la voluntad de un cliente para recomendar la aplicación a otros ',
            ]),
        new Item('metricasEnCodigo',
            [
                '- Aplicar estas metricas suele ser un tema complejo, ya que estas dependen de las necesidades especificas de la aplicación ',
                '- Pero esto trae grandes beneficios para las aplicaciones al permitir conocer el estado actual y las acciones para mejorar nuestro codigo ',
                '',
                ' - Acoplamiento -> todo modulo debe ser lo suficientemente independiente para ser modificado y afectar en lo minimo posible a los demás ',
                '  - demasiado acoplamiento significa que esto conllevara a efectos en cascada no deseados al realizar modificaciones en el codigo ',
                '',
                ' - Cohesion -> es el grado de relación entre las partes, y va muy de la mano con el principio de responsabilidad unica ',
                '  - un codigo poco integrado se vuelve complejo, dificil de mantener y poco reutilizable ',
                '',
                ' - Complejidad -> un algoritmo debe ser eficaz y facil de entender, de esta se diferencia 2 tipos de complejidad ',
                '  - Complejidad Cognitiva -> que es la dificultad para entender intuitivamente el codigo ',
                '  - Complejidad Ciclomatica -> que es la dificultad para probar determinado segmento de codigo ',
                '',
                ' - Code Churn -> frecuencia con que altera el codigo a traves del tiempo, a mayor numero de modificaciones, más posibilidad de error ',
                '',
                ' - Cobertura -> porcentaje de codigo cubierto por las pruebas, a mayor cobertura, menor es la posibilidad de defectos ',
                '',
                ' - Codigo muerto -> es codigo que nunca es ejecutado, no siempre es facil de encontrar y no hay metodos infalibles para esto ',
                '',
                ' - Duplicación -> este codigo es producto del desconocimiento general del proyecto, replicando codigo que ya existe ',

            ]),
        new Item('cleanCode',
            [
                '- La calidad de codigo es un estandar que siempre se debe perseguir, hasta el codigo más limpio puede verse afectado por las malas practicas ',
                '- El proceso de degradación en todo proyecto es inevitable, más no incontrolable ',
                '- Los parches pueden ser reparaciones o adiciones rapidas y funcionales, sin embargo puedan estar en contravia directa de la calidad del codigo ',
                '',
                '- Para soluciones limpias y bien estructuradas se deberian seguir los siguientes pasos: ',
                '  - Analisis de caracateristicas -> toda nueva funcionalidad debe ser analizada e implementada de manera que, ',
                '    - el mayor numero de inquietudes este resuelto antes de iniciar la solución ',
                '  - Analisis del codigo base -> sabiendo la solución se debe analizar el codigo base para causar el menor impacto posible, ',
                '    - para tener claro que se puede modificar, reutilizar y que se debe crear nuevo ',
                '  - Desarrollo y refactorización -> no solo es desarrollar nuevos componentes y modificar los existentes, ',
                '    - tambien puede haber lugar para refactorizaciones, evitando la degradación del codigo ',
                '',
                '- Si estos pasos se realizan de manera adecuada y se mantiene la calidad del codigo en la mente, ',
                ' - la degeneración de nuestro codigo se podra manejar en terminos aceptables ',
            ]),
    ];

export const COMPILACION =
    [
        new Item('compilacion',
            [
                ' - Es el proceso de pasar un lenguaje de programación a otro formato de manera equivalente ',
                ' - Generalmente es un proceso de lenguajes de alto nivel a bajo nivel ',
                ' - Durante el proceso el codigo se puede optimizar o añadir más procesos ',
            ]),
        new Item('nivel',
            [
                ' - Bajo nivel -> son lenguajes de alto rendimiento dependientes de la maquina donde se ejecute ',
                ' - Bajo nivel -> Es un lenguaje que esta más cercano al lenguaje maquina, por lo que son dificiles de manejar ',
                ' ',
                ' - Medio nivel -> Pocos lenguajes caen en esta categoria, ya que pueden ',
                ' - Medio nivel -> Acceder al sistema pero tambien puede funcionar como lenguaje de alto nivel ',
                ' ',
                ' - Alto nivel -> Son lenguajes más cercanos al entendimiento humano, además de ser más dinamicos ',
                ' - Alto nivel -> Son independientes de las maquinas donde se ejecuten, a traves de un traductor como intermediario ',
            ]),
        new Item('interprete',
            [
                ' - Compilados -> son traducidos y ejecutados en la maquina que esten ',
                ' - Compilados -> esto hace que la optimización sea mayor, pero la compatibilidad no ',
                ' - Compilados -> los archivos ejecutables se realizan previamente, por lo que la ejecución es inmediata ',
                ' - Compilados -> al estar enlazados con el SO y el Host, estos se pueden afectar mutuamente ',
                ' ',
                ' - Interpretados -> estos deben tambien deben ser traducidos, pero lo hacen a un intermediario ',
                ' - Interpretados -> este intermediario se encarga de ejecutar el programa para que el sistema lo entienda ',
                ' - Interpretados -> debido a esto son multiplataforma, y se hace a pedido, (just in Time) ',
                ' - Interpretados -> la ejecución de estos programas estan aisladas del SO, por lo que requieren más recursos ',
            ]),
        new Item('transpilacion',
            [
                ' - Estos tambien traducen codigo de un lenguaje a otro, pero de igual nivel ',
                ' - Uno de los ejemplos más relevantes es paso de Typescript a Javascript ',
                ' - Todo transpilador puede ser considerado un compilador, pero no al contrario ',
                ' - Generalmente toda la sintaxis del lenguaje destino es compatible con la de origen, pero no al contrario ',
            ]),
        new Item('azucarSintactico',
            [
                '- Termino acuñado para hacer referencia a las adiciones sintacticas de un lenguaje de programación ',
                '- Estas adiciones se dan con el proposito de hacer que las construcciones sean más faciles de leer y expresar ',
                '- Esto no cambia el sentido semantico de las expresiones, pero si lo hace más entendible para el ser humano ',
                '- Son aquellas expresiones que pueden ser borradas sin afectar el funcionamiento del programa, o su rendimiento ',
                '- Parte del trabajo de los compiladores es desglosar estas expresiones a sus reducciones más basicas ',
            ]),
        new Item('coercion',
            [
                '- Es la conversion automatica o implicita de un tipo de dato a otro ',
                ' - Ejemplo: de string a number ',
                '- La coerción es implicita, mientras que la conversion puede ser implicita o explicita ',
                '- Esto puede dar a errores o conversiones erroneas si no se especifica que es lo que se necesita ',
                ' - Ejemplo -> "5" + 9 = 59         ',
                ' - Ejemplo -> Number("5") + 9 = 14 ',
            ])
    ];

export const META_CARACTERISTICAS =
    [
        new Item('metaDatos',
            [
                '- Literalmente son datos de los datos ',
                '- Estan estructurados para describir caracteristicas de los datos como cantidad y contenido ',
                '- Actualmente se usan para gestionar y recolectar información de interes ',
                '- Facilitan la estandarización y la gestion de los cambios ',
                '- Pueden facilitar el desarrollo al tener un menor cambio de costo entre plataformas ',
            ]),
        new Item('metaClase',
            [
                '- Normalmente se considera una clase de clases ',
                '- Es una caracteristica propia del sistema por lo que el usuario jamas la llegara a ver ',
                '- Esta caracteristica permite añadir y modificar comportamientos del programa, ',
                ' - Sin llegarlo a afectar directamente ',
                '- Este concepto es ampliamente usado para realizar testing, por medio de anotaciones, dobles y otros conceptos, ',
                ' - Un ejemplo de esto son Junit y Mockito, frameworks para realizar pruebas en java, que se basan en estas caracteristica ',
            ]),
        new Item('reflexion',
            [
                '- Capacidad de un codigo para observar un programa para observarse y cambiar su estructura a alto nivel ',
                '- Puede ser dinamica o estatica, y es más comun en los lenguajes que usan maquinas virtuales para ejecutarse, como JAVA ',
                '- Cuando el codigo fuente se compila normalmente pierde su estructura al pasar a un lenguaje de un nivel más bajo, pero ',
                ' - si este sistema permite la reflexión esta estructura se preserva como metadatos ',
                '- La reflexión permite conseguir un codigo aun más flexible, a cambio de perder rendimiento ',
                '',
                '- Esta caracteristica permite realizar acciones como: ',
                ' - Descubrir y modificar secciones de codigo en tiempo de ejecución ',
                ' - Evaluar una cadena como si fuera una sentencia de código fuente en tiempo de ejecución ',
                ' - Flexibilizar el tipado en lenguajes fuertemente tipados ',
            ]),
        new Item('asserts',
            [
                '- Todo codigo contiene algun tipo de restriccion, si estas no se documentan bien pueden inducir a errores ',
                '- La documentación extensiva tampoco es una buena idea ya que modificar codigo conlleva a modificar la documentación tambien ',
                '- Las aserciones son predicados que se evaluan como ciertos o falsos en tiempo de ejecución ',
                '- Estas comprobaciones favorecen el proceso de detectar errores y garantizar las condiciones de funcionamiento ',
                '- Son una opción a considerar si se quiere evitar la programación defensiva ',
            ]),
        new Item('excepciones',
            [
                '- Es la indicación de que se produjo un error en la ejecución del programa ',
                '- Estas pueden ser situaciones esperadas, inesperadas e incluso pueden se provocadas ',
                '- Las exepciones son objetos especializados con toda la información del error ',
                '- Estos objetos pueden ser atrapados por la instrucción try-catch y evitar que se detenga el programa, ',
                ' - o simplemente ser lanzados y terminar el programa de manera abrupta ',
                '- El manejo de excepciones es fundamental para conseguir programas robustos y confiables, por esto es ideal definir, ',
                ' - responsabilidades acerca de quienes pueden lanzar excepciones y quienes pueden atraparlas ',
            ]),
        new Item('scafolding',
            [
                '- Es la generación automatica de codigo funcional, archivos, carpetas, configuraciones, interfaces graficas, etc... ',
                '- Generalmente se basa en la creación de las operaciones CRUD, basandose en un modelo de datos previo ',
                '- Algunos frameworks pueden ayudar en este sentido, e incluso existen aplicaciones con este proposito ',
            ]),
        new Item('cache',
            [
                '- La cache existe para diminuir la latencia e incrementar el rendimiento en operaciones costosas ',
                '- Esta es recomendable usarla en los casos donde el rendimiento no es el esperado, ',
                '  - o si son recursos poco mutables y muy solicitados ',
                '- Esto significa que el sistema soporte operaciones de datos con consistencia eventual ',
                '',
                '- Tipos de cache: ',
                '- Local -> almacenamiento en memoria, ideal cuando la información es poca, predecible y poco mutable ',
                '  - esto puede conllevar a inconsistencias de los datos si hay diferentes instancias y problemas de rendimiento en la ejecución ',
                '- Centralizado -> se almacena de manera externa y este siempre esta en concordancia con las demás ',
                '  - al ser externa depende directamente de la latencia del medio en que este, y de su disponibilidad, además de su manejo ',
                '- Distribuida -> esta particionada y administrada por diferentes nodos que se comunican entre si ',
                '  - su manejo implica más complejidad ',
            ]),
        new Item('hilos',
            [
                '- Un hilo es una secuencia de control dentro de un proceso que ejecuta sus procesos de forma independiente ',
                '- Un proceso es una acción continua o serie de cambios, tareas que ocurren de manera definida ',
                '- El ciclo de vida de un proceso es el siguiente: ',
                '  Creacion -> Listo &larr;&rarr; Ejecución -> Terminado',
                '                            &darr;                     ',
                '                &uarr;	Bloqueado                       ',
            ]),
        new Item('argumentos',
            [
                '- En java los argumentos siempre se pasan por valor, esto significa que siempre se pasa el valor de la variable, ',
                ' - y no la referencia en memoria de la variable, por lo que siempre es una copia del original ',
                '- Las copias se pueden hacer del valor para datos primitivos, o una copia con la dirección de memoria si es un objeto ',
                '- Esto no modifica la variable original, ya sea un tipo primitivo o un objeto ',
                '- Algunas clases son inmutables por lo que los objetos originales nunca son modificados, ',
                ' - solo se devuelve una nueva instancia con los cambios en vez de la original ',
            ]),
        new Item('concurrenciaParalelismo',
            [
                '- Concunrrencia -> es la capacidad de realizar muchas tareas a la vez, con ó sin una secuencia especifica ',
                '- Paralelismo -> es la capacidad de ejecutar 2 ó más acciones de manera simultanea ',
                '',
                '- Para implementar concurrencia se recomienda usar Hilos, en cambio ',
                '- Para implementar paralelismos se optara por usar Procesos ',
                '',
                '- Aunque la programación concurrente tiene problemas en cuanto a la coherencia de los datos, ',
                ' - es bastante util para resolver problemas de rendimiento ',
                '- En cambio si el orden de las tareas es importante y tanto el inicio como el fin tambien, ',
                ' - la programación paralela es mejor debido a su aislamiento inherente ',
            ]),
        new Item('ortogonalidad',
            [
                '- Basicamente significa que cuando hacemos una accion esta no debe modificar lo que no le respecta ',
                '- Tambien se puede interpretar de manera que cuando se ejecute una instrucción solo se ejecute esta y nada más ',
            ]),
        new Item('boilerPlate',
            [
                '- Este hace referencia a codigo repetitivo que no siempre es util, pero si requerido, aun aveces cuando no vaya a ser usado ',
                '- Esto tambien aplica para fragmentos de codigo propios, ya que se reutiliza codigo, con solo copiar y pegar ',
                '- El boiler plate es diferente del scafolding, ya que este primero es más de copiar y pegar, ',
                ' - en cambio el segundo esta relacionado con mantener estandares y formas de uso ',
                '- Un ejemplo de esto es el uso de getters y setters en POO para modificar los objetos, ',
                ' - aunque estos cambian de acuerdo al objeto, su función y su forma son casi siempre identicas ',
            ]),
    ];

export const CONOCIMIENTOS_EMPIRICOS =
    [
        new Item('balas',
            [
                '- El software puede tener dificultades inherentes al software y accidentales ',
                '- Los errores son gajes del oficio, pero tienen diferentes grados de repercusión en el software ',
                '- Jamas sera lo mismo un error semantico a uno de diseño, el primero podria pasar por trivial, pero el segundo NO ',
                '',
                '- Complejidad -> la complejidad es directamente proporcional al tamaño ',
                '- Complejidad -> esta es una propiedad intrinseca del software, que no se puede desligar de su diseño o construcción ',
                '- Complejidad -> de esta complejidad nacen las dificultades para crecer sin afectar al resto del sistema ',
                '- Complejidad -> sin contar con los problemas tecnicos ó las dificultades de aprendizaje ',
                '',
                '- Conformidad -> tener que ajustarse a otros diseños, necesariamente implica algo más que una refactorización ',
                '- Conformidad -> no hay una sola manera para trabajar, por lo que hay acostumbrarse a las diferentes formas de cada persona ',
                '',
                '- Variabilidad -> El software esta sometido a la necesiadad de cambio constante, pero esto no necesariamente significa un "cambio" ',
                '- Variabilidad -> Se podria sacar un nuevo modelo ó una nueva versión, más no obligatoriamente cambiar lo que ya funciona ',
                '',
                '- Invisibilidad -> El software es un recurso intangible, solo entendible por la capacidad de abstracción y de visualización de los humanos ',
                '',
                '- Para revisar los demás temas puedes ir a la fuente original ',
            ]),
        new Item('lehman',
            [
                '- El contenido es eterno, pero no la materia que lo contiene ',
                '- Ley del cambio continuo -> En la realidad las cosas deben seguir cambiando constantemente, de lo contrario eventualmente seran obsoletas ',
                '- Ley de complejida creciente -> Mientras algo siga creciendo, su complejidad tambien lo hara, a no ser que se tomen medidas para reducirla ',
                '- Ley de evolución -> mientras algo crezca, tambien lo haran sus errores, casi siempre de manera promedio ',
                '- Ley de estabilidad organizacional -> la velocidad de desarrollo sera casi siempre la misma, por más recursos que se inyecten ',
                '- Ley de la conservación -> un crecimiento desmesurado hara que el conociemiento basico sea insuficiente para seguir creciendo ',
                '- Ley de crecimiento continuo -> las funcionalidades deben seguir mejorando para mantener a los clientes satisfechos ',
                '- Ley de retroalimentación -> la comunicación con el cliente y con las personas conocedoras es fundamental ',
            ]),
        new Item('conway',
            [
                '- El impacto de la comunicación en tu empresa ',
                '- “Cualquier organización que diseñe un sistema producirá un diseño que copia la estructura de comunicación de dicha organización.”',
                '- El software es una habilidad intelectual humana, por lo que la comunicación es fundamental para la integración ',
                '- La manera de trabajar de tu empresa se vera reflejada en tu software, es el significado principal de esta frase ',
                ' - Equipos pequeños, crearan soluciones pequeñas, altamente modulares ',
                ' - Personas egoistas, generan problemas de integración de componentes y falencias al compartir su conocmiento ',
                ' - Empresas sin organización, generaran codigo complejo, pero funcional de manera rapida, que se convertira en una bola de nieve ',
                ' - Empresas orgullosas, que comparten su codigo y sus buenas practicas ',
                ' - Estos y más ejemplos hay, como empresas y personas halla ',
            ]),
        new Item('murphy',
            [
                '- Si algo malo puede pasar, pasara',
                '- Se inspira en el concepto fisico de la entropia, el cual dicta que todo sistema fluye del orden al desorden ',
                '- Puede ser util para ayudar a prevenir el desastre, si se usa para tomar precauciones ',
                '- No hay ninguna demostración matematica que la niegue ó la acepta, solo es un conocimiento nacido de lo cotidiano ',
            ]),
        new Item('cristales',
            [
                '- Esta teoria predice que los desperfectos del ambiente van a generar la sensación de que la ley no existe ',
                '- Corregir los errores, aun por más por pequeños que sean evitara que el software se degenere ',
                '- Las pequeñas faltas pueden conllevar a transgresiones mayores ',
                '- Establcer normas claras ayuda a evitar este fenomeno ',
            ]),
        new Item('tiposProgramadores',
            [
                '- Estos son los 5 principales tipos de programadores que existen ',
                '',
                ' - The duct tape: ',
                '   - Este programador arreglara el error sin importale como, ',
                '   - la prioridad para el siempre sera arreglar el error, sin importar la complejidad de la solución ',
                '',
                ' - The perfectionist programmer ',
                '   - Para este programador cada segmento de codigo es una obra de arte, ',
                '   - no le importan las fechas limites ó los presupuestos, solo que el codigo generado sea hermoso eficiente, ',
                '   - e inmutable, a menos que sea el mismo quien lo cambie ',
                '',
                ' - The anti-programming programmer ',
                '   - Es aquel que siempre evitara reinventar la rueda, ya sea usando librerias de terceros',
                '   - ó usando codigo ya hecho por alguien más, pero siempre obtendra la solución más simple, ',
                '   - aunque esta no sea eficiente o retrocompatible, pero si sera facil de entender',
                '',
                ' - The half-assed programmer ',
                '   - Este programador es el más odiado por los demás tiposProgramadores, ya que solo le importa cumplir con su tarea, ',
                '   - la calidad ó la eficiencia son solo utopias con el, y lo más seguro es que generara problemas a largo plazo, ',
                '   - siempre sera eficaz a cuanto a los tiempos de entrega, aunque esto dañe otras partes del sistema ',
                '',
                ' - The theoretical programmer ',
                '   - Para este programador siempre habra n maneras de resolver algo, la mayoria de su tiempo lo ocupara pensando como ',
                '   - resolver el problema de la mejor manera, por lo que la manera que escoja para hacerlo nunca lo satisfacera al 100%, ',
                '   - pero entregara codigo a tiempo y con buena calidad ',
            ]),
        new Item('quo',
            [
                '- Es la preferencia innata del ser humano a la estabilidad ',
                '- Nuestras emociones son un punto de inflexión a la hora de tomas decisiones que arriesguan esta estabilidad ',
                '- Este fenomeno esta ligado a otros más comunes y que se viven casi a diario ',
                '',
                ' - Aversión a las perdidad -> es un efecto donde es más facil aferrarse a una cantidad u objeto en el que haya invertido tiempo y dinero, ',
                '   - que adquirir o construir uno nuevo que representara una ganancia, mayor a la actual ',
                ' - Efecto de dotación -> los bienes se perciben de manera más valiosa cuando son de nuestra propiedad, ',
                '   - Aunque este mismo bien sea el mismo que el de otra persona ',
                '',
                '- Estos fenomenos se pueden dar en el mundo del software al no realizar refactors en el codigo solamente porque, ',
                '  - "funciona", aunque lo haga de manera complicada u poco optima ',
            ]),
        new Item('costo',
            [
                '- La falacia del costo hundido es la tendencia a mantener proyectos fracasados ó obsoletos ',
                '- Esto se debe al tiempo y gastos invertidos en los proyectos, que no queremos soltar por la aversion a las perdidas ',
                '',
                ' - En la industria del software es comun tener casos donde hay sistemas que constantemente deben ser parcheados, ',
                '   - costando tiempo y dinero, y donde la solucion más optima seria rehacer el sistema que continuar con este tipo de situaciones ',
                ' - Tambien estan los casos donde las personas se niegan a abandonar proyectos estables, pero que eventualmente seran obsoletos ',
                '   - ya que migrar esto implica un costo, que puede ser menor que mantener a un proyecto legacy; pero esto no se ve a corto plazo ',
            ]),
        new Item('sesgos',
            [
                '- Son impulsos inherentes a cada ser humano que se basan en sus emociones, conocimientos, experiencias, creencias, etc.. ',
                '- Es la interpretación erronea de la información disponible, y como esto afecta nuestra emisión de juicios ',
                '',
                ' - Sesgo de confirmación -> es la busqueda de sucesos ó interpretaciones para confirmar algo que creemos de manera arraigada ',
                ' - Disponibilidad heuristica -> es un atajo mental que otorga más valor o credibilidad a la primera información que recordemos ',
                ' - Sesgo de anclaje -> es basarse en la primera información y solo esta fuente para tomar una decisión, sin evaluar otras posibilidades ',
                ' - Sesgo de observación selectiva -> es cuando diriges toda tu atención solamente a lo que te interesa, sin presta atención a los demás datos ',
                ' - Sesgo negativo -> te enfocas en los sucesos negativos en vez de tomar una posición más neutra ',
                ' - Resistencia reactiva -> se enfoca en hacer lo contrario de lo que alguien te dice ó aconseja, de manera selectiva y racional ',
                ' - Sesgo de impacto -> es la tendencia a sobrestimar un evento o lugar extraordinario, que pasara de lo excepcional a lo comun ',
            ]),
        new Item('multitarea',
            [
                'Es la capacidad de manejar y realizar multiples tareas al mismo tiempo, este concepto es muy buscado actualmente, aunque tiene pros y contras ',
                '',
                '- Ventajas',
                ' - Si se logra hacerlo de manera eficiente, se pueden ahorrar recursos y aumentar la productividad ',
                ' - Mejor reacción a las tareas complejas y un mejor manejo de las responsabilidades ',
                '',
                '- Contras ',
                ' - Menor eficacia, al tener un mayor ruido de las acciones por hacer ',
                ' - Decaimiento de la memoria y posibles problemas de estres, además de una peor salud fisica y mental ',
                ' - Mayor riesgo de errores al tener que estar atento a más cosas ',
                ' - Menor calidad del trabajo, además de posibilidades de sufrir de deficit de atención ',
            ]),
        new Item('maxwellCurve',
            [
                '- Más horas de trabajo, implican menos productividad',
                '- Este estudio fue realizado principalmente para Scrum, hasta la demostración de que en ciertos casos es más optimo el modelo de cascada ',
                '- Jornadas más cortas no necesariamente significan menos productividad, estas pueden ayudar a: ',
                ' - atraer nuevos talentos',
                ' - mejorar el equilibrio entre vida personal y laboral, teniendo trabajadores más felices ',
                ' - reduce los sentimientos de insatisfacción ',
            ]),
        new Item('pendulo',
            [
                '- Permite explicar comportamiento humanos cuando son llevados al extremo ',
                '- Se puede producir por diferentes razones: ',
                ' - Idealización del opuesto -> cuando estamos constreñidos en algo, tendemos a idealizar el contrario ',
                ' - Necesidad de reafirmación -> buscando un gran impacto, generalmente elegimos los polos opuestos al ser vistosos ',
                ' - Comodidad del extremo -> son comodos ya que no tienen contenciones ni filtros, lo opuesto de una posicion intermedia ',
                '',
                '- Los extremos no necesariamente son malos, ya que permiten tener nuevas experiencias, y conocer nuevos puntos de vista ',
                '- Esto se debe hacer de manera racional, y bajo nuestra propia elección, para que podamos reflexionar en vez de seguir ciegamente ',
            ]),
        new Item('prejuicios',
            [
                '- El primer paso es aceptar que todos tenemos segos cognitivos, estemos concientes o no de ellos ',
                '- Para combatirlos se pueden usar diferentes estrategias como: ',
                '',
                ' - Evitar el "punto ciego" -> todos estamos sesgados, el primer paso para evitarlo es aceptarlo ',
                ' - Para evitar la "subjetividad" -> es ideal tener un equipo diverso y participativo ',
                ' - No usar el "muro tecnico" -> para eludir o evitar cuestionamientos incomodos ',
                ' - Planificar e investigar para salir de nuestra zona de comfort, nos ayuda a encontrar más soluciones ',
                ' - Realiza pruebas, no siempre todo funciona o funciona como deberia ',
                ' - Mantener afinidad con una persona no significa que debemos de dejar de prestar atención a los demás ',
                ' - No aceptar la innovación puede ser tan malo como siempre estar al filo de la vanguardia ',
            ])
    ];
