import * as Keys from '../keys'
import { Item } from "../models";

export class Content4 {

    public temas: Item[] = [
        ...AGILES,
        ...ARQUITECTURAS,
        ...CONTENEDORES,
        ...ESTRATEGIAS_DESARROLLO,
        ...FRAMEWORKS,
        ...LEYES,
        ...MALAS_PRACTICAS,
        ...META_CARACTERISTICAS,
        ...POO,
    ];

}

export const AGILES =
    [
        new Item('moscow',
            [
                '- Es una tecnica para la priorización de requisitos y funciones para lograr un alcance especificado, ya sea en etapas iniciales o para un <em>MVP</em>',
                '',
                '<strong><em>M</em>ust Have</strong> (Debe tener):      Este requisito debe estar implementado si ó si, si no, el producto es un fracaso ',
                '<strong><em>S</em>hould have</strong> (Deberia tener): Requisito de alta prioridad que en la medida de lo posible deberia quedar en el producto final ',
                '<strong><em>C</em>ould have</strong> (Podria tener):   Caracteristica deseable, pero que no es necesaria y solo sera implementada si hay posibilidades ',
                '<strong><em>W</em>on´t have</strong> (No tendra):      Son requisitos que estan descartados por esta vez, pero seran incluidos a futuro ',
                '',
                '<strong>Pros:</strong> Tecnica simple de usar, al basarse en principios simples, además de la experiencia humana',
                '<strong>Contras:</strong> Si no hay liderazgo o experiencia previa, la subjetividad sera poco efectiva ',
            ]),
        new Item('scoring',
            [
                '- Permite determinar la prioridad de las funcionalidades, basandose en diferentes criterios, que a su vez ',
                ' - constan con diferentes pesos, cada caracteristica de la Historia de Usuario tendra un valor ',
                '- Determinar el peso de las caracteristicas es más facil ya que se hace en base a una comparación, ',
                ' - donde previamente se ha tomado una HU como punto base y las demás se miden con esta base ',
            ]),
        new Item('muda',
            [
                '- El desperdicio en las empresas viene del termino japones MUDA, que es todo lo inutil, superfluo, despilfarro, residuos, ocioso ',
                '',
                '<strong>- Sobreproducción:</strong> Producir más de lo demandado, esperando que el mercado lo necesite es una mala praxis, que despilfarra recursos de otras areas ',
                '<strong>- Esperas:</strong> Son los famosos cuellos de botella, donde un proceso alenta a los demás, haciendo perder tiempo a todo el proceso ',
                '<strong>- Transporte:</strong> Todo movimiento innecesario de elementos que no aporta valor debe ser minimizado ',
                '<strong>- Sobre procesos:</strong> Son procesos que aunque pueden ser utiles, no van a volver ser usados, por eso su realización es un desperdicio ',
                '<strong>- Exceso de inventario:</strong> Puede conllevar a perdidad monetarias a la empresa, debido a que se pueden volver obsoletos, o nunca usarse ',
                '<strong>- Movimientos innecesarios:</strong> Todo movimiento que no aporte valor al producto es un despedicio, hasta caminar al trabajo puede serlo ',
                '<strong>- Defectos:</strong> Todo error consume tiempo para ser resuelto, independientemente de su tamaño, además de la insatisfacción del cliente ',
            ]),
        new Item(Keys.AGILES_5S,
            [
                'La metodologia <strong>Kaizen</strong> es una concepción oriental hacia la calidad total, la base de la mejora continua ',
                '',
                '<strong>Seiri:</strong> Clasifica y organizar de manera apropiada, retirarando del area todo aquello que no es necesario ',
                '<strong>Seiton:</strong> Orden, organizar los elementos necesarios de manera que sean de facil acceso ',
                '<strong>Seiso:</strong> Limpieza, ya con un orden establecido y areas limpias, es más facil detectar malas practicas ',
                '<strong>Seiketsu:</strong> Estandares, este estado solo se obtiene cuando la limpieza y la organización se mantienen constantes ',
                '<strong>Shitsuke:</strong> Disciplina, es la creación de habitos que eviten el rompimiento de los conceptos anteriores ',
                '',
                '¿ Porque no la aplican algunas empresas ? ',
                '<strong>- La maquinaria no puede parar:</strong> Los cronogramas no dan tiempo de mantenimiento de la maquinaria ',
                '<strong>- La limpieza como perdida de tiempo:</strong> Algunos empleadores pagan para trabajar, no para limpiar su area de trabajo ',
                '<strong>- Costumbre:</strong> Crear nuevos habitos y cambiar los viejos es un cambio fuerte y prolongado de paradigma ',
                '',
                '<strong>Beneficios</strong>',
                '- Mayor seguridad de los empleados ',
                '- Reducción de las perdidas y mermas por defectos ',
                '- Mayor calidad, y menos tiempo de respuesta ',
                '- Genera una cultura organizacional ',
            ]),
        new Item('mudaSoftware',
            [
                '<strong>Trabajo hecho a medias:</strong> Desplegar sin probar y tener errores conocidos más no solucionados, ',
                ' - daran problemas a futuro, de manera que aveces es mejor un nuevo desarrollo que corregir lo existente ',
                '',
                '<strong>Funcionalidad extra:</strong> Toda funcionalidad que no haya sido pedida significa, recursos gastados sin redito alguno ',
                '',
                '<strong>Reaprendizaje:</strong> Nuestra memoria no es absoluta, por lo que inevitablemente olvidaremos cosas, ',
                ' - y gastaremos tiempo volviendolas a aprender, tambien aplica para personas expertas o proyectos mal documentados; ',
                ' - que ya existe el conocimiento, pero nos empeñamos por aprenderlo nosotros mismos, sumando tiempo al desperdicio ',
                '',
                '<strong>Transferencia de conocimiento:</strong> Todo proceso de comunicación es ineficiente ya que, ',
                ' - durante el proceso se suelen perder datos u omitir detalles importantes, y asi entre más niveles ',
                ' - haya que permear, de las mejores manera para evitar esto son la comunicación cara a cara ',
                '',
                '<strong>Retrasos:</strong> Algunas funcionalidades requieren que sean lineales, por lo que si la etapa previa se retrasa, ',
                ' - las etapas subsiguientes tambien lo haran, por lo que estas situaciones deben ser evitadas lo más posible ',
                '',
                '<strong>Cambios de contexto:</strong> Cuando tenemos varias cosas por hacer de manera inmediata, tendemos a ser multitarea, ',
                ' - esto no es más que un cambio de contexto que requiere tiempo y esfuerzo, y que entre más se hagan, más desperdicio habra ',
                '',
                '<strong>Defectos:</strong> Uno de los más peligrosos, ya que entre más tarde se encuentre un error, más costoso sera corregirlo ',
                ' - estos errores se pueden disminuir por medio de las pruebas, e integración continua ',
            ]),
        new Item(Keys.AGILES_PLANNING_POKER,
            [
                '- Las estimaciones son de mucha ayuda, para definir tiempo, costos y esfuerzos, en base a la información disponible ',
                '- Independientemente de la certeza, con que se hayan realizado, generalmente casi nunca se cumplen ',
                '- Ayuda a visualizar desde diferentes puntos de vista, esto es bastante util para analizar un problema ',
                '- Los riesgos pueden ser detectados de manera previa, además de prever posibles obstaculos ',
                '- Todo el equipo involucrado deberia estar presente en este evento, ya que todos pueden aportar desde sus areas ',
                '',
                '<strong>Material necesario:</strong> Cada participante debe tener su baraja, que es una secuencia de <em>Fibonacci</em> modificada, junto a ciertas cartas especiales: ',
                '  <strong>Infinito:</strong>   Es una HU que es demasiado grande para ser estimada, por lo que debera ser dividida y reorganizada ',
                '  <strong>Cero:</strong>       Significa que la HU ya fue realizada ',
                '  <strong>Coffee cup:</strong> Puede significar una actividad de esfuerzo minimo o simplemente la necesidad de realizar una pausa ',
                '',
                '<strong>Trabajo previo:</strong> ',
                ' - Es necesario indicar que indica cada numero antes de realizar el ejercicio, (horas, dias, esfuerzo, etc...)',
                ' - Indicar que incluye y que no la HU, documentación, tests unitarios, tests de integración ',
                '',
                '<strong>Dinamica:</strong> ',
                ' - Se especifica todo lo que se va a estimar y se hacen las preguntas y respuestas pertinentes ',
                ' - Se leen la historia de usuario y se vota por medio de la baraja ',
                ' - Si no hay consenso se abre una breve discusión y se vuelve a votar, si vuelve a suceder se podra realizar un promedio o escoger un extremo ',
                ' - Se repite el proceso hasta completar todas las HU ',
            ]),
        new Item(Keys.AGILES_MANIFEST_AGIL,
            [
                '- Nace con el proposito de reformar el desarrollo de software para hacerlo más eficiente y eficaz ',
                '- Son 4 principios que toda metodologia agil lleva a cabo para mejorar el desarrollo ',
                '',
                '- Individuos e interacciones <strong>SOBRE</strong> procesos y herramientas ',
                '- Software funcionando <strong>SOBRE</strong> documentación extensiva ',
                '- Colaboración con el cliente <strong>SOBRE</strong> negociación contractual ',
                '- Respuesta ante el cambio <strong>SOBRE</strong> seguir un plan ',
            ]),
        new Item('principlesAgile',
            [
                ' 1 - La maxima prioridad es satisfacer al cliente mediante la entrega temprana y continua de software de valor ',
                ' 2 - Los requisitos cambiantes son bienvenidos, estos se aprovechan para la ventaja competitiva del cliente ',
                ' 3 - Entrege software funcional, con frecuencia y a en la menor escala posible ',
                ' 4 - El negocio y los desarrolladores deben trabajar juntos, constatemente durante el proyecto ',
                ' 5 - Construir proyectos en torno a personas motivadas, y confie en ellas para hacer el trabajo ',
                ' 6 - El metodo más eficiente para transmitir información, siempre sera una conversación cara a cara ',
                ' 7 - Software que funciona es la medida principal del progreso ',
                ' 8 - Los procesos agiles promueven el desarrollo sostenible, todas las partes involucradas deberian ser constantes ',
                ' 9 - Atención continua a la excelencia tecnica, un buen diseño y la mejora continua ',
                '10 - La simplicidad es el arte de maximizar el trabajo no realizado es esencial ',
                '11 - Las mejores arquitecturas, requisitos y diseños surgen de equipos colaborativos y autoorganizados ',
                '12 - Regularmente, el equipo reflexiona en como volverse más efectivo, luego sintoniza y ajusta su comportamiento ',
            ]),
        new Item(Keys.AGILES_SPIKE,
            [
                '- Es un termino que viene desde Xtreme Programing y que esta rodeado por la incertidumbre ',
                '- Este es un elemento del backlog del producto, que tiene bastante incertidumbre tecnica o funcional, y no se puede planificar o estimar ',
                '- Aun con esta incertidumbre, se debe definir un tiempo maximo de duración, y los resultados o conclusiones que se esperan obtener ',
                '',
                '<strong>Spike tecnico:</strong> Son ocasiones donde no se conoce la tecnologia a usar o hace falta profundizar en ella, ',
                ' - buscar información o aprender de la documentación, con el fin de tomar deciones tecnicas ',
                '<strong>Spike funcional:</strong> Hace falta conocer más sobre los requisitos y/o alcance, como que se va a incluir, ',
                ' - documentar escenarios, entrevistar a un experto del negocio, revision de codigo ',
            ]),
        new Item(Keys.AGILES_DEMING,
            [
                '- Es un sistema que busca la optimización constante de las actividades empresariales, constando de 4 etapas ciclicas ',
                '- Tambien es conocido como ciclo PDCA por sus etapas <em>Plan, Do, Check, Act </em>',
                '',
                '<strong>Planificar </strong> 1 etapa, Donde se identifican los problemas, se crean objetivos para solucionarlos y se asignan deberes',
                '<strong>Hacer      </strong> 2 etapa, Se empiezan a trabajar en los cambios, de manera supervisada, para lograr lo planteado ',
                '<strong>Verificar  </strong> 3 etapa, Despues de un periodo de tiempo previamente definido se evaluan los resultados, ',
                ' - en base a los KPI seleccionados para cada objetivo, determinando la eficiencia y eficacia ',
                '<strong>Actuar     </strong> 4 etapa, Se toman decisiones en base a los aprendizajes obtenidos, ',
                ' - ya sea tomando acciones correctivas si hubo fallas, ó documentando e integrando nuevos cambios si los resultados fueron optimos ',
                '',
                '- Generalmente este ciclo es usado para mejorar la logistica de las empresas, pero tambien es aplicable a otras areas ',
                '',
                '<strong>Ventajas:</strong>',
                '<strong>- Mejora continua:</strong> Mejorando las areas debiles y manteniendo fuertes las ya existentes ',
                '<strong>- Incremento de la productividad:</strong> Al reducir tiempos muertos, y procesos tardios ',
                '<strong>- Ilimitado:</strong> Al ser un ciclico, puede ser aplicado cuantas veces sea necesario, e incluir otras areas tambien ',
                '',
                '<strong>Desventajas:</strong>',
                '<strong>- Lentitud:</strong> La ejecución de las etapas debe ser metodica, y no es aplicable para situaciones a corto plazo, como emergencias ',
                '<strong>- Suceptible a imprevistos:</strong> Su efectividad depende de que el ambiente sea favorable y sin contratiempos ',
            ]),
        new Item(Keys.AGILES_ESTIMATION_LAWS,
            [
                '- La estimación agil es de algun modo un arte algo engañoso, y al mismo tiempo es fundamental en el exito del proyecto/producto/servicio ',
                '',
                '<strong>Ley de Parkinson:</strong> El trabajo se extiende hasta agotar el tiempo posible, debido a la tendencia humana de prolongar una tarea, ',
                ' - para ajustarse al tiempo estimado, por lo que se deben establecer plazos realistas y evitar retrasos innecesarios en lo posible ',
                '',
                '<strong>Ley de Deuda Tecnica:</strong> El costo a largo plazo, debido a acortar demasiado los plazos estimados, y haciendo un trabajo deficiente ',
                ' - puede ser eficiente al inicio, pero a largo plazo puede generar retrasos y problemas, e incluso acarrear una bola de nieve insostenible ',
                '',
                '<strong>Ley del Error:</strong> Toda estimación esta atada al error, es algo inherente que siempre se debe tener en cuenta en el proceso ',
                '',
                '<strong>Ley de Precisión de la estimación:</strong> A medida que avanzamos en un proyecto, las estimaciones se vuelven más precisas, mientras que ',
                ' - la incertidumbre se va reduciendo y la gestión de riesgos se vuelve cada vez más madura; el <em>Cono de incertidumbre</em> ilustra este concepto ',
                '',
                '<strong>Ley de Probabilidad 0 a la hora de subestimar:</strong> Por más que se inyecten recursos/personal las tareas siempre tendran un umbral ',
                ' - minimo que no se puede superar, por más que se recorten la estimación ',
                '',
                '<strong>Ley de Brooks:</strong> Agregar más personas, no es garantia de recortar tiempo, contrario a lo que se espera, agregar personal ',
                ' - a un proyecto atrasado, no garantiza una finalización más rapida, lo atrasara aun más ',
            ]),
        new Item('requisitosAgiles',
            [
                '- La Prescripción, una de las diversas formas de llamar la intención de adivinar o acotar el futuro',
                '- Existen 3 leyes que nos recuerdan los problemas de intentar adivinar el futuro, y documentarlo sin siquiera haber empezado ',
                '',
                '<strong>Ley de Ziv:</strong> Los requisitos nunca se entienden completamente ',
                '<strong>Ley de Humphrey:</strong> Los usuarios no saben realmente el software que quieren, hasta que lo ven funcionando ',
                '<strong>Lema de Wegner:</strong> Un sistema interactivo, nunca podra ser ni especificado ni testeado por completo',
            ]),
        new Item(Keys.AGILES_OUTPUT_AND_OUTCOME,
            [
                '- En la actualizadad, todavia es dificil determinar la relación de lo que realizan los equipos y el valor de negocio generado a la compañia ',
                '- Los gerentes piensan en maximizar el valor generado (<em>Impacto</em>), lo cual se puede traducir en en mayores ingresos, mejor imagen, o nuevos mercados ',
                '- Por otro lado los equipos agiles, estan preocupados del <em>Output</em> que consiste en indicadores asociados a realizar entregables, como: ',
                ' - puntos de historia, velocidad, nuevos features, cantidad de usuarios por sprint, sin embargo ambos indicadores no tienen relación entre si ',
                '- Sin una relación directa, es dificil medir causas y efectos, sin contar el retraso, ya que las acciones no tienen una afectación inmediata ',
                '- Una solución a este problema es el concepto de <em>Outcome</em> el cual une ambos conceptos, se define como: ',
                ' - <em>Un cambio en el comportamiento humano que conduce a un resultado positivo, en el negocio(impacto)</em> como clientes o colaboradores ',
                '- Para encontrar estos Outcomes, no es una tarea sencilla, se requiere practica y dedicación con foco en el cliente, y existen tecnicas como: ',
                '',
                '<strong>Las 3 preguntas:</strong>',
                '- La primera pregunta, es determinar los comportamientos de los clientes(Outcomes) que son beneficiosos para el Impacto',
                '- Luego se debe descubrir como generar más de esos comportamientos y mediante cuales entregables(Outputs) se pueden aumentar ',
                '- Finalmente se debe retroalimentar sobre los resultados de estas acciones para comprobar los beneficios, mediantes ciclos cortos',
                '',
                '             <strong> Output                                           Outcome                                Impacto        </strong> ',
                ' Mejorar la cobertura de las pruebas unitarias      Disminuir reclamos de los clientes      Mejorar la impresión con los clientes      ',
                ' Reducción de la deuda tecnica                      Reducción y solución de errores         Aumentar la calidad del software           ',
                ' Realización de pruebas de regresión                                                                                                   ',
                '',
                ' Construir un pozo de agua, en el pueblo            Disminución de tiempos de traslado      Mejor calidad de vida para el pueblo       ',
                '',
                '',
                '<strong>Tecnica PRO:</strong> Problema-Remedio-Outcome',
                '- Se basa en la subjetividad y en la experiencia de los clientes para encontrar problemas',
                '- Y luego consultan con personas calificadas para encontrar posibles o viabilidad de las propuestas ',
                '- Sin embargo, no se tiene en cuenta la profundidad de los resultados(Outcomes)',
                '',
                '<strong>Outcome Mapping:</strong>',
                '- Esta tecnica permite encontrar los Outcomes deseados mediante reuniones presenciales y una exposición de ideas, con los objetivos deseados',
                '- Asi se definen los impactos estrategicos más deseados y como aumentarlos',
            ]),
        new Item(Keys.AGILES_PRIORITIZATION,
            [
                '- Priorizar los elementos del negocio, es un pilar fundamental en el desarrollo agil, para asegurar la entrega constante de valor ',
                '- Una adecuada priorización garantiza que los elementos de mayor impacto y valor para el cliente se aborden de manera relevante ',
                '- La priorización es importante ya que no solo ayuda a entregar valor, tambien maximiza la eficiencia y la adaptabilidad de los equipos ',
                '',
                '&brvbar;                  <strong>Matriz de Eisenhower</strong>                  &brvbar;  Permite centrarse en lo que es crucial a corto y largo plazo ',
                '&brvbar;  Importante, No urgente:    &brvbar;  Importante y urgente:   &brvbar; ',
                '&brvbar;   Decidir cuando hacerlo    &brvbar;   Hacer inmediatamente   &brvbar; ',
                '&brvbar; ------------------------------------------------------ &brvbar;        ',
                '&brvbar;  Ni Importante, Ni urgente  &brvbar;  No importante, urgente  &brvbar; ',
                '&brvbar;   Se puede demorar          &brvbar;   Delegarlo              &brvbar; ',
                '',
                '',
                '&brvbar;    <strong>Matriz de Impacto - Esfuerzo</strong>    &brvbar;  Se puede enfocar los recursos en actividades ',
                '&brvbar;  Alto Impacto   &brvbar;  Alto Impacto    &brvbar;   con maxima recompensa y menor esfuerzo',
                '&brvbar;  Poco Esfuerzo  &brvbar;  Mucho Esfuerzo  &brvbar;',
                '&brvbar; ---------------------------------- &brvbar;',
                '&brvbar;  Poco Impacto   &brvbar;  Poco Impacto    &brvbar;',
                '&brvbar;  Poco Esfuerzo  &brvbar;  Mucho Esfuerzo  &brvbar;',
                '',
                '',
                '&brvbar;                     <strong>Matriz de Kano</strong>                    &brvbar;  Ayuda a comprender que caracteristicas satisfacen al cliente ',
                '&brvbar;  Funcionalidad atractiva    &brvbar;  Funcionalidad Deseada  &brvbar;   y construir productos que destaquen en el mercado ',
                '&brvbar;  Me satisface tenerla       &brvbar;  Me satisface tenerla   &brvbar;',
                '&brvbar; ----------------------------------------------------- &brvbar;       ',
                '&brvbar;  Funcionalidad Irrelevante  &brvbar;  Funcionalidad Basica   &brvbar;',
                '&brvbar;  No me satisface            &brvbar;  Me molesta no tenerla  &brvbar;',
            ]),
        new Item(Keys.AGILES_STAR,
            [
                '- Es una tecnica usada por Recursos humanos para seleccionar personal pero puede ser usada en la creación de Tareas y HUs',
                '',
                '<strong>Situación:</strong> Se describe una situación o reto por el cual se deba atravesar en un lenguaje neutro ',
                '- La situación debe ser relevante y especifica de manera que fomente la reflexión pero se eviten ambiguedades/malentendidos ',
                '',
                '<strong>Tarea:</strong> Se indaga sobre la tarea o responsabilidad que se tiene para evaluar la situación descrita ',
                '- Es importante tener en cuenta detalles y el contexto sobre el que se da la acción ',
                '',
                '<strong>Acción:</strong> Son las acciones que se van a hacer para acercarse a la situación y que decisiones se han tomado ',
                '- Fomentar el analisis y observar desde que perspectivas se va a abordar el problema ',
                '',
                '<strong>Resultado:</strong> Se buscan resultados cuantificables y medibles, consecuencias de las acciones a corto y largo plazo',
                '- Es importante evaluar el aprendizaje y como se puede aplicar para futuras situaciones ',
            ])
    ];

export const ARQUITECTURAS =
    [
        new Item(Keys.ARQUITECTURAS_DEFINICION,
            [
                '- Representa la estructura que conforma al sistema completo ',
                '- Define y limita cada una de Las responsabilidades de cada una de las partes ',
                '- La organización y jerarquización de sus componentes ',
                '- Las propiedades visibles externamente y las relaciones a nivel interno ',
                '- Como se comunicaran y entre que componentes, definiendo flujos de datos y que protocolos usar ',
                '- Son independientes de las tecnologias, aunque su implementación pueda cambiar ligeramente entre una y otra ',
            ]),
        new Item('inicioArquitectura',
            [
                '- La arquitectura de software es importante ya que la estructura del proyecto tiene impacto directo sobre la capacidad de este ',
                '- Tambien afecta la satisfacción de atributos de calidad como el rendimiento y la mantenibilidad, además de otros ',
                '',
                '<strong>Etapas:</strong> ',
                '- <strong>Requerimientos:</strong> Captura, documentación y priorización de requisitos funcionales y No funcionales ',
                '- <strong>Diseño:</strong> Compleja y muy importante, aca se definen las estructuras del proyecto , uso de patrones, tecnologias, ',
                ' - con el fin de satisfacer de la mejor manera posible lo pactado en la etapa anterior ',
                '- <strong>Documentación:</strong> Antes y durante del desarrollo, es importante documentar el diseño del proyecto y el porque de las decisiones, ',
                ' - esto con el fin de acelerar el entendimiento del proyecto y/o realizar cambios de manera más efectiva ',
                '- <strong>Evaluación:</strong> Dado a su complejidad no esta mal visto revisar lo anteriormente hecho para encontrar posibles fallas y/o mejoras, ',
                ' - entre más temprano se encuentren los defectos, menos costo e implicaciones negativas tendra la solución ',
                '',
                '<strong>Roles:</strong> ',
                '- Conocer un amplio espectro de tecnologias ',
                '- Excelentes habilidades de comunicación, tanto a nivel tecnico como a nivel formal e informal ',
                '- Tener experiencia previa en el desarrollo de sus funciones y manejo de las etapas',
            ]),
        new Item('conceptosArquitectura',
            [
                '- Esto puede ser ambiguo, y se puede referir a multiples cosas, tales como: ',
                '<strong> Detalles de la implementación:</strong> Estructura de las carpetas y localización de componentes ',
                '<strong> Diseño de la implementación:</strong>   Decisiciones como, Server side ó Client side rendering, BD SQL ó NoSQL, entre otras ',
                '<strong> Tecnologias:</strong>                   Rest ó GraphQl, Node con Express ó Java con Spring, y muchas más opciones ',
                '<strong> Diseño del sistema:</strong>            Monolito ó Micro servicios ',
                '<strong> Infraestructura:</strong>               Un host autoadministrado ó un Proveedeor en la nube ',
                '',
                '<strong>Conceptos importantes, que hay que conocer previamente:</strong>',
                '- Client Server render ',
                '- Que es una API y algunos de sus tipos (REST, SOAP, GraphQl)',
                '- Protocolos como HTTP, FTP, SMTP y sus formatos (Json, XML)',
                '- Modularización de codigo, ¿ Esta bien dividida, de acuerdo a caracteristicas o comprensión ?, ¿ Que tan independientes, son las partes dividas ?',
                '',
                '<strong>¿ Como es su infraestructura ?</strong>',
                '- Monolitos ó Microservicios: Con microservicios, uno de los grandes problemas sera, que la comunicación con las paginas web sera más complicada ',
                ' - Normalmente esto se puede resolver con una capa intermedia que sabe como y a cual micro servicio redireccionar cada petición ',
                '- Balanceadores de carga: Cuando el trafico es demasiado, hay que crecer, y esto se puede hacer de manera vertical ó horizontal ',
                ' - Si hace horizontalmente (software), Es necesario que el trafico se reparta de manera equitativa, con ayuda de estos ',
                '',
                '<strong>¿ Donde vive su infraestructura ?</strong>',
                '- Administración propia: Permitiendo un control total sobre sus servicios, pero requiere tiempo, dinero y mantenimiento ',
                '- En la nube: ',
                ' - Tradicional: Se paga alguna configuración especifica, de acuerdo a las necesidades ',
                ' - Elastico: La capacidad del hardware crecera ó decrecera de acuerdo a la demanda, tambien puede ser vertical ó horizontalmente ',
                ' - Sin Servidor: Esta opción solo es usada bajo demanda, y solo se paga lo que se consuma, desapareciendo despues de su cometido ',
                '',
                '<strong>Organización de las carpetas:</strong>',
                '- Capas: Divide funciones y responsabilidades en carpetas relacionadas y restringe cuanto y quienes se conocen entre si ',
                '- MVC:   Modelo-Vista-Controlador, funciona como otra perspectiva de las capas, además de que incluye una UI (interfaz de usuario) ',
                '',
                '- Por lo tanto, una arquitectura puede ser una de estas secciones ó una combinación, todo <strong>depende</strong> de que se necesite ',
                '- Para ahondar en estos y otros temas, visita la publicación original ó mediante otras secciones propias ',
            ]),
        new Item('principiosArquitecturas',
            [
                '- Cualquier programador con cierto recorrido conoce el nombre de <em>Robert Martin</em> o su libro acerca de Clean Code',
                '- Tambien ha escrito acerca de Arquitecturas Limpias, ',
                '',
                '<strong>Clean Code:</strong> Buenas practicas de programación como: ',
                '- Codigo autocomentado ',
                '- Testing unitario y de integración ',
                '- Estructura comprensible ',
                '- Implementanción de los principios SOLID y uso de patrones',
                '',
                '<strong>Cohesion:</strong>',
                '<strong>Principio de equivalencia al Lanzar/Reutilizar:</strong> Esto nos dice que los componentes debe ser desplegados ',
                ' - de manera independiente sin afectar a los demás ',
                '<strong>Principio de cierre comun:</strong> Es la apliación de la S de SOLID a nivel de paquetes, donde se agrupan clases ',
                ' - que puedan cambiar por motivos en comun, todas en un mismo lugar ',
                '<strong>Principio común de reutilización:</strong> Evitar la dependencia de componentes que no se necesiten ',
                ' - para que solo se use lo realmente necesario',
                '',
                '- Conseguir el cumplimiento de estos 3 principios al mismo tiempo es dificil, por lo que se suele, sacrificar alguno más que otro ',
                '',
                '<strong>Acoplamiento:</strong>',
                '<strong>Principio de dependencias acíclicas:</strong> Cuando un cambio significa que se deben modificar más componentes, ',
                ' - y esto a su vez desencadena más cambios en el componente inicial, la estabilidad del sistema se ve comprometida ',
                '<strong>Principio de dependencias estables:</strong> Todo sistema tiene la tendencia natural de cambiar y evolucionar, ',
                ' - por lo que componentes volatiles deberian depender de componentes más estables pero no muy dificiles de cambiar ',
                '<strong>Principio de abstracciones estables:</strong> Los componentes estables que tienen poca variación deberian contar con ',
                ' - interfaces y clases abstractas, de esta manera es más extensible, sin tantas afectaciones en general ',
                '',
                '<strong>Una Arquitectura limpia tambien cumple las siguientes caracteristicas:</strong>',
                '- Son independientes de los frameworks en la mayor medida posible, ya que estos son herramientas y no obligaciones ',
                '- La logica de la aplicación es testeable y no depende de otras partes para esto ',
                '- La interfaz grafica depende de nuestra aplicación, no al contrario, los cambios en esta solo son relevantes para los usuarios ',
                '- La capa de persistencia, es agnostica, por lo que nuestra aplicación es minimamente afectada por la BD que este usando ',
                '- Los cambios externos, no deben afectar a los componentes internos ',
                '',
                '<strong>Definición de fronteras</strong>',
                '- Es una separación acerca que de puede y que no puede hacer un componente, para evitar acoplamientos indeseados entre componentes ',
                '- Un ejemplo de esto es, de quien es la responsabilidad de guardar la información, de la logica de negocio o de la base de datos ',
                '- Esto nos ayuda a pensar nuestra aplicación como una serie de elementos intercambiables, con minimas afectaciones en los demás ',
                '- Hacer esto es laborioso y tiene un nivel de complejidad y esfuerzo alto, por lo que en ciertos casos solo se hace de manera parcial ',
            ]),
        new Item(Keys.ARQUITECTURAS_CLEAN,
            [
                '- El concepto de arquitecturas limpias, fue presentado por <em>Robert C Martin</em> en 2010, y desde entonces ha ganado mucha popularidad',
                '- La idea principal es separar las preocupaciones en diferentes capas bien definidas, con reglas estrictas sobre como debe interactuar entre si',
                '',
                '<strong>Frameworks & Drivers</strong>      <strong>Interface Adapters</strong>     <strong>Aplication Rules</strong>     <strong>Enterprise rules</strong>  (de más externo a más interno)',
                ' Servicios                                                                           ',
                ' Bases de datos            Controladores                                             ',
                ' Web                 -->   Puertas de enlace  -->  Casos de uso   -->    Entidades   ',
                ' Interfaz de usuario       Presentación                                              ',
                ' Interfaces externas                                                                 ',
                '',
                '<strong>Partes de una arquitectura limpia</strong> (de más interna a más externa)',
                '<strong>- Entidades:</strong>    Contienen la logica de nuestra aplicación y solo deben cambiar si es estrictamente necesario ',
                '<strong>- Casos de uso:</strong> Reglas de negocio que especifican las acciones de nuestr aplicación, y son variables de acuerdo a las condiciones que se den ',
                '<strong>- Adaptadores:</strong>  Estas interfaces son las encargas de transformar los datos entre capas, para comunicarse entre el exterior y el interior ',
                '<strong>- Frameworks:</strong>   Es la capa más externa, donde van los detalles, como las tecnologias usadas, frameworks, bases de datos, etc...',
                '',
                '<strong>Patrones de diseño involucrados:</strong>',
                '- Principio de inversión de dependencias    - Patron Adapter',
                '- Inversión de Control                      - Patron Presentador',
                '- Inyección de dependencias                 - Patron repositorio',
                '- Separación de Conceptos',
                '',
                '<strong>Arquitecturas relacionadas:</strong> Arquitectura DDD, Arquitectura CQRS, Microservicios',
                '',
                '<strong>Consideraciones importantes:</strong>',
                '- Compresión del dominio del problema, fundamental para un modelado adecuado de todo el sistema',
                '- División clara de las responsabilidades, asi cada capa solo le conciernen sus responsabilidades',
                '- Inversión de dependencias, las dependencias se deben basar en las abstracciones, nunca en los detalles',
                '- Enfoque en el nucleo, este componente debe ser agnostico e independiente de todas las demás capas',
                '- Pruebas unitarias y de integración, todo componente importante deberia ser testeado, además de sus interacciones',
                '- Flexibilidad tecnologica, asi cualquier cambio o actualización no deberia afectar el funcionamiento del sistema',
                '- Escalabilidad y mantenibilidad, de manera que la degradación del codigo y futuros cambios sean sostenibles con el tiempo',
                '- Cultura entre los equipos, ya que se requiere de un compromiso y una comprensión compartida por los desarrolladores ',
            ]),
        new Item(Keys.ARQUITECTURAS_CAPAS,
            [
                '- Se basa en la distribución de roles y responsabilidades de forma jerarquica en cada capa ',
                '- Puede tener N capas, generalmente son 3, de la cual se desprende MVC ',
                '- La abstracción se mejora al definir la responsabilidad de cada capa y que interfaces se pueden usar/exponer ',
                '- Se aumenta la reutilización, al tener componentes especializados ',
                '- El desacople y la integración mejoran como resultado de una adecuada abstracción y definición de responsabilidades ',
                '- Con un alto grado de abstracción se pueden aislar ciertas capas y hacerlas independientes de las tecnologias ',
                '- Los cambios tienen bajo impacto y la mantenibilidad es más eficiente de hacer si hay una adecuada modularidad ',
                '- Es una arquitectura muy usada en aplicaciones web, sistemas de gestión de contenido y aplicaciones moviles ',
            ]),
        new Item('cliente',
            [
                '- Tiene 3 elementos principales y es una de las arquitecturas más usadas debido a su simplicidad ',
                '',
                '<strong>Servidor:</strong> Encargado de responder las peticiones, gestionar la concurrencia y la persistencia de los datos ',
                '<strong>Red:</strong>      Medio para la comunicación entre ambas partes ',
                '<strong>Cliente:</strong>  Dispositivos que hacen solicitudes, para crear/manipular/eliminar información ',
            ]),
        new Item(Keys.ARQUITECTURAS_HEXAGONAL,
            [
                '- Aisla el dominio de las tecnologias, permitiendo que los cambios entre tecnologias sean superfluos o minimos ',
                '- La comunicación entre componentes internos ó llamados externos se da por medio de puertos(interfaces) ',
                '<strong>- Puerto:</strong> Definición de la interfaz publica',
                '<strong>- Adapter:</strong> Especialización de un puerto, para un contexto especifico',
                '',
                '- Cualquier dispositivo/usuario/sistema podra consultar de forma homogenea la información y esta sera consistente ',
                '- Las capas que se hayan definido son idependientes entre si, sin estar totalmente aisladas ',
                '- Hay una definición clara de responsabilidades, permitiendo hacer testing más facilmente ',
                '- El termino hexagonal solo se da para resaltar la naturaleza similar de los puertos, no la cantidad de estos ',
                '- Una de las mayores motivaciones para esta arquitectura, es evitar el acoplamiento incorrecto con la infraestructura o la interfaz de usuario ',
                '- Tambien puede ser usada en conjunto con <strong>DDD</strong> ya que ambos se centran en que el negocio sea el nucleo '
            ]),
        new Item('noHexagonal',
            [
                '- Este modelo es una buena propuesta donde se circunscriben buenas practicas ya conocidas',
                '- En el sentido estricto de la palabra el desacoplamiento jamas sera mal visto en el desarrollo de software, ',
                ' - pero tomar conceptos ya existentes y renombrarlos de manera pretenciosa no los hace nuevos, toma conceptos de otras arquitecturas como: ',
                '',
                '<strong>- Arquitectura a capas:</strong> La separación de capas con funcionalidades especificas y que estas solo conozcan a sus vecinos adyacentes ',
                '',
                '<strong>- Arquitectura MVC:</strong> La importancia de separar estrictamente la presentación de los datos, la logica del negocio, ',
                '  - y la logica de control que efectua la función de intermediario',
                '',
                '<strong>- Pipes y Filters:</strong> Las tranformacion de los datos no pueden depender del estado interno, estas deben ser congruentes en todo momento ',
                '',
                '<strong>- El hexagono que no es:</strong> El uso de puertos y adaptadores no solo se limita a un hexagono (6 lados), ',
                ' - es estrictamente dependiente de nuestras necesidades; persistencia, autenticación, visualizacion, archivos, web, etc...',
                '',
                '- Cumple los principios <strong>SOLID</strong> y usa patrones <strong>GoF</strong>, pero estos ya existian desde antes ',
            ]),
        new Item('mvc',
            [
                '- Es una de las aquitecturas más conocidas, debido a su simpleza y a su enfasis de separar la visualización de los datos, de estos ',
                '- Esta separación de funciones, en 3 partes bien definidas, nos permite tener un menor acoplamiento y mejorar el mantenimiento ',
                '',
                '<strong>- Modelo:</strong>      Maneja los datos y la logica del negocio',
                '<strong>- Vista:</strong>       Se encarga de la interacción con el usuario y la presentación de los datos ',
                '<strong>- Controlador:</strong> Enruta los comandos entre la vista y el modelo ',
                '',
                '- Anteriormente esta arquitectura solo se consideraba en el lado del servidor, pero frameworks como Angular han demostrado lo contrario',
                '- Esta adaptación para la web, se ha dado con ciertas diferencias ya que todos los conceptos no son totalmente aplicables '
            ]),
        new Item(Keys.ARQUITECTURAS_MVP_MVC,
            [
                '- Este patron es una derivación de <em>MVC</em> y es ampliamentes usado para construir aplicaciones en Android',
                '- Funciona para casi todos los tipos de aplicación, facil de adaptar y replicar, aunque puede conllevar mucho codigo repetitivo(boilerplate)',
                '',
                '- La principal diferencia entre MVP & MVC es que aca el presentador además de comunicar la vista y el modelo, ',
                ' - contiene toda la logica de la presentación y en algunos casos logica simple relacionada al negocio ',
                '',
                '- Tambien hay diferencias como que en <strong>MVC</strong> el modelo puede notificar directamente a la vista de los cambios, ',
                ' - en <strong>MVP</strong> el modelo y la vista no se conocen, solo el presentador ejerce la función de "puente" entre ambos ',
                '',
                '- En <strong>MVC</strong> la vista tiene algo de logica para entender la comunicación con el modelo, ',
                ' - pero en el <strong>MVP</strong> esta es totalmente "estupida", solo se encarga de mostrar lo que se le indique',
            ]),
        new Item('otrasArquitecturas',
            [
                '<strong>- Bus de Eventos:</strong> Una fuente emite eventos donde un bus los direcciona a los receptores indicados ',
                '<strong>- Tuberia:</strong> Es un flujo donde los datos son transformados a medida que van desde su origen hasta su destino ',
                '<strong>- Maestro-esclavo:</strong> Existe un componente maestro, que distribuye todo el trabajo entre otros componentes esclavos ',
                '<strong>- Interprete:</strong> Dado un recurso X y su contexto, este deba ser convertido a su equivalente, pero en Y con otro contexto',
                '<strong>- Intermediario:</strong> Un componente central, es el encargado de administrar los componentes solicitados ',
            ]),
        new Item(Keys.ARQUITECTURAS_MONOLITOS,
            [
                '  Caracteristica                 MONOLITO                        MICROSERVICIOS                         MICROLITOS         ',
                ' ',
                ' Separación de            Acoplamiento alto y mayor        Entregadas por la plataforma          Acoplamiento alto y mayor ',
                ' funciones tecnica        dependencia del framework        usada, reduce el acoplamiento         dependencia del framework ',
                ' ',
                ' Latencia                 Casi nula                        Puede ser alta                        casi nula ',
                ' ',
                ' Consistencia             Transaccional                    Eventual, requiere más atención       Eventual ',
                ' ',
                ' Evolución                Complicada por proceso           Sencilla por proceso                  Sencilla ',
                ' ',
                ' Especialización          Alta variedad de                 Alta especialización,                 Alta especialización,    ',
                ' de los equipos           conocimientos                    conocimiento del negocio              conocimiento del negocio ',
                ' ',
                ' Automatización           Pocos despliegues                Muchos despliegues                    pocos despliegues ',
                ' ',
                ' Tamaño                   Grande                           Pequeño                               Pequeño ',
                ' ',
                ' Observalidad             Relativamente facil              Más complicada                        Punto intermedio ',
                ' ',
                ' Monitarización           Complicado separar               Sencillez para identificar            Sencillez para identificar ',
                ' tecnica                  los problemas                    problemas de rendimiento              problemas de rendimiento ',
            ]),
        new Item('stylesArchitecture1',
            [
                '- Un estilo de arquitectura, es una estrategia de alto nivel que proporciona un marco abstracto, para una familia de sistemas, ',
                ' - resolviendo problemas frecuentes de maneras reutilizables ',
                '- Un patron, en cambio, son de naturaleza concreta y especifica, para abordar problemas o modulos particulares, ya a nivel del sistema, ',
                ' - describiendo como los componentes y las interacciones deben organizarse, para una función particular ',
                ' - y resolverlo de una manera estructurada, son similares a los patrones, pero fucionan a un mayor nivel de abstración ',
                '',
                '<strong>Arquitectura a capas:</strong> ',
                ' - Principio:    Separa los componentes en diferentes capas, un ejemplo tipico es el MVC ',
                ' - Fortalezas:   Facil de mantener y desarrollar, los cambios son independientes entre capas',
                ' - Debilidades:  Puede causar sobrecargas de rendimiento, los cambios que involucran varias capas, pueden ser muy extensos ',
                ' - Usos:         Aplicaciones web y empresariales',
                ' - Antipatrones: Dependencias circulares, Saltos entre capas',
                '',
                '<strong> - N-tier:</strong> No solo existen 3 capas, se pueden agrupar y crear más, de acuerdo a las necesidades',
                '<strong> - Clean/Onion:</strong> Enfatiza la separación de responsabilidades, de manera concentrica, donde el modelo del dominio es el centro, y este se rodea',
                '  - de más capas externas, promoviendo que los cambios de cada capa, afecte mayormente a la exterior y no a la interior ',
                '',
                '<strong>Arquitectura basada en componentes:</strong>',
                ' - Principio:    Organiza el sistema, como componentes reutilizables, acoplados libremente',
                ' - Fortalezas:   Mucha reutilización, flexibilidad y mantenimiento',
                ' - Debilidades:  Complejidad de los componentes y sus relaciones',
                ' - Usos:         Aplicaciones web, de escritorio y sistemas distribuidos',
                ' - Antipatrones: Clases Dios, Redundancia',
                '',
                '<strong> - Patron Orientado a Objetos:</strong> Cumple los mismos requisitos que POO',
                '<strong> - Micro Kernel:</strong> El nucleo con las funcionalidades minimas, se aisla, y se usan complementos para crecer ',
                '<strong> - Patron Plugin:</strong> Permite agregar nuevas funcionalidades, a travez de interfaces, para ampliar y personalizar, como en un navegador',
                '',
                '<strong>Arquitectura orientada a servicios:</strong>',
                ' - Principio:    Diseña aplicaciones como una colección de servicios, que se comunican a travez de una red',
                ' - Fortalezas:   Flexibilidad, Escalabilidad, Reutilización',
                ' - Debilidades:  Complejidad, Dependencia de la red, problemas de rendimiento',
                ' - Usos:         Sistemas empresariales, microservicios',
                ' - Antipatrones: Ignorar las necesidades, Usarse donde no es necesario',
                '',
                '<strong> - Orientación a servicios:</strong> Se diseñan multiples servicios, para que convivan de manera separada, teniendo responsabilidades bien definidas ',
                '<strong> - Patron Broker:</strong> Los componentes se comunican a traves de un intermediario, que coordina la comunicación, el envio de solicitudes, ',
                '  - el manejo de excepciones, retransmision de respuestas, de manera que pueda ser un sistema distribuido',
                '<strong> - Microservicios:</strong> Tambien se diseñan multiples servicios, de manera que sean los más independientes posibles, y que se comuniquen ',
                '  - a traves de un protocolo ligero, de manera que las partes sean reutilizables e intercambiables',
                '<strong> - Serverless:</strong> Un patron exclusivo de la nube, donde no hay servidores que administrar, y los recursos se autoadministran, generalmente ',
                '',
                '<strong>Arquitectura de sistemas distribuidos:</strong>',
                ' - Principio:    Involucra multiples sistemas que trabajan juntos mediante una red, para dar la impresión de un solo sistema más grande y complejo ',
                ' - Fortalezas:   Escalabilidad, Tolerancia a fallos',
                ' - Debilidades:  Complejidad, Coherencia de los datos',
                ' - Usos:         Bases de datos distribuidas, Computación en la nube, telecomunicaciones',
                ' - Antipatrones: No funciona sin red, Problemas de consistencia',
                '',
                '<strong> - Basado en el espacio:</strong> Diseñado para evitar cuellos de botella, distribuyendo uniformemente recursos y servicios, en multiples servidores ',
                '<strong> - Punto a punto:</strong> Cada participante de la red, actua como cliente y servidor, teniendo comunicación directa entre nodos ',
                '',
                '<strong>Arquitecturas Domain-Driven:</strong>',
                ' - Principio:    Se centra en el dominio, donde se concentra la logica en un modelo que sera usado por toda la aplicación',
                ' - Fortalezas:   Mejora la compresión del negocio, fomenta la comunicación entre diversos equipos ',
                ' - Debilidades:  Entre mayor sea el dominio, mayor su complejidad, requiere buena compresion del negocio',
                ' - Usos:         Sistemas empresariales, Software empresarial',
                ' - Antipatrones: Ignorar el lenguaje obicuo, No inlcuir expertos en el negocio',
                '<strong> Hexagonal:</strong> Separa la logica empresarial, de capas externas como la persistencia y la comunicación, usando puertos y adaptadores ',
                '  - con los cuales es posible acoplarse a nuevas partes, o que esta sea consumida por otros ',
                '<strong> Domain-Driven:</strong> Ideal para sistemas complejos, con reglas y procedimientos intrincados y que cambian constantemente ',
            ]),
        new Item('stylesArchitecture2',
            [
                '<strong>Arquitecturas orientadas a eventos:</strong>',
                ' - Principio:    Se impulsa por eventos, como acciones de usuario, salidas de sensores, alertas, mensajes, etc...',
                ' - Fortalezas:   Escalable, Flexible, información en tiempo real o muy cercano a este',
                ' - Debilidades:  La programación asyncrona, puede ser compleja y de depurar ',
                ' - Usos:         Aplicaciones GUI, Analsis en tiempo real, procesamiento de eventos',
                ' - Antipatrones: Mal manejo de la información, falta de persistencia y/o acciones ',
                '<strong> - Event-Driven:</strong> Una o varias parte envian eventos, mientras que otra u otras, consumen y procesas estos eventos',
                '<strong> - Publicador-Subscriptor:</strong> Patron de mensajeria, donde se publica información en uno o varios topicos, y estos a su vez pueden ser escuchados ',
                '  - de manera que las partes solo publican o se suscriben a los topicos de su interes, bastante util en sistemas asincronos ',
                '',
                '<strong>Arquitecturas de separación de conceptos:</strong>',
                ' - Principio:    Diferentes areas de la aplicación son manejadas, por parte separadas e independientes ',
                ' - Fortalezas:   Mejora la compresión y la modularidad, promueve la modularidad',
                ' - Debilidades:  Mayor complejidad, requiere más comunicación entre modulos',
                ' - Usos:         Aplicable a casi todos los tipos de software',
                ' - Antipatrones: Acoplamiento indeseado, Falta de limites claros',
                '<strong> - Patron MVVC:</strong> Facilita la separación de las interfaces graficas, de la logica y de los servicios ',
                '<strong> - Patron MVP:</strong> Derivado del patron MVC, donde el "presentador" funciona de intermediario entre la vista y el modelo, la comunicación ',
                '  - solo se da a traves de este componente, estos 2 nunca se conocen, por lo que cambiarlos implica menos cambios asociados ',
                '',
                '<strong>Arquitecturas de Interprete</strong>',
                ' - Principios:   Las instrucciones se ejecutan de manera facil, sin necesidad de convertirlas a lenguaje maquina ',
                ' - Fortalezas:   Facil de depurar y de probar ',
                ' - Debilidades:  No es tan rapido como los lenguajes compilados, un mayor uso de recursos ',
                ' - Usos:         Creacion de scripts y lenguajes de alto nivel, compiladores y transpiladores ',
                ' - Antipatrones: Usarse, donde el rendimiento es un requisito fundamental ',
                '',
                '<strong> - Patron interprete:</strong> Especifica como evaluar oraciones en un idioma, respetando y ejecutando el arbol sintactico de una oración ',
                '',
                '<strong>Arquitecturas para concurrencia</strong>',
                ' - Principios:   Las partes de un programa se ejecutan de manera independiente, posiblemente tambien de manera simultanea ',
                ' - Fortalezas:   Mejorar el rendimiento, especialmente en sistemas multinucleo ',
                ' - Debilidades:  Corregir problemas relacionados a bloqueos y condiciones de carrera, puede ser complejo ',
                ' - Usos:         Sistemas en tiempo real, Computación de alto rendimiento, servidores web',
                ' - Antipatrones: Ignorar problemas de sincronización, administrar mal los recursos compartidos ',
                '',
                '<strong> - Patron orquestador:</strong> Un controlador, define y controla el flujo de la aplicación, especialmente, si se trata de operaciones complejas ',
                '<strong> - Patron de coreografia:</strong> Crea un sistema descentralizado y altamente desacoplado, donde solo se interactua mediante eventos ',
                '<strong> - Patron Primario-Secundario:</strong> Existen 2 tipos de componentes, el principal distribuye el trabajo, y los secundarios ',
                '  - que hacen los calculos pertinentes, para despues ser agrupados por el principal ',
                '<strong> - Patron Pipeline:</strong> Implica una cadena de elementos de procesamiento, organizados de manera secuencial, ',
                '  - donde la salida de una pieza, pueda ser la entrada de otro elemento, y asi continuar la cadena ',
                '',
                '<strong>Arquitecturas centradas en datos:</strong>',
                ' - Principios:   Todas las interacciones ocurren a travez de la BD, la cual es el centro',
                ' - Fortalezas:   Proporciona coherencia, integridad y fiabilidad de los datos',
                ' - Debilidades:  Puede crear cuellos de botella, afectando la escalabilidad',
                ' - Usos:         Aplicaciones empresariales, Sistemas CRM y ERP',
                ' - Antipatrones: Ignora posibles problemas de rendimiento, dificil de escalar ',
                '',
                '<strong> - Patron CQRS:</strong> Separa las operaciones de lectura de las de escritura, ideal en casos, donde la cantidad de operaciones es bastante dispareja ',
                '<strong> - Patron Event-Sourcing:</strong> Modela los cambios de estado, como una secuencia inmutable o registro de eventos, para su procesamiento ',
                '<strong> - Patron Kappa:</strong> No utiliza una BD como un almacenamiento convenciona, si no que lo usa para mantener un registro inmutable ',
                '<strong> - Patron Lambda:</strong> Procesa metodos de procesamiento por lotes, y secuencias para manejar grandes cantidades de datos, como el BigData ',
            ]),
        new Item('monolitosModulares',
            [
                '- Es una aplicación monolitica, con un enfasis especial en crear y mantener modulos ',
                '- Simulando trabajar con microservicios, e intentando juntar los beneficios de ambos tipos de aplicaciones ',
                '- Cada modulo, se puede definir como una colección de modulos debilmente acoplados, donde cada uno encapsula una capacidad o dominio diferente ',
                '- Las interacciones se dan entre interfaces debidamente definidas, y se implementan como una sola unidad similar a un monolito tradicional ',
                '',
                '<strong>Beneficios:</strong>',
                '<strong>- Modularidad:</strong> Los modulos promueven una separación clara de preocupaciones, mejorando el mantenimiento y su debida gestión ',
                '<strong>- Simplicidad:</strong> A diferencia de los microservicios que requieren una orquestación compleja, los modulos se implementan como una unidad ',
                '<strong>- Sin latencia:</strong> Al no tener comunicacion mediante la red, ya no hay complejidad asociada a los llamados entre servicios ',
                '<strong>- Enfoque DDD:</strong> Este tipo de arquitectura encaja bien con el diseño basado en <em>Design Domain Driven</em>, sin dejar de lado una clara separación ',
                '',
                '<strong>Consideraciones:</strong>',
                '<strong>- Acoplamiento indebido:</strong> Aunque se intente un acoplamiento flexible, existe el riesgo de introducir inadvertidamente un mal acoplamiento ',
                '<strong>- Escalamiento:</strong> Un proceso más desafiante, debido a que generalmente significa escalar toda la aplicación y no un componente individual ',
                '<strong>- Limitaciones tecnologicas:</strong> La aplicación tiene un stack de tecnologias definido, y no siempre se pueden cambiar, de acuerdo a la más indicada ',
                '<strong>- Paros:</strong> Debido a que solo existen modulos, estos suelen tener puntos criticos que si fallan, pueden afectar el resto de la aplicación ',
            ]),
        new Item(Keys.ARQUITECTURAS_DESCOMPOSICION_MODULAR,
            [
                '- Es el proceso de descomponer un sistema, en una serie de elementos más pequeños y manejables(divide y venceras)',
                '- Este conjunto de elementos debe mantener un bajo acoplamiento(independientes) con un alto grado de cohesion(significado)',
                '- Esto representa grandes ventajas, ya que la claridad y la reutilización del codigo se puede ver aumentada',
                '',
                '<strong>Pasos principales:</strong>',
                '- <strong>Identificación</strong> de los modulos, estos deben estar debidamente acotados y tener sentido dentro del sistema en general ',
                '- <strong>Describir</strong> cada modulo, de manera que la ó las responsabilidades esten claras y ',
                '- <strong>Relaciones</strong>, los modulos no pueden estar completamente aislados entre si, por lo que se debe definir que modulos y como se pueden comunicar ',
                '',
                '<strong>Cualidades minimas que se han de cumplir:</strong>',
                '<strong>- Independencia funcional:</strong> Se mide el acoplamiento y la cohesión entre modulos',
                ' - Se desea un <em>acoplamiento</em> debil, donde los datos y las estructuras usadas solo se intercambian, no hay cambios realizados fuera de su modulo ',
                ' - Se desea una <em>cohesión</em> alta, donde las entidades, los datos, funciones, procesos, etc... estan debidamente abstraidos y son coherentes entre si',
                '',
                '<strong>Comprensibilidad:</strong> Para facilitar el mantenimiento y la reutilización, es necesario que cada modulo se comprensible de manera individual, ',
                ' - sin perder su sentido dentro del panorama general, para esto es necesario tener Independencial funcional, y deseablemente Documentación ',
                '',
                '<strong>Adaptabilidad:</strong> Si no se cuenta con los 2 factores anteriores, resultara más dificil, por lo que se debe tener un poco de: ',
                ' - <strong>Previsión:</strong> Como que aspectos del sistema, pueden o van a cambiar a futuro, de manera que afecte al menor numero de elementos posibles ',
                ' - <strong>Accesibilidad:</strong> Para analizar aspectos como documentos, diseños, arquitectura, tecnologias, etc.. antes de emprender cualquier cambio ',
                ' - <strong>Consistencia:</strong> cualquier cambio que se haga, debe intentar mantener la misma estructura y caracteristicas que ya tiene el sistema ',
            ]),
        new Item(Keys.ARQUITECTURAS_EVENT_DRIVEN,
            [
                '- <em>Event Driven Arquitecture</em> es un patron de diseño en el que los componentes se comunican mediante la producción y el consumo de eventos ',
                '- Los componentes tienen un bajo acoplamiento y son flexibles en su forma de interacturar, esta comunicación se da de manera asincrona',
                '',
                '<strong>- Eventos:</strong> Define los eventos/mensajes que se intercambiaran entre servicios ',
                '<strong>- Productor de eventos:</strong> Los servicios generan eventos cuando se producen determinadas acciones ',
                '<strong>- Consumidor de eventos:</strong> Los servicios tambien se suscriben a los eventos que les interesan y poder reaccionar ',
                '<strong>- Bus/Queue(Broker):</strong> Intermediario de mensajes o un sistema de colas para facilitar la comunicación entre servicios ',
                '<strong>- Integración:</strong> Cada servicio se integra con el agente de mensajes elegido, publicando/suscribiendose como sea necesario ',
                '',
                '<strong>Pros</strong>',
                '<strong>- Acoplamiento debil:</strong> Al tener una comunicación indirecta con los eventos, permitiendo evolucionar con minimas afectaciones entre si ',
                '<strong>- Escalabilidad:</strong> Permite crecer de manera horizontal entre diferentes nodos, agregando consumidores para manejar mayores cargas ',
                '<strong>- Flexibilidad:</strong> Se pueden agregar nuevas funciones, solamente introduciendo nuevos eventos y controladores sin modificar los existentes ',
                '<strong>- Comunicación asincrona:</strong> Esto mejora la capacidad de respuesta y la resiliencia, al punto de poder funcionar si no hay consumidores temporalmente ',
                '',
                '<strong>Contras</strong>',
                '<strong>- Complejidad:</strong> Extra al tener que gestionar el enrutamiento de los mensajes, el manejo de fallos y garantizar la consistencia de los datos ',
                '<strong>- Orden/Secuencia:</strong> Debe existir alguna una manera de garantizar este orden, especialmente en los sistemas distribuidos',
                '<strong>- Debugging/Logging:</strong> Rastrear y monitorear puede resultar dificil, especialmente entre más productores y consumidores existan ',
                '<strong>- Coherencia Eventual:</strong> Que las actualizaciones del sistema se propaguen y logren una coherencia solida, puede requerir coordinación extra',
                '<strong>- Gastos:</strong> El manejo de eventos y la infraestructura necesaria para estos, pueden consumir más recursos y tener mayor latencia ',
            ]),
        new Item(Keys.ARQUITECTURAS_LAYERS_SOFTWARE,
            [
                '- Construir aplicaciones de software modernas, requiere entender/conocer/implementar de 5 capas fundamentales ',
                '',
                '<strong>User Interface/User Experience:</strong> Capa interactiva, generalmente grafica, con la interactua el usuario y el software ',
                '- Tech Stack: Angular, Vue, React, Astro',
                '',
                '<strong>API Layer:</strong> Puente de comunicación entre componentes, ya sean interacciones asincronas/sincronas ',
                '- Tech Stack: REST, GraphQL, SOAP',
                '',
                '<strong>Business Logic:</strong> Es el cerebro de la aplicación, donde sucede el procesamiento de la información y las reglas de negocio ',
                '- Tech Stack: Java, Spring, Python, Go, C++',
                '',
                '<strong>Database:</strong> El hogar de tus datos, un lugar seguro y confiable para guardar y consultar tus datos ',
                '- Tech Stack: PostgreSQL, Oracle, MongoDB, Redis',
                '',
                '<strong>Infraestructure:</strong> La base sobre la cual todo corre, aun con el auge de la nube, tambien puede existir de manera local ',
                '- Tech Stack: AWS, Docker, Kubernetes, Azure',
            ]),
        new Item(Keys.ARQUITECTURAS_EXPERIMENTATION,
            [
                '- Cuando se esta experimentado o creando una nueva arquitectura, inevitablemente habra equivocaciones ',
                '- Esta parte del proceso debe seguir existiendo, para recopilar datos y tomar decisiones fundamentales en equipo ',
                '- La <strong>Minima Arquitectura Viable</strong>(MVA) tambien pone a prueba a los <strong>MVP</strong> de manera tecnica ',
                '- Equivocarse es importante ya que ayuda a expandir nuestros limites, para eso se pueden aislar las partes y experimentar de manera individual ',
                '- Saber que probar es la mitad del problema, la otra es idear experimentos efectivos y de bajo costo, siempre con la mentalidad de fallar rapido ',
                '- Si no se realizan estos experimentos, no hay forma de probar las suposiciones hasta que sea demasiado tarde y costoso ',
                '- Estos experimentos deben ser lo suficientemente pequeños como para recopilar información de manera rapida y al mismo tiempo ser significativos ',
                ' - para enfrentar los riesgos que enfrenta el equipo además de tener tiempo maximo de duración o un cronograma de ser posible ',
                '- En caso de algun fallo o de no haber cumplido las expectativas, debe existir un plan de reversión como <strong>Pruebas A/B</strong>',
            ])
    ];

export const META_CARACTERISTICAS =
    [
        new Item(Keys.META_CARACTERISTICAS_META_DATOS,
            [
                '- Literalmente son datos de los datos',
                '- Su significado proviene del griego <em>μετα</em>, <strong>"después de"</strong> y del plural del latín <em>datum</em>, <strong>"datos"</strong>, literalmente significa "más allá de los datos"',
                '- Estan altamente estructurados para describir caracteristicas de los datos como cantidad, contenido, atributos, circunstancias, etc..',
                '- Actualmente se usan para gestionar y recolectar información de interes, desde pequeñas cantidades, hasta BigData ',
                '- Facilitan la estandarización y la gestion de los cambios, además de ayudar con las busquedas y la generación de informes/reportes ',
                '- Pueden facilitar el desarrollo al tener un menor cambio de costo entre plataformas ',
                '- Con una adecuada gobernananza de los datos, pueden dislumbrar patrones, y generar información util para multiples areas'
            ]),
        new Item('metaClase',
            [
                '- Normalmente se considera una clase de clases ',
                '- Es una caracteristica propia del sistema por lo que el usuario jamas la llegara a ver ',
                '- Esta caracteristica permite añadir y modificar comportamientos del programa, sin llegarlo a afectar directamente ',
                '- Este concepto es ampliamente usado para realizar testing, por medio de anotaciones, dobles y otros conceptos, ',
                '- Un ejemplo de esto son <em>Junit</em> y <em>Mockito</em>, frameworks para realizar pruebas en java, que se basan en estas caracteristica ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_REFLEXION,
            [
                '- Capacidad de un codigo de observarse asi mismo y cambiar su estructura a alto nivel o su comportamiento en tiempo de ejecución ',
                '- Puede ser dinamica o estatica, y es más comun en los lenguajes que usan maquinas virtuales para ejecutarse, como JAVA ',
                '- Cuando el codigo fuente se compila normalmente pierde su estructura al pasar a un lenguaje de un nivel más bajo ',
                '- Para que este comportamiento se de, esta estructura se debe preservar como metadatos, los cuales puedan manipularse ',
                '',
                '<strong>Permite realizar acciones como:</strong>',
                ' - Descubrir y modificar secciones de codigo en tiempo de ejecución ',
                ' - Evaluar una cadena como si fuera una sentencia de código fuente en tiempo de ejecución ',
                ' - Flexibilizar el tipado en lenguajes fuertemente tipados ',
                ' - Invocar metodos y constructores de objetos de manera dinamica, modificar y/o obtener información de las clases ',
                '',
                '<strong>Aplicaciones:</strong>',
                ' - Multiples <em>ORM</em> como Hibernate usan anotaciones para asignar comportamientos dinamicamente a los objetos',
                ' - Inyección de dependencias, usada por Spring y otros frameworks para inyectar codigo en tiempo de ejecución ',
                ' - Testing, Marcos de pruebas como Junit y Mockito, que permiten el descubrimiento, suplantación y verificación de objetos ',
                ' - Serialización/Deserialización, donde bibliotecas como Jackson y Gson convierten objetos a Json o Xml y viceversa ',
                '',
                '<strong>Contras:</strong>',
                ' - Perdidas de rendimiento debido a la flexibilidad requerida para afectar el codigo de manera dinamica',
                ' - Preocupaciones de seguridad, ya que omite mecanismos de control que se dan de manera normal ',
                ' - Problemas en tiempo de ejecución, ya que puede afectar o corromper los metadatos necesarios para que el programa funcione ',
            ]),
        new Item('asserts',
            [
                '- Todo codigo contiene algun tipo de restriccion, si estas no se documentan bien pueden inducir a errores ',
                '- La documentación extensiva tampoco es una buena idea ya que modificar codigo conlleva a modificar la documentación tambien ',
                '- Las aserciones son predicados que se evaluan como ciertos o falsos en tiempo de ejecución ',
                '- Estas comprobaciones favorecen el proceso de detectar errores y garantizar las condiciones de funcionamiento ',
                '- Son una opción a considerar si se quiere evitar la programación defensiva ',
                '- Existen diferentes librerias para su implementanción pero se desaconseja el uso de los "asserts" propios de Java en entornos productivos '
            ]),
        new Item(Keys.META_CARACTERISTICAS_EXCEPTIONS,
            [
                '- Es la indicación de que se produjo un error en la ejecución del programa ',
                '- Estas pueden ser situaciones esperadas, inesperadas e incluso pueden se provocadas ',
                '- Las exepciones son objetos especializados con toda la información del error ',
                '- Estos objetos pueden ser atrapados por la instrucción try-catch y evitar que se detenga el programa, ',
                ' - o simplemente ser lanzados y terminar el programa de manera abrupta ',
                '- El manejo de excepciones es fundamental para conseguir programas robustos y confiables, por esto es ideal definir, ',
                ' - responsabilidades acerca de quienes pueden lanzar excepciones y quienes pueden atraparlas ',
            ]),
        new Item('cache',
            [
                '- La cache existe para diminuir la latencia e incrementar el rendimiento en operaciones costosas ',
                '- Esta es recomendable usarla en los casos donde el rendimiento no es el esperado, o si son recursos poco mutables y muy solicitados ',
                '- Esto significa que el sistema soporte operaciones de datos con consistencia eventual ',
                '- Los datos en cache deberian estar acompañados de una politica de limpieza o tiempo de vida, no deberian existir sin ninguna caducidad ',
                '',
                '<strong>Tipos de cache:</strong>',
                '<strong>- Local:</strong> Almacenamiento en memoria, ideal cuando la información es poca, predecible y poco mutable ',
                ' - esto puede conllevar a inconsistencias de los datos si hay diferentes instancias y problemas de rendimiento en la ejecución ',
                '<strong>- Centralizado:</strong> Se almacena de manera externa y este siempre esta en concordancia con las demás ',
                ' - al ser externa depende directamente de la latencia del medio en que este, y de su disponibilidad, además de su manejo ',
                '<strong>- Distribuida:</strong> Esta particionada y administrada por diferentes nodos que se comunican entre si, su manejo implica más complejidad ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_PROCESS_AND_THREADS,
            [
                '<strong>- Programa:</strong> Es un archivo ejecutable que contiene un conjunto de instrucciones y se almacena de manera pasiva en el disco ',
                '<strong>- Procesos:</strong> Significa que un programa esta en ejecución, despues de su carga en la memoria y asignación de recursos para su funcionamiento ',
                '<strong>- Hilos(Threads):</strong> Es la unidad minima de ejecución dentro de un proceso ',
                '',
                '&brvbar;---------------------------------------&brvbar;      ',
                '&brvbar;              &brvbar; Programa &brvbar;             &brvbar;      &brvbar;-------------------------------&brvbar;       ',
                '&brvbar;  &brvbar;---------------------------------&brvbar;  &brvbar;      &brvbar;  &brvbar;-------------------------&brvbar;  &brvbar;      &brvbar;-------------&brvbar;            ',
                '&brvbar;  &brvbar; Instruccion 1 &brvbar; &brvbar; Instruccion 2 &brvbar;  &brvbar;  ->  &brvbar;  &brvbar; Proceso 1 &brvbar; &brvbar; Proceso 2 &brvbar;  &brvbar;      &brvbar;  &brvbar;-------&brvbar;  &brvbar',
                '&brvbar;  &brvbar; Instruccion 3 &brvbar; &brvbar; Instruccion n &brvbar;  &brvbar;  ->  &brvbar;  &brvbar; proceso 3 &brvbar; &brvbar; Proceso n &brvbar;  &brvbar;  ->  &brvbar;  &brvbar; Hilos &brvbar;  &brvbar;',
                '&brvbar;  &brvbar;---------------------------------&brvbar;  &brvbar;      &brvbar;  &brvbar;-------------------------&brvbar;  &brvbar;      &brvbar;  &brvbar;-------&brvbar;  &brvbar;    ',
                '&brvbar;                 Disco                 &brvbar;      &brvbar;            Memoria            &brvbar;      &brvbar;   Proceso   &brvbar;',
                '&brvbar;---------------------------------------&brvbar;      &brvbar;-------------------------------&brvbar;      &brvbar;-------------&brvbar;',
                '',
                '- Los procesos suelen ser independientes, mientras que los hilos existen como un subconjunto de un proceso ',
                '- Cada proceso tiene un espacio de memoria y este es compartido por los hilos pertenecientes ',
                '- Un proceso es una operación pesada, que tarda en ser iniciada y finalizada ',
                '- El cambio de contexto entre procesos es costoso ',
                '- La comunicación entre hilos es especialmente rapida ',
                '',
                '<strong>- Corrutinas:</strong> Es una instancia de calculo suspendible, similiar a un hilo, pero no se vincula a uno en particular, pueden suspenderse en un hilo ',
                ' - y ser retomada por otro, estas pueden llegar a bloquear a los hilos lo que no es deseable además de que no todos los lenguajes lo soportan ',
                '<strong>- Virtual Threads:</strong> Es una nueva caracteristica presente desde Java 19 y oficialmente integrada en Java 21, se manejan igual que un hilo ',
                ' - pero son más livianos y rapidos, ideales para tareas simples, no son administrados por el Sistema Operativo si no por la JVM',
            ]),
        new Item('argumentos',
            [
                '- En java los argumentos siempre se pasan por valor, esto significa que siempre se pasa el valor de la variable, ',
                ' - y no la referencia en memoria de la variable, por lo que siempre es una copia del original ',
                '- Las copias se pueden hacer del valor para datos primitivos, o una copia con la dirección de memoria si es un objeto ',
                '- Esto no modifica la variable original, ya sea un tipo primitivo o un objeto ',
                '- Algunas clases son inmutables por lo que los objetos no pueden ser modificados, se devuelve una nueva instancia con los cambios y no la original ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_CONCURRENCY_AND_PARALLELISM,
            [
                '<strong>Concurrencia:</strong> Es la capacidad de realizar muchas tareas a la vez ',
                '<strong>Paralelismo:</strong>  Es la capacidad de ejecutar multiples acciones de manera simultanea ',
                '',
                '- Para implementar concurrencia se recomienda usar <em>Hilos</em>, en cambio para implementar paralelismo se optara por usar <em>Procesos</em> ',
                '',
                '<strong>Concurrencia</strong> Consiste en lidiar con varias cosas a la vez, implica una estructura para manejar multiples tareas simultaneamente ',
                ' - y se puede dar de manera que las tareas se inicien, ejecuten y completen en periodos de tiempo superpuestos, ',
                ' - pero no necesariamente al mismo instante ó que esten relacionados de manera secuencial, pero dando la impresion de ser simultaneo ',
                '',
                '<strong>Paralelismo</strong> Por otro lado es la ejecución simultanea de multiples tareas al mismo tiempo, ',
                ' - utilizando multiples procesos ó nucleos, necesarios para tener capacidad de realizar multiples operaciones al mismo tiempo, ',
                ' - esto es crucial para tareas vinculadas a la CPU donde la velocidad y el rendimiento son cuellos de botella '
            ]),
        new Item('ortogonalidad',
            [
                '- Basicamente significa que cuando hacemos una accion esta no debe modificar lo que no le respecta ',
                '- Tambien se puede interpretar de manera que cuando se ejecute una instrucción solo se ejecute esta y nada más ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_BOILER_PLATE,
            [
                '- Este hace referencia a codigo repetitivo que no siempre es util, pero si requerido, aun aveces cuando no vaya a ser usado ',
                '- Esto tambien aplica para fragmentos de codigo propios, ya que se reutiliza codigo, con solo copiar y pegar ',
                '- El boiler plate es diferente del scafolding, ya que este primero es más de copiar y pegar, ',
                ' - en cambio el segundo esta relacionado con mantener estandares y formas de uso ',
                '- Un ejemplo de esto es el uso de getters y setters en POO, aunque estos cambian segun el objeto, su función y su forma son casi siempre identicas ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_RECURSIVIDAD,
            [
                '- Es una tecnica de programación para ejecutar codigo un cierto numero de veces ',
                '- Esto es posible a la caracteristica de cualquier lenguaje de permitir que los metodos se llamen a si mismas ',
                '- La recursividad tiene que tener un condición de salida, de lo contrario se convertira, en una pila de llamados infinita a si mismo ',
                '- Es una alternativa y en ocasiones más eficiente de realizar tareas que requieren ser repetitivas ',
                '',
                'Ejemplo con la función factorial ',
                ' public int factorial(int n) { ',
                '     return (n == 0) ? 1 : n * factorial(n - 1);',
                ' }',
            ]),
        new Item(Keys.META_CARACTERISTICAS_BACKTRACKING,
            [
                '- Es una estrategia para encontrar soluciones que satisfagan restricciones ',
                '- De una manera basica esto se asemeja a un recorrido en profundidad dentro de un grafo que no contega ciclos ',
                '- Durante todo el recorrido se va construyendo la solución del problema, todo esto para que al final si se tiene exito, ',
                ' - todas estas soluciones parciales se junten y conformar una solución completa ',
                '- Si el recorrido no tiene exito y tampoco se puede completar, se eliminaran todos los elementos construidos previamente ',
                '- Este proceso suelen implementarse mediante algoritmos recursivos para evitar busquedas profundas, evitando desperdicio de recursos ',
                '- Tambien se pueden hacer optimizaciones donde se evalua el peso de las ramas o se acotan los caminos posibles ',
                ' - mediante subrutinas para podar el arbol y mejorar su eficiencia ',
                '- Esta estrategia es usada en los analisis sintacticos de los compiladores y en la inteligencia artificial, ',
                ' - dando lugar a nuevos algoritmos de busqueda como el A*',
            ]),
        new Item(Keys.META_CARACTERISTICAS_RAW_TYPES,
            [
                '- Hacen referencia al uso de tipos genericos, sin especificar el tipo a usar',
                '- Esto se debe a que versiones previas de Java no se tenia soporte para uso de Genericos, pero este debia seguir siendo retrocompatible ',
                '- En caso de necesitar implementaciones muy laxas, sin perder seguridad, se pueden parametrizar con <em>Object</em> o el <em>wildcard<em>(<strong>?</strong>)', 
                '',
                '- Actualmente es posible usarlos, pero deben ser evitados ya que: ',
                ' - Pueden sacar errores en tiempo de ejecución, que no esta presentes o pasan desapercibidos en tiempo de compilación ',
                ' - Su uso atenta contra del codigo autocomentado además de la legibilidad y la mantenibilidad ',
                ' - Se necesitan casteos para su uso, consumiendo recursos extras ',
                '',
                '- Por Ejemplo: <em>List</em> es un raw type, mientras que <em>List(String)</em> es un tipo parametrizado '
            ]),
        new Item('memoryAndGarbage',
            [
                '- Una fuga de memoria es el deterioro gradual del rendimiento del sistema en el transcurso del tiempo, ',
                ' - como resultado del uso y de la fragmentacion de la memoria RAM del dispositivo',
                '- Esto se puede dar, debido a aplicaciones mal programadas o comportamientos inusuales del sistema',
                '',
                '<strong>Recolección de basura</strong>',
                '- Liberar estos bloques de memoria para evitar bloqueos, es una preocupación de los SO o los lenguajes propiamente ',
                '- Esta limpieza constante de la memoria parece provenir del lenguaje Lisp y adaptado por algunos SO, ',
                ' - con el fin de detectar problemas antes de que los programas fallen ',
                '- Algunos lenguajes como Java tambien lo proporcionan, siendo una gran ventaja para el programador, ',
                ' - ya que el desarrollador no debe preocuparse de un proceso que ocurre de manera silenciosa y constante ',
            ]),
        new Item('footprint',
            [
                '- Es la cantidad de Memoria RAM que utiliza el software cuando se ejecuta, las instrucciones del programa, los datos ',
                '- Tambien puede reservar para instrucciones adicionales, o acciones que se soliciten ',
                '',
                '<strong>Sistemas embedidos:</strong>',
                '- Con la proliferación de dispositivos portatiles y de productos cada vez más electronicos con necesidades para procesar datos ',
                '- Se requieren programas con poca memoria que se ajusten a cantidades del orden de kilobytes o megabytes, ',
                ' - en comparación con los servidores que disponen de gigabytes, esto suele ser un desafio con nuevas posibilidades y problemas ',
            ]),
        new Item('featureFlag',
            [
                '- Es una tecnica de desarollo, que activa y desactiva funcionalidades, en tiempo de ejecución, sin tener que realizar nuevas implementaciones ',
                '- De esta manera se puede tener un control más granular sobre que personas, pueden o no pueden realizar acciones sobre el sistema ',
                '',
                '<strong>- Pruebas en producción:</strong> Permiten probar nuevas funcionalidades en ambientes más reales, al mismo tiempo que se puede limitar el riesgo ',
                ' - si se llegar a presentar algun error, las nuevas caracteristicas se pueden apagar, sin afectar a las ya existentes ',
                '',
                '<strong>- Lanzamientos canario:</strong> Se prueba una función en un subgrupo de usuarios, para analisis de comportamiento y correciones ',
                ' - antes de ser lanzado al usuario final, esto evita el riesgo de crear funcionalidades que deban ser revertidas, sin afectar a los usuarios generales ',
                '',
                '<strong>- Ciclos de liberación más rapidos:</strong> Al tener más opciones para realizar despliegues y cambiar el comportamiento sin cambios disruptivos, ',
                ' - esto libera al equipo de desarrollo para realizar otras tareas ',
                '',
                '<strong>- Interruptor de retrocesos/desconexión:</strong> Las nuevas funcionalidades pueden ser habilitadas o deshabilitadas de una manera bastante simple, ',
                ' - solo basta con editar el archivo de configuracion, de esta manera es posible <em>apagar</em> funcionalidades sin tener que pasar por procesos de revisión ',
                '',
                '<strong>- CD/CI:</strong> Las entregas continuas se encuentran beneficiadas, ya que permite la unión de los cambios, e incluso de funcionalidades incompletas, ',
                ' - que no afectaran el codigo de producción, y que cuenta con mecanismos para ser <em>activadas/desactivadas</em> cuando se requieran ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_GENERICS,
            [
                '- Es una caracteristica del lenguaje que permite la abstraccion de tipos, presente en Java y otros lenguajes orientados a objetos como C# ',
                '- Esto permite crear soluciones más sofisticadas que ayudan a mejorar la mantenibilidad del codigo y mantener la seguridad de los tipos ',
                '- Los genericos es una forma de indicar al compilador que tipo de objeto se almacenara en una coleccion o manipulara mediante una clase y/o metodo ',
                '- Esto permite detectar errores y realizar comprobaciones en tiempo de compilación, mucho más seguro que en tiempo de ejecución ',
                '- Esta parametrización permite crear clases, interfaces y metodos que pueden operar con multiples tipos de datos sin perder comprobaciones en la compilación ',
                '',
                '- Tambien permiten flexibilidad al poder usar comodines lo que evita perder restricciones y reducir errores del tipo <em>ClassCastException</em> ',
                '<strong> Comodin ilimitado:</strong>         <em> ? </em>             Permiten cualquier tipo',
                '<strong> Comodin de limite superior:</strong><em> ? extends Type</em> Restringen el tipo desconocido a un subtipo particular ',
                '<strong> Comodin de limite inferior:</strong><em> ? super Type  </em> Restringen el tipo desconocido a un supertipo particular ',
                '',
                '<strong>- Parametros comunes en Genericos:</strong>',
                ' T -> Tipe   ',
                ' E -> Element',
                ' K -> Key    ',
                ' N -> Number ',
                ' V -> Value  ',
                '',
                '- Esta caracteristica fue introducida sin cambiar la JVM, por lo que garantiza retrocompatibilidad con versiones previas a Java 5 ',
                '- Para esto fue necesario realizar un borrado de tipos, ya que la JVM no soporta esta caracteristica siendo solamente en tiempo de compilación ',
                '- Debido a esto no existe una sobrecarga ni se ve afectado el rendimiento en tiempo de ejecución ',
                '- Al contrario esto puede traer beneficios en el uso de la memoria al evitar crear objetos intermedios y eliminar casteos innecesarios ',
                '- Para el trabajo con operaciones criticas en rendimiento se recomienda usar los tipos primitivos si es posible y asi no ',
                ' - realizar el <em>autoboxing</em> y <em>unboxing</em> entre primitivos y sus correspondientes tipos de envoltorio(Wrapper)',
                '- Tambien evite usar <em>Raw Types</em>(tipos crudos) ya que no cuentan con la seguridad que proporcionan los genericos ',
            ]),
        new Item('memorySafety',
            [
                '- Ya no solo se pone interes en el software que se crea, tambien en el como se crea, y parece que tambien paso a ser un tema de seguridad nacional ',
                '- La oficina del director cibernetico de la casa blanca de Estados Unidos asi lo cree, ya que en febrero del 2024, publicaron un informe donde, ',
                ' - aconsejan usar o migrar a lenguajes seguros para la memoria, y para aquellas bases heredadas dificiles de migrar, ',
                ' - sugiere implementar practicas, que ayuden con la seguridad de la memoria ',
                '',
                '- Grandes vulnerabilidades informaticas de la era de internet, provienen de practicas inseguras y del uso de lenguajes que permiten ',
                ' - un uso inseguro de la memoria, como <em>C</em> y <em>C++</em>',
                '',
                '<strong>Memoria Insegura:</strong> Cada variable que se crea o se asignan datos, se almacena en memoria, esto se hace mediante funciones de bajo nivel ',
                ' - que son propias de cada lenguaje, asignando y desasignando esta memoria de acuerdo si es necesario o no, estos lenguajes tambien ',
                ' - cuentan con algun mecanismo general para la recolección de basura; en C y C++ todos estos procesos se deben de realizar manualmente ',
                '',
                '- Esto conlleva a problemas en 2 categorias, espacial y temporal:',
                '',
                '<strong>Errores de memoria espacial:</strong> Ocurren cuando intentas leer o asignar datos a listas y variables fuera de lo asignado ',
                '- Colocando como ejemplo un array de 20 elementos, ¿ Que pasa al intentar leer/asignar el elemento 21 ?, un lenguaje seguro arrojara un error, ',
                ' - pero los no seguros, pueden permitir leer regiones de memoria contiguas, independientemente de lo que este almacenado, ',
                ' - este tipo de error es conocido como un error de fuera de limites (out-of-bond)',
                '',
                '<strong>Errores de memoria temporal:</strong> Ocurren cuando el lenguaje intenta acceder a la memoria desasignada, ',
                ' - puede ser causado por el uso de punteros, donde este almacena la dirección en memoria de la variable, por lo que si la variable se desasigna ',
                ' - y la memoria se libera, el puntero seguira siendo el mismo, y cuando se use se accedera a esa misma posición en memoria, ',
                ' - leyendo cuaquier dato almacenado en esa dirección, esto es conocido como un error de uso despues de la liberación (use-after-free)',
                '',
                '- Lenguajes seguros con la memoria existen muchos, como Java, C#, Go, Ruby, Swift y principalmente Rust',
                '- Rust tiene un "Verificador de prestamos", lo que hace que hace que cualquier referencia no sobreviva, sin la información a la cual fue asignada ',
                '- Al crear una variable, se le asigna la memoria justa para su valor, por lo que al quedar fuera de alcance, la memoria se libera, sin problemas ',
                '- Esto es restrictivo, pero Rust tambien permite realizar prestamos, mediante el uso de referencias, que se borran junto con la variable ',
                '',
                '<strong>Algunas practicas para la seguridad, en lenguajes inseguros</strong>',
                '- NULL, elimina los punteros siempre al liberar la memoria, para evitar errores de liberación ',
                '- Recursividad, intente no usarla, o usela solo si conoce sus limites, para evitar problemas de agotamiento de pila(Stack) y del monton(Heap)',
                '- Si sospecha de referencias nulas, no evite este tipo de comprobaciones, y asi evita problemas de referencias nulas ',
                '- Utilice mecanismos para evitar condiciones de carrera, en ambientes multi-hilos',
                '- Inicialize los punteros y variables que vaya a usar, sin una asignación de valores previa',
                '- Finalize los String en Null, una vez se dejen de usar, para evitar fugas de memoria ',
                '- Escoja correctamente los tipos de variables, para evitar desbordamientos y conversiones innecesarias ',
                '',
                '- En lenguajes seguros, tambien se recomienda utilizar metodos formales para comprobar posibles vulnerabilidades, como el analisis de codigo estatico ',
                ' - y pruebas basadas en afirmaciones, que solo son correctas si no hay errores en el software ',
            ]),
        new Item('profiling',
            [
                '- Las aplicaciones pueden fallar y tener errores debido a problemas de falta de memoria, y para encontrarlos suelen haber herramientas especificas ',
                '- Un perfilador es una herramienta para medir y examinar el rendimiento de las aplicaciones, no solo de Java ',
                '- Mediante la verificación de la construcción y operación del codigo de bytes a nivel de Java en la JVM',
                '',
                'Este recopila datos de la ejecución del programa <strong>como:</strong>',
                '- Tiempo de ejecución de las funciones ',
                '- Uso de memoria',
                '- Frecuencia de los llamados',
                '- Cantidad de Hilos y sus estados',
                '- Clases y cantidades de sus objetos',
                '- Uso de la CPU',
                '',
                '<strong>Beneficios:</strong>',
                '- Ayuda a identificar cuellos de botella',
                '- Permite identificar secciones de codigo con retrasos',
                '- Analiza el consumo de recursos e identificar lugares que se puedan optimizar ',
                '',
                '<strong>Tipos:</strong>',
                '<strong>- De Muestreo:</strong> Toman periodicamente instantaneas del programa en ejecución, y analizan la pila de llamados, para identificar puntos de acceso',
                '<strong>- De Instrumentación:</strong> Modifican el codigo durante la ejecución, para recopilar datos más detallados acerca del rendimiento',
            ]),
        new Item('blockingAndNoBlocking',
            [
                '- Son 2 maneras diferentes de como el Sistema Operativo para manejar operaciones de <strong>I/O</strong>',
                '- Una llamada con bloqueo es donde el <em>SO</em> decide que se necesita esperar el resultado de la operación, antes de continuar con la ejecución, ',
                ' - el resultado directo de esto es que el usuario, no puede hacer nada más hasta que termine la tarea solicitada ',
                '',
                '- En cambios las llamadas sin bloqueo(asincronas) no bloquean el hilo ni esperaran que sucedan los procesos,',
                ' - estas retornan inmediatamente cuando finalizan, sin tener efecto en lo que sucede en otros subprocesos',
                '',
                '- La diferencia principal entre estos 2 tipos de operaciones es como se comporta el codigo durante la operación sin bloqueo,',
                ' - la principal ventaja es que el usuario puede continuar con otras tareas, sin tener que esperar a que finalize',
                '',
                '- Las operaciones asyncronas son más complicadas de escribir ya que hay que tener en cuenta posibles efectos segundarios,',
                ' - pero al mismo tiempo aportan flexibilidad y mejoran la concurrencia del programa',
                '',
                '- Las operaciones <strong>Asyncronicas</strong> no se recomiendan, cuando se necesitan encadenar tareas que tienen un orden especifico de ejecución ',
                ' - o necesitan estar sincronizadas y ser fiables, como el acceso y la modificación de datos',
            ]),
        new Item(Keys.META_CARACTERISTICAS_ANOTATIONS,
            [
                '- Son metadatos que se pueden agregar al codigo para proporcionar información al compilador o al entorno de ejecución ',
                '- No afecta directamente la funcionalidad del programa, si no que transmiten instrucciones a las herramientas o al marco de trabajo(framework)',
                '- Tambien pueden contener parametros, para otorgar información extra y además pueden convivir varias en un mismo elemento ',
                '- Las anotaciones tienen un <em>Scope(alcance)</em> y especifica en que pueden ser utilizadas, clases, metodos, atributos ',
                '',
                '<strong>Anotaciones comunes:</strong>',
                '<strong>- @Deprecated:</strong> Para aquellos metodos y clases que ya no se deben usar, pero tampoco pueden ser removidos ',
                '<strong>- @Override:</strong> Información util para el compilador de que debe sobreescribir el metodo de la clase padre, ya sea por herencia ó contrato ',
                '<strong>- @SuppressWarnings:</strong> Elimina las advertencias que el compilador pueda mostrar, ya sea por desinteres o improbabilidad ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_CACHE_AND_TYPES,
            [
                '- Las estrategias usadas para la escritura/lectura varian segun las necesidades de cada negocio, ya que resuelven problemas en distintos escenarios ',
                '',
                '<strong>Cache Aside Pattern:</strong> Es uno de los patrones más usados, la aplicación debe conocer todos los procesos que actuan sobre los datos ',
                '<strong> Escritura:</strong> 1. Actualizar Base de Datos  <strong>Lectura:</strong> 1. Leer datos del cache y devolverlos si estan',
                '            2. Eliminar cache                     2. Si no existen, actualizar el cache directamente con la información de la BD y regresarlos ',
                '- ¿ Porque no se actualizan los valores ? En escenarios con mucha concurrencia esto puede generar inconsistencias en los datos tanto en cache como en la BD ',
                '- Este patron es ideal en escenarios donde se dan muchas lecturas y pocas escrituras y la consistencia de los datos no es critica ',
                '',
                '<strong>Read Through Pattern:</strong> Es similar al patron de Cache Aside, pero con una capa de control de acceso adicional ',
                ' 1. La solicitud accede a la capa de control',
                ' 2. El control de acceso lee los datos desde la cache y los devuelve ',
                ' 3. Si no se encuentran datos, se cargan desde la BD, se escribe en la memoria cache y se devuelven ',
                '- Este escenario es aplicable cuando existen muchas lecturas y la consistencia de los datos requerida es relativamente baja ',
                '- Tambien puede ayudar a reducir el problema de la primera lectura, con posibles precargas de la información ',
                '',
                '<strong>Write Through Pattern:</strong> Similar al Patron de <em>Read Through</em> y a diferencia de <em>Cache Aside</em> cada escritura actualiza el cache ',
                ' 1. La solicitud accede a la capa de control',
                ' 2. La capa de control actualiza la cache de manera atomica',
                ' 3. Se actualia la BD de manera sincrona ',
                '- ¿ Porque se actualizan los valores antes que en la BD ? El orden de los eventos no cobra tanta relevancia, pero si se requiere tene una gran concurrencia, ',
                '- Se pueden usar bloqueos distribuidos para lidiar con posibles inconsistencias o si la concurrencia es elevada, especialmente durante la escritura ',
                '',
                '<strong>Write Behind Pattern:</strong> La escritura de los datos se hace de manera asincrona, solamente actualizando el cache cuando exista un cambio en los registros ',
                ' 1. La aplicación solicita acceso a la capa de control ',
                ' 2. Esta capa actualiza el cache ',
                ' 3. Se actualiza la BD de manera asincrona y en forma de lotes(batch)',
                '- Es el escenario donde existe la mayor posibilidad de tener problemas en la coherencia de los datos, a cambio de reducir la presión sobre la BD ',
                '- Es util en sistemas donde se tengan una cantidad incesante de escrituras que requieran ser procesadas de manera eficiente ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_TYPE_ERASURE,
            [
                '- Es un mecanismo importante de Java además de otros lenguajes que admitan Genericos ',
                '- Esto con el fin de aplicar restricciones en tiempo de compilación, y descartar la información en tiempo de ejecución ',
                '- Esto se puede dar en diferentes niveles, principalmente a nivel de Clase y de Metodo ',
                '- El cambio suele suceder, reemplazando el tipo seleccionado por <em>Object</em>, o la información del tipo más cercano ',
                '- En casos más extremos, donde puede haber ambiguedad, el compilador puede crear algunos metodos intermedios o puente, ',
                ' - con el fin de crear objetos polimorficos y seguros a nivel de tipos para evitar errores de ejecución ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_DEAD_LOCKS,
            [
                '- Un punto muerto ó un Bloqueo se da cuando 2 ó más transacciones estan esperando entre si para liberar recursos bloqueados ',
                '- Asi ninguna transacción puede continuar, pero tampoco deja el camino libre para que otras continuen, creando una espera infinita ',
                '',
                '<strong>Condiciones de Coffman:</strong> Son 4 condiciones que se deben presentar simultaneamente para que ocurra un punto muerto ',
                '<strong>- Exclusión mutua:</strong> Al menos un recurso debe mantener un estado que le impida ser compartido ',
                '<strong>- Mantener y esperar:</strong> Un proceso actualmente tiene un recurso y solicita recursos adicionales que estan en poder de otros ',
                '<strong>- Espera Circular:</strong> Los procesos esperan recursos que estan bloqueados por otros, formando una cadena circular ',
                '<strong>- Sin Preferencia:</strong> Los recursos no pueden ser retirados por la fuerza de los procesos que los contienen ',
                '',
                '<strong>Prevención de Bloqueos:</strong> ',
                '<strong>- Ordenación de Recursos:</strong> Imponer un orden de todos los tipos de recursos y que solo se soliciten en un orden creciente ',
                '<strong>- Tiempos de espera:</strong> Si un proceso retiene recursos durante demasiado tiempo, se pueden liberar/revertir ',
                '<strong>- Algoritmo del Banquero:</strong> Simula la asignación de recursos y ayuda a decidir si es seguro conceder una solicitud de recursos a futuro ',
                '',
                '<strong>Recuperación de Bloqueos:</strong> ',
                '<strong>- Selección de una victima:</strong> La mayoria de los <em>DBMS</em> tienen la capacidad de detectar puntos muertos y seleccionar victimas segun los criterios ',
                '<strong>- Rollback:</strong> La BD puede revertir toda la transacción ó solo lo suficiente para romper el punto muerto y despues reiniciarlas ',
            ]),
        new Item(Keys.META_CARACTERISTICAS_TIPOS,
            [
                '- Un tipo describe un conjunto de valores que se le pueden asignar a una expresión, esto delimita la cantidad de valores que pueda usar y/o operar ',
                '- Ayuda a detectar errores durante la fase de desarrollo ',
                '- Guia al programador sobre las opciones validas en un determinado contexto mediante documentación o ayudas del IDE ',
                '- Cambios en el comportamiendo de una operación, puede variar segun sea la forma... Polimorfismo, Sobrecarga, Herencia, etc...',
                '- Las validaciones basadas en los tipos son más faciles de automatizar y de evolucionar ',
                '',
                '<strong>Tipado Explicito:</strong> Toda variable, parametro o metodo, tienen un tipo definido, el polimorfismo se da solamente mediante herencia o interfaces ',
                '<strong>Tipado Implicito:</strong> Las variables se definen en base al tipo con el que se declaran(inferencia), permitiendo una mayor flexibilidad ',
                '',
                '<strong>Tipado Estatico:</strong> Se checkean en tiempo de compilación, una vez declarado solo se puede cambiar el valor ',
                '<strong>Tipado Dinamico:</strong> Se checkean en tiempo de ejecución, y pueden ir cambiando de tipos y valores a lo largo de la ejecución ',
                '',
                '<strong>Tipado Fuerte:</strong> Es la permisividad del lenguaje para cambiar de tipos(casteo), el cambio se permite pero bajo ciertas reglas y pasos ',
                '<strong>Tipado debil:</strong> El cambio se puede hacer de manera simple sin necesidad de ser explicitos ',
                '',
                '<strong>Tipado Nominal:</strong> Tienen un nombre y solo son compatibles si tienen el mismo nombre, usando plantillas como Clases e Interfaces ',
                '<strong>Tipado Estructural:</strong> Se basa en la estructura ó atributos, por lo que son compatibles si comparten la misma información ',
                '',
                '                                                 <strong>Clasificaciónes</strong>       ',
                '&brvbar; Java &brvbar; estatico &brvbar; fuerte &brvbar; nominal     &brvbar; mixto     &brvbar;    &brvbar; Scala      &brvbar; dinamico &brvbar; fuerte &brvbar; estructural &brvbar; mixto     &brvbar;',
                '&brvbar; C++  &brvbar; estatico &brvbar; debil  &brvbar; nominal     &brvbar; explicito &brvbar;    &brvbar; Javascript &brvbar; dinamico &brvbar; debil  &brvbar; estructural &brvbar; implicito &brvbar;',
                '&brvbar; Go   &brvbar; estatico &brvbar; fuerte &brvbar; estructural &brvbar; explicito &brvbar;    &brvbar; Python     &brvbar; dinamico &brvbar; fuerte &brvbar; nominal     &brvbar; implicito &brvbar;',
                '&brvbar; Rust &brvbar; estatico &brvbar; debil  &brvbar; estructural &brvbar; explicito &brvbar;    &brvbar; Perl       &brvbar; dinamico &brvbar; debil  &brvbar; nominal     &brvbar; implicito &brvbar;',
            ])
    ];

export const CONTENEDORES =
    [
        new Item('lxc',
            [
                '- Los contenedores de aplicaciones en linux buscaban mejorar la asignación de recursos a los procesos por medio de una interfaz de espacio de usuario ',
                '- Esto con el objetivo de mejorar mejorar el rendimiento de las maquinas virtuales y su uso de recursos ',
                '- El uso de maquinas virtuales y el software de supervisor obligaban a tener un uso de recursos fijo que en ocasiones era desperdiciado ',
                '- En estos contenedores no hay emulación de hardware por lo que solo ejecutaba con lo que necesitaba obteniendolo directamente del host ',
                '- Pero los ambientes no estaban completamente aislados, por lo que compartir el mismo host podia conllevar problemas si habian aplicaciones similares ',
                '- Tambien se ha de tener en cuenta que este ambiente solo estaba disponible en un SO Linux como base, por lo que es poco portable ',
                '- Aunque Docker inicialmente implementaba lxc, este se modifico volviendose muy popular, al punto de ser un estandar en la industria del software ',
                '- Ya sea lxc, Docker o kubernetes, los contenedores solucionaron muchos problemas de compatibilidad facilitando el desarrollo en muchos ambitos ',
                '',
                '<strong>Algunas diferencias entre Lxc y Docker:',
                '- Docker ofrece una abstracción para configuraciones especificas de la maquina, como redes, almacenamiento, registros, dependiendo menos del Host ',
                '- Los contenedores de Docker estan diseñados para ejecutar un unico proceso, por contenedor ',
                '- Mientras que <em>Lxc</em> esta orientado a replicar distribuciones de Linux, <em>Docker</em> solo el de empaquetar aplicaciones individuales '
            ]),
        new Item(Keys.CONTENEDORES_DOCKER,
            [
                '- Esta basado en el Kernel de Linux y su proposito es segregar los procesos de manera que sean independientes ',
                '- Reduce el consumo de recursos al solo tener lo necesario para ejecutar los procesos ',
                '- Desde su aparición las maquinas virtuales han perdido relevancia ',
                '- El uso de los contenedores y todos sus beneficios fue una gran revolución en el desarrollo del software ',
                '- Los contenedores son entornos de ejecución completos haciendolos independientes del sistema anfitrión ',
                '- Los servicios se pueden unir para generar aplicaciones de más complejidad y eficiencia ',
            ]),
        new Item('images',
            [
                '- Son los elementos necesarios para crear instancias de lo que se necesite ',
                '- Estas imagenes pueden ser oficiales ó personalizadas, especificamente para nuestros requerimientos ',
                '- Existen repositorios en la nube donde se pueden descargar o guardar estas imagenes, uno de los principales es DockerHub ',
                '- Toda imagen tiene un tag asociado, para poder diferenciar las versiones entre si, por defecto este tag es latest ',
                '- Las imagenes tambien pueden ser privadas, por lo que se requirira de una autenticación para que se puedan usar ',
                '',
                '<strong>Formas de creación/personalización:</strong>',
                ' - Creando un contenedor a partir de una imagen base y manipularlo manualmente, para crear una imagen a la medida',
                ' - Mediante un archivo DockerFile: Donde se crea una secuencia de comandos, que a su vez, indica una capa, ',
                '  - las cuales se van apilando y modificando entre si para construir algo más complejo ',
                ' - Tambien existen herramientas automatizadas, configurables y que cumplen los estandares y especificaciones de la <strong>OCI</strong>'
            ]),
        new Item('containers',
            [
                '- Son las instancias de las imagenes creadas/descargadas, que se ejecutan de manera aislada',
                '- <strong>docker ps</strong>                         Contenedores ejecutandose                                    ',
                '- <strong>docker ps -a</strong>                      Contenedores existentes, independientemente de su estado     ',
                '- <strong>docker exec</strong>                       Ejecutar comandos dentro del contenedor, sin tener que entrar',
                '- <strong>docker start   <em>nombre_contenedor</em></strong>  Inicia el contenedor                                ',
                '- <strong>docker stop    <em>nombre_contenedor</em></strong>  Detiene el contenedor                               ',
                '- <strong>docker restart <em>nombre_contenedor</em></strong>  Reinicia el contenedor                              ',
                '- <strong>docker rm      <em>nombre_contenedor</em></strong>  Elimina el contenedor                               ',
                '- <strong>docker inspect <em>nombre_contenedor</em></strong>  Muestra la informacion completa del contenedor      ',
                '- para estos comandos tambien se puede usar los ID de los contenedores ',
            ]),
        new Item('volumes',
            [
                '- Un volumen es un directorio o fichero que esta asociado a un contenedor/contenedores, son independientes y no se afectan cuando se destruyen ',
                '- Son usados para almacenar toda la información que se quiere mantener de un contenedor, debido a su naturaleza efimera ',
                '- Se pueden crean añadiendo la opción -v al crear un contenedor <strong>docker run -it --name <em>contenedor</em> -v /path imagen:tag bash</strong>',
                '- Tambien se pueden crear mediante volumenes o como simples directorios, por ejemplo <strong>docker run -it --name <em>contenedor</em> -v vol:/path imagen:tag bash</strong>',
                '',
                '- Todo contenedor crea un volumen con un nombre aleatorio por defecto, estos se pueden consultar mediante 2 formas ',
                '<strong>- docker inspect <em>contenedor</em></strong> Mostrando todas las caracteristicas del volumen',
                '<strong>- docker volume ls</strong> Enseña todos los contenedores existentes, pero sin sus asociaciones ',
            ]),
        new Item('network',
            [
                '- Las redes entre contenedores, se refieren a la capacidad de los contenedores para comunicarse entre si, o con recursos externos ',
                '- Cada contenedor de docker tiene una IP asociada, en base a la IP del Host o del tipo de red que sea, existen varios tipos: ',
                '',
                '<strong>- Bridge</strong>  Red por defecto de los contenedores cuando no se les especifica una ',
                '<strong>- Host</strong>    El contenedor usara la misma IP del host en el que este ',
                '<strong>- None</strong>    Se le indica al contenedor que no tiene una red asignada ',
                '<strong>- Overlay</strong> Crea multiples redes superpuestas permitiendo la comunicación de servicios en enjambre ',
                '<strong>- Ipvlan</strong>  Brindan control total sobre las direcciones IPv4 & IPv6',
                '<strong>- Macvlan</strong> Permiten asignar una dirección MAC a un contenedor, apareciendo como un dispositivo fisico en la red ',
                '',
                '<strong> docker network create --driver bridge <em>nombre_red</em></strong> Crea una nueva red, de tipo bridge, cada red creada, creara otra subred ',
                '',
                '<strong> docker run -d -P --name <em>nombre_contenedor</em> --network <em>nombre_red</em></strong> Especifica una red cuando estos se crean ',
                '',
                '<strong> docker network connect --link <em>nombre_contenedor</em>:<em>alias</em> <em>nombre_red</em> <em>nombre_contenedor</em></strong> Tambien se puede cambiar despues de la creación ',
            ]),
        new Item('file',
            [
                '<strong>- FROM</strong> Indica el SO base de la imagen ',
                '<strong>- COPY</strong> Añade archivos del directorio actual a la imagen ',
                '<strong>- RUN</strong> Ejecuta comandos dentro del contenedor necesarios para crear la imagen ',
                '<strong>- CMD</strong> Ejecuta comandos directamente en la consola ',
                '<strong>- LABEL</strong> Son etiquetas del proyecto para dar a conocer información, como licencias ',
                '<strong>- EXPOSE</strong> Indica que puertos estaran abiertos en la imagen para que la aplicación pueda comunicarse con el host',
                '<strong>- ENV</strong> Define las variables de entorno, sirve para ayudar en la configuración de la imagen ',
                '<strong>- ADD</strong> Funciona igual que COPY pero se diferencia a la manera de extraer los archivos de sus ubicaciones ',
                '<strong>- ENTRYPOINT</strong> Establece el comando principal de la imagen, suele ser el comando iniciador de la aplicación ',
                '<strong>- VOLUME</strong> Enlaza directorios y/o archivos entre el host y el contenedor, de manera que se puedan persistir y modificar archivos ',
                '<strong>- USER</strong> Este cambia el usuario del contenedor a uno diferente, el usuario por defecto suele ser root ',
                '<strong>- WORKDIR</strong> Indica el directorio donde trabajara la aplicación, y se recomienda el uso de rutas absolutas para este ',
                '<strong>- ONBUILD</strong> Son comandos que se ejecutaran una vez terminada la construcción de la imagen principal ',
            ]),
        new Item('compose',
            [
                '- Docker Compose permite simplificar y administrar los contenedores por medio de archivos YAML ',
                '- Esto permite conectar y administrar a los contenedores y sus puertos, volumenes, configuraciones, etc.. ',
                '- Se puede usar con Dockerfiles previamente creados, o especificar todo directamente en el archivo ',
                '- Mejora la portabilidad entre ambientes, y es ampliamente usado y soportado por la comunidad'
            ]),
        new Item('kubernetes',
            [
                '- Es una plataforma de codigo abierto para administrar cargas de trabajo y servicios por medio de contenedore ',
                '- Es un proyecto liberado por Google en 2014 que ha crecido con la comunidad y sus buenas practicas ',
                '- Este orquesta la infraestructura redes y almacenamiento, sin intervención de los usuarios ',
                '- Esto ofrece la simplicidad de un PaaS y la flexibilidad de un IaaS ',
                '- Kubernetes no despliegua ni compila tu aplicación, eso se hacer por medio <strong>CI/CD</strong>',
                '- No provee servicios de capa de aplicación como midleware, bases de datos, cache, mensajes ni monitoreo automatico ',
                '',
                '<strong>Beneficios:</strong> ',
                '- Mayor agilidad y velocidad de despliegue de aplicaciones ',
                '- Consistencia en los entornos de desarrollo, producción y pruebas sin importar las caracteristicas de la maquina fisica ',
                '- Posibilidad de Microservicios y las ventajas que esto conlleva ',
                '- Aislamiento de recursos y una mejor administración de estos ',
                '',
                '- El nombre de kubernetes proviene del griego "<i>κυβερνήτης</i>" que significa timonel, de ahi su logo '
            ]),
        new Item('containerOrchestation',
            [
                '- Debido a lo escalable y populares que son los contenedores, es imperativo tener una manera de manejarlos y automatizarlos ',
                '',
                '<strong>- Kubernetes:</strong> Plataforma de codigo abierto, para la gestion y automatización de cargas de trabajo y servicios en contenedores ',
                '<strong>- OpenShift:</strong> Es un PaaS que ayuda en la automatización en entornos de Nube hibrida a nivel empresarial ',
                '<strong>- Nomad:</strong> Orquestador de cargas, simple, flexible y ligero, utilizando Infraesctructura como Codigo(Iac); sin limitarse a contenedores ',
                '<strong>- Docker Swarm:</strong> Utiliza un modelo declarativo para definir un estado deseado, para que Docker mantenga ese estado, mediante nodos ',
                ' - encargados de la administración y de los trabajos, en la versión empresarial es compatible con Kubernetes ',
                '<strong>- Docker Compose:</strong> Define y ejecuta aplicaciones para que funcionen en conjunto, mediante archivos YAML',
                '<strong>- Cloudify:</strong> Orquestación en la nube de contenedores y microservicios, compatible con otros orquestadores basados en Docker como Swarm y Kubernetes ',
                '<strong>- GKE:</strong> Administra los contenedores proveidos por Google Cloud Platform y puede interactuar con la CLI de Kubernetes ',
                '<strong>- AKS:</strong> Es un servicio de Kubernetes autoadministrado, ofrecido por Azure, solamente configurando los nodos de agentes ',
                '<strong>- AWS EKS:</strong> Es un servicio autoadministrado por Amazon, y que usa el potencial de la computación sin servidor (serverless) ',
                '',
                '- Para ver otras opciones o conseguir los enlaces oficiales de cada tecnologia, puedes seguir leyendo el articulo original ',
            ]),
        new Item('openContainer',
            [
                '- Es una proyecto de gobernanza abierta y liviana, formada bajo el auspicio de la Fundación Linux ',
                '- Fue creada en el 2015 por Docker, CoreOs y otros lideres en la industria de contenedores ',
                '- Con el proposito expreso de crear estandares abiertos de la industria en torno a los formatos y especificaciones de ',
                '',
                '- Especificación de tiempo de ejecución <strong>(runtime-spec)</strong>',
                '- Especificación de las imagenes <strong>(image-spec)</strong>',
                '- Especificación de distribución <strong>(distribution-spec)</strong>',
                '',
                '- La especificación de tiempo de ejecución describe como ejecutar un "paquete de sistema de archivos" presente en el disco, ',
                ' - otra implementación descargaria la imagen, se desempaqueta para ser ejecutado, sin argumentos o procesos adicionales para cada paso ',
                '',
                '- Para que las UX el formato de la OCI contiene suficientes especificaciones para usar comandos, variables de entorno, argumentos, etc ',
                '- Para las imagenes construidas, se encuentra generamente un manifiesto de la imagen, las capas, y la configuración ',
                '- Para el ambiente de ejecución, Docker dono su formato de contenedores y su ejecución, para que sirviera como base ',
                '',
                '- Para encontrar los links originales a cada especificación, ademas de otros datos y la comunidad del proyecto, puede revisar la fuente ',
            ]),
        new Item(Keys.CONTENEDORES_SECURE_ORCHESTRATION,
            [
                '- Teniendo en cuenta que un contenedor, es un paquete ejecutable, que contiene todo lo necesario para el tiempo de ejecución ',
                '- Esta ejecución es entandar, solucionando muchos problemas de compatibilidad que antes existian, además de estar segregada y aislada',
                '- Durante mucho tiempo el mayor exponente de los contenedores ha sido <em>Docker</em>, pero tambien estan surgiendo alternativas como <em>Podman</em>',
                '- Este con unfoque de tipo <em>Rootless</em> donde no se necesita tener acceso a la raiz para funcionar, al contrario que Docker que es <em>Rootful</em>',
                '- Acceder a la raiz y tener un daemon(servicio) permite que Docker pueda leer archivos, instalar programas, y muchas más acciones,',
                ' - que facilitan la administración y la usabilidad, pero al mismo tiempo son atractivas para piratas informaticos',
                '- Pero al no tener acceso a la raiz, Podman depende de otras herramientas, para tener acceso y analizar los contenedores, no administrarlos ',
                '- Como muchas herramientas, ambas tienen pros y contras, y como siempre es importante saber en que contexto y que necesidades se necesitan suplir ',
            ]),
        new Item(Keys.CONTENEDORES_ARQUITECTURE,
            [
                '- Los contenedores son unidades estandar que empaqueta todo el codigo y sus dependencias, de manera rapida y confiable, sin importar el entorno ',
                '- Estos son unidades portatiles y casi todos se basan en Linux, aunque Microsoft ha invertido para que tambien sean compatibles y eficientes en Windows ',
                '',
                '<strong>Docker Client</strong> &rarr; Cuando el comando <em>docker container run</em> que esta expuesta por el Docker daemon',
                '     &uarr;&darr;',
                '<strong>Docker Daemon</strong> &rarr; Recibe instrucciones mediante un API gRPC que inicia el contenedor con especificaciones <em>OCI</em>',
                '     &uarr;&darr;',
                '<strong> containerd</strong>   &rarr; Recibe las instrucciones de alto nivel para crear el contenedor, instrucciones(runc)',
                '     &uarr;&darr;',
                '<strong>  shim/runc</strong>   &rarr; <em>runc</em> Construye e inicia el contenedor a bajo nivel, <em>shim</em> se convierte en el proceso principal del contenedor ',
                '<strong>  container</strong>      ',
                '',
                '- Docker en Linux utiliza varios namespaces del Kernel, cada contenedor tiene su propia colección de namespaces aislados ',
                ' - Identificación del proceso(pid)      - Comunicación entre procesos(ipc)',
                ' - Red(net)                             - User(user)',
                ' - Sistema de archivos/montaje(mnt)     - UTS(uts)',
                '',
                '- Si los namespaces aportan al aislamiento, tambien existe el Control de Grupos(cgroups) que limitan los recursos compartidos disponibles ',
                '- Ningun contenedor puede consumir recursos sin control alguno, recursos como CPU, RAM, Network, I/O, evitando posibles ataques DoS'
            ])
    ];

export const FRAMEWORKS =
    [
        new Item(Keys.FRAMEWORKS_FRAMEWORKS,
            [
                '- Son marcos de trabajo con la finalidad de acelerar y aumentar la calidad del codigo desarrollado ',
                '- Evitan perder tiempo desarrollando funciones que el propio entorno ya tiene ',
                '- Aumentan la productividad y la reutilización de codigo ',
                '- Existen infinidad de frameworks tanto para back como front, desarrollo movil, persistencia y analisis de datos, etc... '
            ]),
        new Item('ioc',
            [
                '- La inversion de control es la implementación del principio de Hollywood en la que se basan muchos frameworks para funcionar ',
                '- El framework es quien toma el control de la ejecución del codigo del usuario modificando el ciclo de vida como tal ',
                '- Permite añadir nuevas funciones prefabicadas sin tener que modificar el codigo por medio de la inyección de dependencias ',
            ]),
        new Item(Keys.FRAMEWORKS_IOD,
            [
                '- La inyección de dependencias Permite modificar y extender nuestro codigo mucho más facil ',
                '- Solo es especificar que funcionalidades queremos añadir y estaran disponibles de manera transversal ',
                '- El codigo modificado se vuelve más reutilizable, compacto y manejable, además de que tiene un mejor reparto de responsabilidades ',
                '- Asi se tiene un codigo compuesto, menos acoplado y mejor abstraido, donde lo más importante es que hace, en vez de como lo hace ',
                '- Tambien ayuda al manejo implicito de las dependencias y una mejor visión de como se relacionan las diferentes partes del sistema'
            ]),
        new Item('scafolding',
            [
                '- Es la generación automatica de codigo funcional, archivos, carpetas, configuraciones, interfaces graficas, etc... ',
                '- Generalmente se basa en la creación de las operaciones CRUD, basandose en un modelo de datos previo ',
                '- Algunos frameworks pueden ayudar en este sentido, e incluso existen aplicaciones con este proposito ',
            ]),
        new Item('iodSpring',
            [
                '- La inyección de depencias es un patron de diseño que promueve un bajo acoplamiento y una gran modularidad ',
                '- El framework de Spring ha adoptado este principio y permite 3 formas diferentes de implementarlo ',
                '- Esto permite delegar la administración de los objetos necesarios al framework y asi preocuparse en el porque, en vez del como ',
                '',
                '<strong>Inyección por constructor:</strong> Proporciona todas las dependencias de un objeto al momento de su inicialización ',
                ' - la cual se realiza mediante el propio constructor de la clase',
                '<strong>Inyección por campo:</strong> Establece directamente las dependencias en los campos de una clase, siempre que se anote con <em>@Autowired</em> ',
                ' - esto se hace por medio de reflexión, iterando sobre los campos e inyectando las dependencias despues de crear la instancia ',
                ' - esto se puede evitar y hacer que las inyecciones de este tipo, sean perezosas, ',
                ' - validandose e inyectandose, solamente justo antes de usarse, si el campo tambien se anota con <em>@Lazy</em>',
                '<strong>Inyección por setter:</strong> Se proporciona la dependencia, a traves de un metodo setter, esto es adecuado para escenarios ',
                ' - donde la mutabilidad de las dependencias es posible ',
                '',
                '- Los primeros 2 tipos son similares, pero con diferencias sutiles que hacen que se prefiera la de constructor sobre la de campo ',
                '',
                '<strong>Inmutabilidad:</strong> La instancia puede ser marcada como <em>final</em> por lo que se evitaran errores, ',
                ' - si se intentara modificar el valor inyectado por error ',
                '<strong>Dependencias Explicitas:</strong> Esto hace que todas las depencias necesarias para el funcionamiento sean claras y visibles ',
                ' - desde el principio, ayudando a entender mejor la relacion entre las clases y sus dependencias ',
                '<strong>Testing unitario:</strong> Se facilitan los tests ya que se pueden pasar los objetos simulados(mocks) como argumentos al crear la prueba ',
                ' - sin tener que usar reflexión o otros metodos, para configurar el ambiente ',
                '<strong>Fail Fast:</strong> Si hay algun fallo en alguna dependencia, o en las subdependencias, la aplicación fallara justo al iniciar ',
                ' - por lo que cualquier fallo o dependencia requerida, sera detectado como un fallo temprano, y no cuando se este en ejecución ',
                '<strong>Seguridad en tiempo de compilación:</strong> De esta manera es posible asegurarse de proporcionar todas la instancias necesarias ',
                ' - antes de que se ejecute la aplicación, reduciendo errores en tiempo de ejecución ',
                '',
                '- Aunque los otros tipos tienen casos donde son más convenientes, e incluso la unica opción, la Inyeción por Constructor ',
                ' - se considera la mejor opción, creando aplicaciones más testeables, robustas y mantenibles ',
            ]),
        new Item(Keys.FRAMEWORKS_CODE_STRUCTURE,
            [
                '- Al desarrollar una aplicación con Spring, a menudo el desarrollador se enfrenta con la decisión de como ordenar los paquetes de la aplicación',
                '- 2 enfoques comunes suele ser el de dividir los paquetes por <em>capa</em> o por <em>feature</em>, con ventajas y desventajas para cada enfoque ',
                '',
                '<strong>Por capas:</strong> Los componentes se organizan en función de capas funcionales, representado una responsabilidad distinta dentro de la arquitectura',
                '<strong>Por funcionalidad:</strong> Se organizan en función de caracteristicas comunes o funcionalidades, estando contenida junto a los componentes necesarios ',
                '',
                'com.example.myapp                               com.example.myapp             ',
                '├── controller                                  ├── user                      ',
                '│   ├── UserController.java                     │   ├── UserController.java   ',
                '│   ├── ProductController.java                  │   ├── UserService.java      ',
                '│   └── ...                                     │   ├── UserRepository.java   ',
                '├── service                                     │   └── User.java             ',
                '│   ├── UserService.java                        ├── product                   ',
                '│   ├── ProductService.java                     │   ├── ProductController.java',
                '│   └── ...                                     │   ├── ProductService.java   ',
                '├── repository                                  │   ├── ProductRepository.java',
                '│   ├── UserRepository.java                     │   └── Product.java          ',
                '│   ├── ProductRepository.java                  ├── config                    ',
                '│   └── ...                                     │   ├── AppConfig.java        ',
                '├── model                                       │   ├── SecurityConfig.java   ',
                '│   ├── User.java                               │   └── ...                   ',
                '│   ├── Product.java                            └── util                      ',
                '│   └── ...                                         ├── StringUtils.java      ',
                '├── config                                          └── ...                   ',
                '│   ├── AppConfig.java                                                        ',
                '│   ├── SecurityConfig.java                                                   ',
                '│   └── ...                                                                   ',
                '└── util                                                                      ',
                '    ├── StringUtils.java                                                      ',
                '    └── ...                                                                   ',
                '                                                                      <strong> Pros </strong>   ',
                '- Separacion clara de responsabilidades, mejorando la mantenibilidad        - Alta cohesión al agrupar componentes directamente relacionados,',
                '- Modificar una capa, no necesariamente afecta a las demas                   - promoviendo la encapsulación, modularización y mantenibilidad ',
                '                                                                            - Nuevas funciones son independientes entre si, reduciendo posibles',
                '                                                                             - efectos segundarios ',
                '                                                                     <strong> Contras <strong>                                              ',
                '- Rigidez para agregar nuevas funciones, afectando multiples capas          - Componentes tranversales pueden generar codigo duplicado',
                '- Dificulta la modularidad y una división,                                  - La navegabilidad se puede complicar si existen, ',
                ' - basado en contextos para microservicios                                   - muchos componentes compartidos ',
                '',
                '- Ambos enfoques son totalmente compatibles con <em>POO</em>, solo que se enfatizan aspectos diferentes, ',
                ' - en la división por capas, se enfoca en el Principio de Responsabilidad Unica(SRP), mientras que ',
                ' - en la división por funcionalidad se proporciona una mayor cohesión y una mejor encapsulación ',
            ])
    ];

export const POO =
    [
        new Item(Keys.POO_POO,
            [
                '- Paradigma de programación, que nos permite crear aplicaciones complejas, manteniendo una base de codigo entendible y manejable ',
                '- Por eso uno de sus principios es <em>Alta integridad, Bajo acoplamiento</em>',
                '- Mejora la abstracción y el diseño de las soluciones, al acercar los problemas a lo cotidiano ',
                '- Esta forma de programación tambien requiere de una forma de pensar en <em>Objetos</em> por lo que puede debe ser lo menos subjetiva posible ',
                '',
                '<strong>Clases:</strong> Abstracciones de la realidad, convertidas en plantillas, que contienen una serie de caracteristicas y acciones ',
                '<strong>Objetos:</strong> Instancias creadas a partir de una clase, con propiedades similares ó iguales, pero a su vez tambien con una propiedad unica ',
                '<strong>Propiedades:</strong> Atributos o caracteristicas de un objeto, estos pueden pertener a un solo objeto ó ser comun a todos los objetos ',
                '<strong>Metodos:</strong> Comportamientos o acciones de un objeto, que este puede realizar al ser invocadas ',
            ]),
        new Item(Keys.POO_POO_PILARES,
            [
                '<strong>Encasulapción:</strong> Todas las propiedades del objeto solo le competen al objeto ó su clase ',
                '<strong>Abstracción:  </strong> Las acciones son publicas pero su complejidad esta oculta; todos necesitan el que, más no interesa el como ',
                '<strong>Herencia:     </strong> Todo hijo tienen acceso a los metodos y atributos del padre, además de las propias, pero el padre no conoce a ningun hijo ',
                '<strong>Polimorfismo: </strong> Cada objeto se puede comportar diferente, aunque tenga una misma base, solamente cambiandose por la instancia deseada ',
            ]),
        new Item('composicion',
            [
                '- En los diagramas UML se suele representar por medio de un diamante con o sin relleno, ubicado en la clase contenedora ',
                '- En cuestion de codigo ambas relaciones no cuentan con grandes diferencias entre si (en la mayoria de lenguajes) ',
                '- La principal diferencia es a nivel conceptual, donde esto puede ayudar a entender mejor el problema y su modelado ',
                '',
                '<strong>Agregación:</strong> Indica que una clase es parte de otra, y que los componentes pueden ser compartidos por otros ',
                '- La destrucción del compuesto no necesariamente indica la destrucción de todos los formantes ',
                '- Se suele representar mediante un diamante sin relleno en UML',
                '- Cualquier Empresa Tiene 0..* Clientes, los clientes y la empresa pueden vivir independientemente el uno del otro ',
                '',
                '<strong>Composición:</strong> La clase contenida y el contenedor deben tener los mismmos ciclos de vida ',
                '- Los objetos contenidos son solamente del objeto contenedor, si este se destruye, todos sus componentes tambien ',
                '- Su representación en UML se da mediante un diamante con relleno ',
                '- Una Empresa tiene 1..* Empleados, si NO existe una empresa, NO pueden existir sus empleados ',
            ]),
        new Item('pooStatic',
            [
                '- Metodos o atributos que pertenecen a la clase y no al objeto en si, aunque estos generalamente son consultados y/o usados por estos ',
                '- Pueden ser accesibles de manera global, hay que ser cautelosos con su uso ya que son vulnerables ante la concurrencia ó efectos secundarios ',
                '- No necesitan ser instanciados para ser usados, solo basta con saber en que clase fueron implementados(metodos), declarados(atributos)',
                '- Si es un metodo, debe estar implementado por obligación, no puede ser abstracto '
            ]),
        new Item('sobrecarga',
            [
                '- Algunos lenguajes permite sobrecargar los metodos y constructores, siempre y cuando este no sea cohibido ',
                '- El nombre sera el mismo pero deben recibir una cantidad/tipos diferentes de parametros o retorno, cambiando la firma del metodo ',
                '- Deben tener diferencias entre si, de lo contrario el compilador sacara error ',
            ]),
        new Item('acoplamiento',
            [
                '<strong>Aferente:</strong> Hace referencia a una clase con un alto grado de responsabilidad y una jerarquia bastante alta',
                ' - Esto es indicativo de la herencia, por lo que es pertinente modificarla con cuidado, debido a posibles efectos colaterales ',
                ' - Este tipo de clases solo usa atributos y metodos principalmente de las clases padre ó propios y poco o nada de entidades externas ',
                '',
                '<strong>Eferente:</strong> Es un paquete o clase con un alto grado de dependencia, esto condiciona el comportamiento de la clase ',
                ' - Siendo casi totalmente dependiente de las entidades externas, por lo que es más suceptible a efecto colaterales por cambios en estas ',
                '',
                '- Idealmente se debe evitar el acoplamiento Eferente y buscar el Aferente, ya que este conlleva una mejor estabilidad y mantenimiento ',
            ]),
        new Item(Keys.POO_DESIGN_BY_CONTRACT,
            [
                '- Diseñar por contratos ó Programar por Contrato, mejora la compresión de POO al mejorar la especificaciónes de los elementos ',
                '- Tambien puede servir como documentación, la cual se puede ir haciendo a la par con la codificación ',
                '- Uso eficaz de la herencia y la reutilización ',
                '- Las Responsabilidades estan previamente  definidas y romperlas es más dificil y complejo ',
                '- Se manejan los conceptos de precondiciones y postcondiciones, definiendo en que casos se pueden reforzar y/o debilitar ',
                '- Se puede conseguir una disminución de errores, a la vez que ayuda a detectarlos ',
                '',
                '- Se debe especificar cierta informacion, para que puedan existir un <em>cliente</em> que firme un <strong>contrato</strong> con el <em>proveedor</em>',
                ' - ¿ Que hace ?                - ¿ Posibles Errores ó Excepciones ?',
                ' - ¿ Parametros ?              - ¿ Significado de entradas y salidas ?',
                ' - ¿ Tipos de Datos ?          - ¿ Garantias ?',
                ' - ¿ Retorno ?                 - ¿ Efectos segundarios ?',
            ]),
        new Item(Keys.POO_DESIGN_BY_CONTRACT_PARTS,
            [
                '- Un buen software parte de un buen diseño y no solamente es una buena implementación ',
                '- Debido a que un contrato es una construcción que impone reglas para las partes involucradas, estas se suelen definir: ',
                '',
                '<strong>Precondiciones:</strong> Son las comprobaciones que realiza el codigo antes de ejecutarse ',
                '- Generalmente suelen comprobar el conjunto de datos proporcionado, además de las configuraciones y variables del contexto ',
                '- Las subclases pueden debilitarlas pero no reforzarlas, ya que incumpliria el <em>Principio de Sustitución de Liskov</em>',
                '',
                '<strong>Postcondiciones:</strong> Son el paso posterior despues de haber ejecutado la función/metodo ',
                '- Suelen ser resultados o acciones extras que se esperan despues ó como complemento de la acción principal ',
                '- Las subclases pueden reforzarlas pero no debilitarlas, ya que los clientes esperan y confian en que estas se sigan cumpliendo ',
                '',
                '<strong>Invariantes:</strong> Todo aquello que se debe mantener constante, antes y despues, de cualquier ejecución del metodo ',
                '- Como cuando hay propiedades No <em>Inmutables</em> que <strong>NO</strong> pueden ser modificadas, pero se necesitan para hacer calculos ',
                '- Las subclases pueden reforzarlas pero no debilitarlas, ya que se comprometeria el comportamiento, <em>Principio Open/Close</em> ',
                '',
                '<strong>Efectos Segundarios:</strong> Cualquier cambio de estado ó en el entorno que ocurre como consecuencia de la ejecución del metodo ',
                '- Pero que no forma parte explicita de las responsabilidades del contrato, puede ser evidente o inesperado ',
                '- Si estos efectos segundarios violan o afectan las invariantes, son indicadores de un diseño/codificación defectuosos ',
            ]),
        new Item('descomposicion',
            [
                '- La descomposición funcional Se refiere al proceso de resolución y separación de las funciones en sus partes consituyentes, ',
                ' - de tal manera que la función original se pueda reconstruir sin verse alterada al visualizarla como un todo ',
                '',
                '- Este proceso se lleva a cabo con la idea de desmenuzar la realidad en sus partes constitutivas más elementales ',
                ' - esto ayuda a la modularización del diseño, y una mejor definición de responsabilidades ',
                '',
                '- Se debe realizar de manera responsable y bien planeada, ya que su abuso puede resultar en un antipatron, ',
                ' - donde el costo de integración entre elementos es demasiado elevado, no es partir porque si, es hacerlo donde se debe ',
            ]),
        new Item(Keys.POO_HERENCIA,
            [
                '- Caracteristica proveida por los lenguajes, donde una clase o plantilla pueda ser creada a partir de otra ya existente ',
                '- Esta reutilización permite obtener caracteristicas(atributos) y comportamientos(metodos) similares a los ya existentes ',
                '- Todo comportamiento heredado puedo ser sobrescrito por cualquiera de los hijos, dando lugar al polimorfismo, si el lenguaje lo permite ',
                '- Es usada para la reutilización de codigo, definir jerarquias, y obtener comportamientos especializados ',
                '',
                '- La herencia Puede ser de diferentes tipos: ',
                '<strong>Simple:        </strong> Cada hijo SOLO puede heredar de una clase padre, más no restringe que un padre tenga muchos hijos ',
                '<strong>Multiple:      </strong> Las clases pueden heredar a partir de una o más clases, esto puede traer problemas si hay atributos o metodos con nombres iguales ',
                '<strong>Implementación:</strong> Los metodos pueden ser sobreescritos; permitiendo usarse tal cual vengan del padre ó modificarlos y cambiar su comportamiento ',
                '<strong>Interfaz:      </strong> La firma de los metodos es heredada, pero su implementación no, esta es responsabilidad de todo aquel que lo necesite usar ',
            ]),
        new Item(Keys.POO_POLIMORFISMO,
            [
                '- El polimorfismo es la capacidad de adoptar diferentes comportamientos ante un mismo estimulo, dependiendo de si se es un tipo o un super tipo ',
                '- Es una relajación del sistema de tipos en lenguajes tipados, además de que es un consecuencia directa de la herencia ',
                '- Este se puede lograr de diversas maneras, no solo con la herencia, como el uso de interfaces, sobrecarga de metodos, uso de genericos ',
                '- No deben confundirse la Sobrecarga(Overloading), con la Sobreescritura(Overriding), ya que son diferentes formas de polimorfismo ',
                '- Al estar tan ligado a la herencia, es inevitable tener en cuenta la relación de <em>Ser/Tener</em>, asi se puede evitar el mal uso de la herencia '
            ]),
        new Item('herVScomp',
            [
                '<strong>        Caso                Diseño basado en Herencia                          Diseño basado en Composición</strong>',
                ' Inicio del desarrollo        Más rapido                                           Más lento                               ',
                ' Diseño del software          Facil pero pobre                                     Más complejo                            ',
                ' Efectos no deseados          Propicia                                             Reducidos                               ',
                ' Adaptabilidad                Entre más niveles más complejidad                    Facil de cambiar (instancias)           ',
                ' Testing                      Entre más sobreescritura más dificil de cambiar      Piezas acotadas y fronteras claras      ',
                ' Extension                    Debe hacerse con cuidado de no extender "basura"     Facil incorporación de piezas nuevas    ',
                ' Polimorfismo                 No es necesario ningun mecanismo extra               Se puede lograr mediante interfaces     ',
                ' Crecimiento                  Dificil, al heredar "basura" junto a lo nuevo        Se incorporan o extienden nuevas piezas '
            ]),
        new Item(Keys.POO_ENLACES,
            [
                '- La asociación entre la definición de los metodos y variables, se suele dar de 2 maneras, durante tiempo de ejecución y de compilación ',
                '- Todo lo se pueda conocer en tiempo de compilación, y que es necesario para que el programa se pueda ejecutar se conoce como enlace estatico ',
                '- Lo demás que es necesario ejecutar el programa para conocer su valor y su comportamiento, se conoce como enlace dinamico ',
                '- Los miembros privados, finales y estaticos usan el enlace estatico, mientras que los metodos anulados y en general son por enlace dinamico '
            ]),
        new Item(Keys.POO_COUPLING_COMPONENTS,
            [
                '- Los componentes deberian estar estructurados de manera jerarquica, y de manera que tengan poca complejidad entre sus relaciones, ',
                '- Tambien es ideal reducir la dependencia entre si, en la medida de lo posible; Existen varios tipos a tener en cuenta: ',
                '',
                '<strong>Principio de dependencia aciclicas <em>ADP</em></strong>',
                '- Las dependencias circulares no deberian existir ',
                '- Si estan existen, deberian convertirse en un solo componente para no afectar al resto ',
                '- A mayor tamaño del software, más problemas en cuanto a relaciones y la compilación de este ',
                '- Utilizar la inversion de dependencias para evitar relaciones arbitrarias y/o acopladas ',
                '- Separar y tener claro que puede ser volatil y que es más constante ',
                '',
                '<strong>Principio de dependencias estables <em>SDP</em></strong>',
                '- Un componentes dificl de cambiar (estable) no deberia depender de un componente volatil ',
                '- Esta relación se puede calcular sabiendo quienes son dependientes y de quien depende el componente ',
                '- Dependencias entrantes: quienes estan afuera y dependen de este (interno) ',
                '- Dependencias salientes: quien esta adentro y dependen de otros (externos) ',
                ' - 0   == estabilidad       Esto se calcula mediante la siguiente formula: ',
                ' - 0-1 == intermedio        inestabilidad =        salidas       ',
                ' - 1   == inestable                         (entradas + salidas) ',
                '',
                '<strong>Principio de abstracciones estables <em>SAP</em></strong>',
                '- Los componentes deben abstraerte hasta el grado de estabilidad deseado ',
                '- Los partes criticas de nuestro sistema deberian ser estables y de alto nivel ',
                '- Las partes volatiles deben poder ser cambiadas con gran facilidad, con minimas afectaciones a los demás ',
                '- Las clases abstractas e interfaces son indicativos de estabilidad ',
            ]),
        new Item('beginingPoo',
            [
                '- Los paradigmas funcional e imperativo se iniciaron a explorar matematicamente en 1930, gracias al calculo lambda y la maquina de turing ',
                '- Ya en 1940 aparecen los lenguajes de bajo nivel y de ensamblaje ',
                '- A finales de 1950 aparecen los primeros lenguajes de alto nivel, los dialectos Lisp como FORTRAN Y COBOL, ó Clojure que es más actual ',
                '',
                '- POO fue acuñada por <strong>Alan Kay</strong> alrededor de 1966 mientras estudiaba su posgrado ',
                '- El primer lenguaje Orientado a objetos reconocido fue Simula, este presentaba objetos, herencia, clases, subclases, y metodos virtuales ',
                '- La gran idea era usar minicomputadoras encapsuladas en software que se comunicaran a traves del paso de mensajes en vez de datos directamente ',
                '- Con esto en mentes se desarrollo Smalltalk, más de objetos que Simula, aca todo es un objeto, aun asi, estaba inspirado en Lisp y Simula ',
                '- Segun Alan kay, la principal idea era la mensajeria y no los <em>objetos</em> como lo es hoy en dia ',
                '',
                '  Ingredientes esenciales                                             Elementos NO esenciales ',
                '   - Paso de mensajes                                                   - Clases y tipos estaticos ',
                '   - Encapsulación                                                      - Herencia y polimorfismo',
                '   - Union dinamica (adaptación en tiempo de ejecución)                 - Tratamiento especial para objetos/funciones/datos ',
                '   - Evitar la mutabilidad y estados compartidos                        - la palabra clave (new) ',
                '',
                '- Muchas de las caracteristicas esenciales para Alan Kay fueron ignoradas por los lenguajes de la familia C, C++, Java, C#, etc... ',
                '- Los sistemas de tipos demasiado restrictivos para la libre expresión de ideas dinamicas y funcionales dificultan la simplicidad del codigo ',
                '- La orientación a objetos modernas no refleja los conceptos que la iniciaron, más bien seria una Programación orientada a mensajes (MOP)',
                '',
                '- POO significa (segun Alan Kay): ',
                ' - Programación con componentes <em>objetos</em>',
                ' - El estado del componentes debe estar encapsulado y solo puede ser manipulado por si mismo ',
                ' - El paso de mensajes para la comunicacion entre objetos y que estos sean ',
                ' - Los componentes se pueden agregar/cambiar/reemplazar en tiempo de ejecución ',
                ' - La mayoria de los comportamientos se pueden especificar de manera generica usando estructuras de datos algebraicas, sin herencia '
            ]),
        new Item(Keys.POO_INMUTABILITY,
            [
                '- Es la propiedad de un objeto de no cambiar su estado, una vez haya sido declarado ',
                '- Esto permite que sean seguros en lenguajes que soportan el uso de hilos (thread-safe) ',
                '- En diferentes lenguajes y en el paradigma funcional, esto es inherente, pero en otros como Java se puede lograr por otros medios ',
                '- Este concepto tambien se aplica a las funciones(puras), generalmente deberian devolver el mismo valor, ante las mismas entradas ',
                '',
                '<strong>Ventajas:</strong>',
                '- Los objetos siempre seran los mismos, facilitando la depuración de ser necesario ',
                '- Menos propenso a errores y efectos segundarios (side-effects) ',
                '- Sin problemas para la paralelización y posibles mejoras de rendimiento al manejar menos referencias ',
                '- Mejora el encapsulamiento y la abstracción '
            ]),
        new Item('typesPolimorfismo',
            [
                '- El polimorfismo no es un concepto exclusivo de los lenguajes Orientados a Objetos',
                '- Este esta estrechamente relacionado con las capacidades que se le otorgan al programador y el comportamiento del lenguaje ',
                '- Existen 2 tipos principales según, pero estos pueden diferir de acuerdo al autor respectivamente ',
                '',
                '<strong>Universal:</strong> Inclusión, Parametrico, En fila ',
                '<strong>Ad-hoc:</strong> Sobrecarga, Cohesión ',
                '',
                '<strong>Sobrecarga </strong> ',
                ' - Es el proceso de utilizar un mismo nombre para una función, pero con algun cambio en la declaración ',
                ' - Aca es donde el compilador se encarga de diferenciar y saber cual se debe usar ',
                '',
                '<strong>Coerción </strong> ',
                ' - Es una operación de traducción/mapeadora para convertir el tipo del argumento al tipo esperado ',
                ' - Se diferencia del de Sobrecarga ya que este es un enfoque sintactico y el Coerción es de tipo semantico ',
                ' - El proceso puede ser explicito o implicito, e incluso dinamico o estatico, dependiendo del sistema de tipos subyacente ',
                '',
                '<strong>Parametrico </strong> ',
                ' - La idea es implementar generalizaciones sobre funciones, para hacerlas disponibles a diferentes tipos de datos ',
                ' - Dependiendo del lenguajes se puede considerar programación generica o de plantillas ',
                ' - Tambien permite la inferencia se de por el propio sistema de tipos para las operaciones a realizar ',
                '',
                '<strong>Inclusivo </strong>',
                ' - Al establecer una jerarquia, es posible heredar propiedades y metodos en comun entre ellos ',
                ' - Esto da lugar a 2 aspectos de generalizaciónn y especialización simultaneamente ',
                ' - Es importante saber cuando se deben usar los "subtipos" y cuando no, de aca se desprenden otros 2 subtipos',
                ' <strong>- Nominal: </strong> Es una declaración explicita de la relación y una forma de hacerlo seria la Herencia ',
                ' <strong>- Estructural: </strong> Mediante una equivalencia que exprese la relación intrinseca, como serian las Interfaces',
                ' - Este 2do suele ser más facil de reutilizar en casos no previstos, aunque no tiene control sobre la jerarquia que el 1ero ',
                '',
                '<strong>De fila </strong>',
                ' - Este tipo aplica especialmente para registros, ya que estos tienen un desafio particular cuando son pasados a función ',
                ' - Para evitar esta perdida de información se suele usar un enfoque estructural evitando perdidas por la conversion implicita ',
                ' - No se usa un enfoque de subtipos, ya que que no suele haber una relación entre registros',
                ' - Un ejemplo donde se evidencia podria ser un Narrowing casting donde se pasa de Auto a Vehiculo, sin perdidad de información ',
                ' - No todos los lenguajes lo soportan, por lo que es poco conocido ',
            ]),
        new Item('factoryMethods',
            [
                '- Los metodos de fabrica funcionan como un constructor, entregando instancias completamente inicializadas ',
                '',
                '<strong>Ventajas:</strong> ',
                '- Tienen nombres significativos, por lo que un factory method puede ser más explicito en lo que hace ',
                '- Pueden devolver el mismo tipo, un subtipo e incluso primitivos si se da el caso, por lo que son más flexibles ',
                '- Encapsulan toda la logica requerida para la construcción de los objetos, alivianando la carga del constructor ',
                '- Pueden controlar las instancias, por ejemplo el patron Singleton ó un constructor semantico ',
                '- La inmutabilidad puede ser una caracteristica inherente a su uso ',
                '',
                '- Estos tambien pueden ser personalizados o venir previamente incluidos en el SDK como la clase <strong>Collections</strong>',
            ]),
        new Item('interfacesOverInheritance',
            [
                '- La Herencia puede ser malvada, mal manejada principalmente por eso se recomienda un diseño en base a interfaces y abstracciones, ',
                ' -  en vez de depender de clase concretas que ya cuenten con un codigo base ',
                '- Alguna vez <em>James Gosling</em> uno de los inventores de Java, dijo en una sesion de preguntas y respuestas, que no crearia las <strong>Clases</strong> ',
                '- Haciendo referencia que el verdadero problema no son las clases, si no la herencia de implementación <em>extends</em>, ',
                ' - en vez de la herencia de interfaz <em>implements</em> ',
                '',
                '- Uno de los problemas es que el uso explicitos de nombres de las clases concretas, encierra implementaciones especificas, ',
                ' - esto dificulta cambios posteriores ',
                '- Actualmente con el uso de metodologias agiles; los sistemas se empiezan a desarrollar sin la necesidad de que todo el sistema se especifique ',
                '- Para que esto sea posible, la flexibilidad debe ser una caracteristica inherente del sistema, para que cada cambio sea más rapido y facil ',
                '',
                '- Esto tambien reduce la confianza indeseable de una parte del programa en otra, ó en otras palabras el <em>Acoplamiento</em> ',
                '- Todo diseño debe intentar reducirlo lo minimo posible sin eliminarlo, ya que significaria que no habria interacción alguna entre el sistema ',
                '- En la herencia toda clase que herede conoce las acciones de su padre, por lo que si se llegara a cambiar la base, esto afectaria a sus hijos ',
                ' - de maneras deseadas e indeseadas por igual, si no se tiene cuidado ',
                '- Si una clase llega a tener la necesidad de anular metodos del padre; debido a un malfuncionamiento, se deberia reconsiderar su uso ',
            ]),
        new Item('enumeraciones',
            [
                '- Una enumeración es una clase <em>especial</em>, que limita la creación de objetos al conjunto especificado explícitamente dentro la clase',
                '- Las enumeraciones existen en multiples lenguajes, especialmente si son fuertemente tipados',
                '- Si la enumeración tiene atributos, todos los constructores que se vayan a usar, deben ser privados',
                '- Estas son clases finales implícitas, evitando convertirse en cualquier tipo de subclase/superclase',
                '- Pueden implementar contratos (interfaces), obligando a que cada valor de la enumeración, implemente y defina el debido comportamiento',
            ]),
        new Item(Keys.POO_COUPLING_AND_COHESION,
            [
                '<strong>Cohesion:</strong> Se centra en como diseñar cada modulo o clase y entre mejor sean las relaciones mejor sea el Diseño Orientado a Objetos ',
                '- Esta aumenta si las funciones y atributos de una clase tienen caracteristicas en comun, y además cumplen el Principio de Responsabilidad Unica ',
                '- Una baja cohesión esta directamente asociada a problemas como poca mantenibilidad, codigo poco claro y dificil de testear ',
                '',
                '<strong>Tipos:</strong> (Peor -> Mejor)',
                '<strong>- Coindencial:</strong> Las partes de un modulo se agrupan arbitrariamente, sin necesidad de alguna relación ',
                '<strong>- Logica:</strong> Se agrupan al estar categorizadas para hacer logicamente lo mismo, aun con diferentes naturalezas ',
                '<strong>- Temporal:</strong> Las partes de un modulo se agrupan segun el momento en que se realizan',
                '<strong>- Comunicacional:</strong> Las partes de un modulo se agrupan porque operan sobre los mismos datos ',
                '<strong>- Secuencial:</strong> Las partes de un modulo se agrupan porque la salida de una parte es la entrada de otra parte ',
                '<strong>- Funcional:</strong> Las partes se agrupan porque todas contribuyen a una unica tarea bien definida, no siempre es alcanzable ',
                '',
                '<strong>Acoplamiento:</strong> Es la fuerza de las relaciones entre los modulos y que tan relacionados estan ',
                '- Para esto se suelen usar interfaces o contratos, que generalmente son mas estables que sus implementaciones ',
                '- Si se tiene un alto acoplamiento, se suelen tener grandes problemas en cuanto a mantenibilidad, facilidad para realizar cambios y correciones ',
                '',
                '<strong>Tipos:</strong> (Alto -> Bajo)',
                '<strong>- Content:</strong> Se utiliza el codigo de otro modulo, violando el ocultamiento de la información ',
                '<strong>- Common:</strong> Se da cuando varios modulos tienen acceso a los mismos datos globales, un cambio erroneo puede propagar errores sin control ',
                '<strong>- External:</strong> Sucede cuando 2 partes comparten un formato de datos o protocolo de comunicación, generalmente con sistemas externos ',
                '<strong>- Control:</strong> Un modulo controla a otro, impartiendo acciones e información sobre que hacer ',
                '<strong>- Stamp:</strong> Comparten una estructura de datos, la cual usan en su integridad o parcialmente ',
                '<strong>- Data:</strong> Lo unico que comparten son datos a traves de diversas formas, como parametros ',
            ])
    ];

export const LEYES =
    [
        new Item('balas',
            [
                '- El software puede tener dificultades inherentes al software y accidentales ',
                '- Los errores son gajes del oficio, pero tienen diferentes grados de repercusión en el software ',
                '- Jamas sera lo mismo un error semantico a uno de diseño, el primero podria pasar por trivial, pero el segundo NO ',
                '',
                '<strong>Complejidad</strong>',
                '- La complejidad es directamente proporcional al tamaño ',
                '- Esta es una propiedad intrinseca del software, que no se puede desligar de su diseño o construcción ',
                '- De esta complejidad nacen las dificultades para crecer sin afectar al resto del sistema ',
                '- Sin contar con los problemas tecnicos ó las dificultades de aprendizaje ',
                '',
                '<strong>Conformidad</strong>',
                '- Tener que ajustarse a otros diseños, necesariamente implica algo más que una refactorización ',
                '- No hay una sola manera para trabajar, por lo que hay acostumbrarse a las diferentes formas de cada persona ',
                '',
                '<strong>Variabilidad</strong>',
                '- El software esta sometido a la necesiadad de cambio constante, pero esto no necesariamente significa un "cambio" ',
                '- Se podria sacar un nuevo modelo ó una nueva versión, más no obligatoriamente cambiar lo que ya funciona ',
                '',
                '<strong>Invisibilidad</strong>',
                '- El software es un recurso intangible, solo entendible por la capacidad de abstracción y de visualización de los humanos ',
                '- Por eso es dificil diseñar sistemas ya que se deben usar sistemas conceptuales que deben ser comunicados sin perder su intención ',
                '',
                '<strong>POO</strong>',
                '- Los tipos de datos jerarquicos y datos abstractos, ayudan a eliminar dificultades accidentales del proceso ',
                ' - sin tener que escribir grandes cantidades de codigo para expresar cualquier intención ',
                '',
                '<strong>Sistemas Expertos:</strong>',
                '- Es un sistema que tiene un motor de inferencia generalista, que toma entradas de datos, suposiciones, reglas y consige resultados ',
                '- Son más que algoritmos ya que no estan tan limitados como estos, y suelen poder soportar logica difusa y logica puramente determinista ',
                '',
                '<strong>Generación de codigo</strong>',
                '- Desde siempre se ha soñado con la capacidad para que un programa se genere para solucionar un problema ',
                '- Generalmente se debe especificar la solución o el contenido necesario para esta, más que el problema ',
                '',
                '- Para revisar los demás temas puedes ir a la fuente original ',
            ]),
        new Item(Keys.LEYES_LEHMAN,
            [
                '- El contenido(información) es eterno, pero no la materia que lo contiene(almacenamiento)',
                '',
                '<strong>Ley del cambio continuo:</strong> En la realidad las cosas deben seguir cambiando constantemente, de lo contrario eventualmente seran obsoletas ',
                '<strong>Ley de complejida creciente:</strong> Mientras algo siga creciendo, su complejidad tambien lo hara, a no ser que se tomen medidas para reducirla ',
                '<strong>Ley de evolución:</strong> Mientras algo crezca, tambien lo haran sus errores, casi siempre de manera promedio, estos se autoregulan ',
                '<strong>Ley de estabilidad organizacional:</strong> La velocidad de desarrollo sera casi siempre la misma, por más recursos que se inyecten ',
                '<strong>Ley de la conservación de la familiaridad:</strong> Un crecimiento desmesurado hara que el conocimiento basico sea insuficiente para seguir creciendo ',
                '<strong>Ley de crecimiento continuo:</strong> Las funcionalidades deben seguir mejorando para mantener a los clientes satisfechos ',
                '<strong>Ley de decremento de la calidad:</strong> La calidad de los sistemas comenzara a disminuir a menos que dichos sistemas se adapten a los cambios ',
                '<strong>Ley de retroalimentación:</strong> La comunicación con el cliente y con las personas conocedoras es fundamental ',
            ]),
        new Item(Keys.LEYES_CONWAY,
            [
                '- El impacto de la comunicación en tu empresa ',
                '- <em>Cualquier organización que diseñe un sistema producirá un diseño que copia la estructura de comunicación de dicha organización.</em>',
                '- El software es una habilidad intelectual humana, por lo que la comunicación es fundamental para la integración ',
                '',
                '- La manera de trabajar de tu empresa se vera reflejada en tu software, es el significado principal de esta frase ',
                ' - Equipos pequeños, crearan soluciones pequeñas, altamente modulares ',
                ' - Personas egoistas, generan problemas de integración de componentes y falencias al compartir su conocmiento ',
                ' - Empresas sin organización, generaran codigo complejo, pero funcional de manera rapida, que se convertira en una bola de nieve ',
                ' - Empresas orgullosas, que comparten su codigo y sus buenas practicas ',
                ' - Estos y más ejemplos hay, como empresas y personas halla ',
            ]),
        new Item('murphy',
            [
                '<strong>- Si algo malo puede pasar, pasara</strong>',
                '- Se inspira en el concepto fisico de la entropia, el cual dicta que todo sistema fluye del orden al desorden ',
                '- Puede ser util para ayudar a prevenir el desastre, si se usa para tomar precauciones ',
                '- No hay ninguna demostración matematica que la niegue ó la acepta, solo es un conocimiento nacido de lo cotidiano ',
            ]),
        new Item('pendulo',
            [
                '- Permite explicar comportamientos humanos cuando son llevados al extremo; Se puede producir por diferentes razones: ',
                '<strong>Idealización del opuesto:</strong> Cuando estamos constreñidos en algo, tendemos a idealizar el contrario ',
                '<strong>Necesidad de reafirmación:</strong> Buscando un gran impacto, generalmente elegimos los polos opuestos al ser vistosos ',
                '<strong>Comodidad del extremo:</strong> Son comodos ya que no tienen contenciones ni filtros, lo opuesto de una posicion intermedia ',
                '',
                '- Los extremos no necesariamente son malos, ya que permiten tener nuevas experiencias, y conocer nuevos puntos de vista ',
                '- Esto se debe hacer de manera racional, y bajo nuestra propia elección, para que podamos reflexionar en vez de seguir ciegamente ',
            ]),
        new Item(Keys.LEYES_HYRUM,
            [
                '- Cualquier cosa que ofrezcas será usada por alguien',
                '- El mantenimiento de las aplicaciones siempre va a ser una constante, por lo que reducir características inútiles es una opción de reducirlo ',
                '- El problema surge cuando algún cliente la estaba usando con otro fin, o simplemente le era útil para su nicho específico de mercado ',
                '- Hacer esto puede conllevar problemas con los clientes ya que estos cambios abruptos hacen sentir al cliente que no están siendo considerados ',
                '- También hay que tener en cuenta que estos cambios a veces son fundamentales y se deben hacer incomoden o no a tus usuarios ',
            ]),
        new Item('leblanc',
            [
                '- Esta ley nace debido a la tendencia natural de las personas de procastinar ',
                '- Haciendo referencia a esas cosas que se dice que se van a arreglar despues, pero... , nunca se terminan arreglando ',
                '- Despues es lo mismo que Nunca ',
                '- Estos pendientes se acumulan poco a poco y convertirse en una bola de nieve, lo ideal es hacerlos en el acto, o como tareas en el corto plazo ',
            ]),
        new Item('leyesInternet',
            [
                '- Las autoridades aun no encuentran una forma universal de controlar internet, porque este ha creado sus propias "leyes" para "autoregularse" ',
                '- Aunque se les llama leyes, son observaciones que se repiten a lo largo del tiempo y son poco contrariadas ',
                '- Un ejemplo de esto es la <em>Ley de murphy</em> que que tiene su propio ajuste para internet (ley de Skitt)',
                '',
                '<strong>Ley de Skitt:</strong> "Cualquier publicación que corrija un error en otra publicación contendrá al menos un error" ',
                '<strong>Ley de Godwin:</strong> "A medida que una discusión online se alarga, la probabilidad de que aparezca una comparación a Hitler o los nazis tiende a 1" ',
                '<strong>Ley de Poe:</strong> "Sin un emoticón u otra muestra de humor, es absolutamente imposible parodiar una idea sin que alguien la confunda con una opinión genuina" ',
                '<strong>Ley de Cunningham:</strong> "La mejor manera de conseguir una respuesta correcta en la red, no es haciendo la pregunta sino publicando una respuesta equivocada" ',
                '<strong>Ley de Exclamación:</strong> "Cuantos más signos de exclamación se usen, más probable es que sea una mentira. También aplica para el uso excesivo de mayúsculas" ',
                '<strong>Ley de Danth:</strong> "Si una persona tiene que insistir en la red que ha ganado una discusión, es probable que esa persona haya perdido el debate" ',
                '<strong>Regla 34:</strong> "Si existe, hay pornografía" ',
                '<strong>Regla 35:</strong> "Si no existe tal pornografía, se hará"',
                '<strong>Ley de Pommer:</strong> "La opinión de una persona puede cambiar en base a lo que lee en internet. La naturaleza del cambio será: de no tener, a estar equivocada" ',
                '<strong>Ley de Haig:</strong> "La fealdad de un diseño de una página en internet es directamente proporcional a la demencia de su contenido y de su creador" ',
                '<strong>Efecto Streisand:</strong> "Todo aquel que intente censurar u ocultar información en la red, acaba consiguiendo que se divulgue aún más" ',
            ]),
        new Item('pareto',
            [
                '- Tambien conocida como la regla de <strong>80/20</strong> que asegura que el 80% de las causas proviene del 20% del esfuerzo ',
                '- Termino acuñado en Italia en 1896 por el filosofo e ingeniero <em>Vilfredo Federico Pareto</em> ',
                '- Se utilizo conocimiento empirico para su comprobación, por medio de la propiedad de la tierra de esa epoca, ',
                ' - con la conclusión de que 20% de los propietarios poseia el 80%, mientras que el 80% restante solo poseia el 20% ',
                '- Con el paso del tiempo, esta relación se trasladado a diferentes ambitos de la sociedad, de manera equivalente ',
                '- Esta relación esconde un mensaje bastante importante, el cual es que debemos centrarnos en lo que realmente importa ',
                '- Asi no malgastaremos esfuerzos ni recursos en acciones que aportarian pocos o nulos beneficios ',
                '',
                '<strong> Ventajas de su aplicación:</strong> ',
                ' - Aumentar el ratio del trabajo eficiente, al identificar lo que es realmente importante ',
                ' - Mejor desarrollo de las actividades al gestionar mejor el tiempo ',
                ' - Reducción del efecto Burnout y del estres al simplificar y reducir las tareas a realizar ',
                ' - Mejora la toma de decisiones, al tener datos de lo que es realmente importante ',
                ' - Optimización de recursos, ya que se gastan donde realmente pueden generar un impacto '
            ]),
        new Item('brooksLaw',
            [
                '- <strong>Fred Brooks</strong>, Experto en computación e ingeniero de software desarrollador del sistema operativo OS/360 de IBM, además del ',
                ' - mitico libro del <em>hombre-mes</em>, uno de los libros más citados y utiles en el ejercicio de la ingenieria de software ',
                '- Una de las grandes enseñanzas que abordaba el libro es que la respuesta tipica ante un retraso es agregar mano de obra, ',
                ' - en la ingenieria de Software es practicamente como "apagar el fuego con gasolina" ',
                '- <em>Añadir recursos humanos a un proyecto retrasado hace que se retrase aún más</em> <strong>Tambien</strong> <em>Nueve mujeres no hacen un bebe en un mes</em>',
                '- Existe un lapso de tiempo en el que los programadores tienen que ponerse al dia, aprender nuevas tecnologias y/o metodologias, entre otras cosas ',
                '- Mientras el trabajo realizado <strong>aumentaba linealmente</strong>, la complejidad y los costos de comunicación <strong>crecian exponencialmente</strong>, si todo salia bien ',
                '- Además de que siempre existe la posibilidad de que el desconocimiento del proyecto provocase que el nuevo fichaje cometiera errores graves, ',
                ' - generando <strong>productividad negativa</strong>, al tener que corregir los errores ó realizar de nuevo lo que se trataba de hacer ',
                '- Sin embargo esta ley tiene algunas excepciones, como lo es Linux y el software libre, ',
                ' - en el cual miles de programadores estan dispuestos a revisar y corregir, aca se tienen una alta convicción para superar el desconocimiento ',
            ]),
        new Item('mooreAndWirth',
            [
                '- El software y el hardware van de la mano, no solo existen PC lentos, tambien existen software lentos ',
                '',
                '- El Software tiene la tendencia de ocupar todo el espacio disponible',
                '- El Software se ralentiza a mayor velocidad de lo que se acelera el hardware ',
                '',
                '- Esta afirmaciones, además de otras, encapsulan la complejidad y el costo de desarrollar software, se conocen como la <strong>La ley de Wirth </strong>',
                '- Acotada a Niklaus Wirth, padre de lenjuajes como Pascal o Modula, y que publico en 1995 un articulo con estas y otras observaciones ',
                '',
                '- <strong>Ley de Moore:</strong> Observo en 1965 que el numero de transistores en un circuito integrado, se dobla aproximadamente cada 24 meses ',
                '- No solo es lograr un Hardware más potente, tampoco se debe descuidar el Software, solamente porque sera compensado por mejores componentes '
            ]),
        new Item('amdahl',
            [
                '- Es una observación intuitiva, con una formula asociada, en que la mejora de rendimiento, que se puede obtener mediante procesamiento en paralelo ',
                ' - esta limitada por las partes de un sistema, que es inherentemente secuencial, donde la formula enseña la mejora maxima que se puede esperar ',
                '<strong> Smax = 1 / ((1-p) + p/s)</strong> Donde: ',
                '<strong> Smax:</strong> Es la maxima mejora teorica, en el tiempo de ejecución de toda la tarea, Por ejemplo, si es 2, significa que puede ser el doble de rapida',
                '<strong> p:</strong>    Es la proporción de tiempo total de ejecución invertido por la parte de la tarea, que se beneficia del procesamiento paralelo ',
                '<strong> 1-p:</strong>  Es la parte del tiempo total de ejecución que dedica la parte de la tarea que debe ejecutarse secuencialmente ',
                '<strong> s:</strong>    Es la mejora de rendimiento o aceleración de la parte de la tarea que se beneficia del procesamiento paralelo ',
                '',
                '- Para poner un ejemplo practico, si un programa con todas sus instrucciones en conjunto tarda 10 horas en ejecutarse en serie, ',
                ' - y una porcion no se puede paralelizar, lo mejor que se puede esperar es acercarse al limite de mejora de 10 veces, no importa ',
                ' - cuanto paralelices las nueve horas que pueden ser paralelas, nunca se podra eliminar la hora que debe ser ejecutada en secuencia ',
                '',
                '<strong>Ley de Gustafson</strong>',
                '- Esta ley se puede considerar un complemento, ya que agrega predicciones a la mejora, entre más nucleos se vayan agregando ',
                '- Esto debido a que la ley de Amdahl supone que el problema del tamaño es fijo, pero en la practica los recursos pueden crecer ',
            ]),
        new Item('gall',
            [
                '- Es una observación sobre la naturaleza y evolución de los sistemas complejos, un principio que resuena en el mundo del software ',
                '- <em>Invariablemente se descubre que un sistema complejo que funciona ha evolucionado a partir de un sistema simple que funcionó.</em>',
                '- <em>Un sistema complejo diseñado desde cero nunca funciona y no se puede reparar para que funcione.</em>',
                '- <em>Hay que empezar de nuevo con un sistema simple que funcione.</em>',
                '',
                '<strong>Observaciones:</strong>',
                '<strong>- Comienze simple:</strong> La idea es siempre empezar con el sistema más simple posible, esto suele estar en el linea con un <em>Minimo Producto Viable</em>',
                '<strong>- Evolución:</strong> Una vez el sistema funcione, ahora puede empezar a ampliarse y evolucionar a un sistema más complejo',
                '<strong>- Sobreingenieria:</strong> Tener una base compleja, por lo general trae más problemas que beneficios, además del desperdicio de recursos',
                '',
                '<strong>Aplicaciones en el Software</strong>',
                '- Implemente metodologias agiles, estas se alinean con el enfoque de un sistema simple y funcional ',
                '- Refactorización, como medidad de aseguarar el matenimiento a medida que crece',
                '- Monolitos modulares, en vez de un enfoque inicial de microservicios, asi los limites estan claros y una posible transición no seria tan dificil',
            ]),
        new Item(Keys.LEYES_KIDLIN,
            [
                '- Es una teoria de resolucion de problemas que dice: <em>Si escribes el problema claramente, el asunto está medio resuelto',
                '- La palabra <strong>Claramente</strong> te invita a conocer que es lo que falla, cual es el dolor principal y no los sintomas ',
                '- Si se comprende el problema de fondo, entonces podras idear una solución más adecuada ',
                '',
                '- Para aplicar esta ley se suele dividir el problema en partes más pequeñas y manejables',
                '- Tambien se suelen implementar etapas, que son bastante similares a las del <em>Ciclo de Deming</em>',
            ]),
        new Item(Keys.LEYES_GOODHARTS,
            [
                '<em>Cuando una medidad se convierte en un objetivo, deja de ser una buena medida</em>, Charles Goodhart',
                '- Cuando cualquier metrica se convierte en un objetivo o meta, las personas empezaran a cambiar su comportamiento para cumplir con esa metrica ',
                '- Esto a expensas del significado de la metrica y generalmente en detrimento de lo que intentaba representar ',
                '- Esto no significa que no se deban mediciones, sin mediciones no se puede saber que mejorar ',
                '',
                ' - Numero de lineas de codigo (Medir la productividad)',
                ' - Puntos de Historia completados (Velocidad del equipo)',
                ' - Cobertura de Codigo (Calidad de las pruebas)',
                '',
                '- Esto se evita teniendo estas metricas como guias hacia un objetivo y que se instauren de manera estatica ',
                '- Las metricas no siempre entregaran el mejor valor por solo ser cuantitativas, hay casos donde aporta más un enfoque cualitativo ',
            ]),
        new Item(Keys.LEYES_LINUS,
            [
                '<em>Si existen los suficientes ojos, todos los errores son osbservables</em>, Eric Raymond',
                '- Esta es una de las esencias del software libre, donde la participación activa de la comunidad ayuda a identificar y corregir errores ',
                '- De manera más eficaz que en los sitemas cerrados, al tener una mayor cantidad de manos identificando y solucionando errores ',
            ]),
        new Item(Keys.LEYES_HOFSTADTER,
            [
                '<em>Siempre lleva más tiempo del esperado, incluso cuando se tiene en cuenta la Ley de Hofstadter</em>, Douglas Hofstadter',
                '- Es un gran recordatorio de que somos consistentemente imprecisos al estimar el tiempo requerido para realizar tareas de Desarrollo ',
                '- Esto es especialmente util ya que los tiempos siguen siendo imprecisos, aun cuando se tiene en cuenta esta imprecisión ',
            ])
    ];

export const ESTRATEGIAS_DESARROLLO =
    [
        new Item(Keys.ESTRATEGIAS_DESARROLLO_DDD,
            [
                '- El lenguaje debe ser obicuo, que sea entendible por desarrolladores, como por los usuarios ',
                '- Se proponen <strong>4 capas</strong> principales para la arquitectura: ',
                '  - Interfaz de usuario            - Aplicación ',
                '  - Dominio                        - Infraestructura ',
                '',
                '- Tambien maneja otros conceptos como:',
                ' <strong>- Entidades:</strong>     Cualquier objeto de dominio que mantiene un estado y un comportamiento, más de la ejecución de la aplicación ',
                ' <strong>- Value Objects:</strong> Son objetos que no tienen identidad, pero si un comportamiento especifico',
                ' <strong>- Servicios:</strong>     Son acciones a las cuales les es dificil asgignarles un propietario, pero aun asi son concretas ',
                ' <strong>- Modulos:</strong>       Permite mantener una alta integridad y un bajo acoplamiento, al mismo tiempo que permite la agrupación y división ',
                ' <strong>- Agregados:</strong>     Estos grupos de entidades, relacionados entre si, a nivel de negocio ',
                ' <strong>- Factorias:</strong>     Se encargan de la creación de objetos y entidades que se han vuelto complejas, separandolo de la reglas de negocio ',
                ' <strong>- Repositorios:</strong>  Realizan la persistencia y la obtención de los datos, por lo que no estan limitados a solo el uso de una BD ',
                '',
                '- El desarrollo debe ser lo más abstracto posible para ser independiente de las implementaciones ',
                '- Las capas se vuelven parte diciente del codigo, indicando su utilidad con sus nombres ',
            ]),
        new Item(Keys.ESTRATEGIAS_DESARROLLO_BDD,
            [
                '- Es una evolución de TDD, que es más que solo testing ',
                '- Aca las pruebas se concentran en tener un lenguaje obicuo, por lo que todas las partes se pueden involucrar rapidamente ',
                '- Para implementarse las Historias de Usuario son fundamentales ',
                '- Comprender el esquema Given-When-Then ó otros formatos usados en las Historias de Usuario',
                '- Aunque se usen metodologias agiles la idea no solo es implementar "funcionalidades" el objetivo es darle valor al usuario final ',
                '',
                '<strong>Dado</strong> escenario y precondiciones <strong>Cuando</strong> acciones a ejecutar <strong>Entonces</strong> Resultado a validar',
                '<strong>Como</strong> un usuario especifico <strong>Deseo</strong> la necesidad que se tiene <strong>Para que</strong> caracteristicas para cumplir el objetivo ',
                '',
                '- Mejora la comunicación entre todas las partes, ya que todas se comunican más entre si ',
                '- Como se intenta disminuir el lenguaje tecnico, se llega a un público más amplio '
            ]),
        new Item(Keys.ESTRATEGIAS_DESARROLLO_TDD,
            [
                '- Primero se escriben las pruebas, y despues se crea el codigo para que estas funcionen ',
                '- Puede incrementar la carga de trabajo, pero se obtiene un codigo más robusto y mantenible ',
                '- Basicamente es un ciclo constante de creación de pruebas, refactorización y crecimiento ',
                '- El <strong>Que</strong> es más importante que el <strong>Como</strong> ',
                '- La productividad se puede ver mermada si no se conoce esta estrategia ',
                '- El incluir Bases de Datos o Interfaces graficas suele complicar el desarrollo ',
            ]),
        new Item('atdd',
            [
                '- Primero se escriben las pruebas, despues se crean los casos de aceptación Y de ultimas se crea el codigo para que estos funcionen ',
                '- Las pruebas se automatizan, por lo que a la larga el desarrollo se volvera más agil ',
                '- Definir las Historias de Usuario y sus casos de aceptación es fundamental para evitar perder tiempo ',
            ]),
        new Item(Keys.ESTRATEGIAS_DESARROLLO_BOTTOM_UP_AND_TOP_DOWN,
            [
                '- Son enfoques para el analisis y toma de decisiones, originarios en la informatica de los años 70',
                '',
                '<strong>Bottom-Up:</strong>(Ascendente) Nace de lo particular para concluir en lo general ',
                '- Los equipos estan presentes en todas los pasos del proceso de gestión ',
                '',
                '<strong>Top-Down:</strong>(Descendente) Nace de lo general hasta concluir en lo particular ',
                '- Las decisiones se toman en el nivel más alto y se transmiten a los demás de manera jerarquica ',
                '',
                '- Hoy en dia pocas organizaciones se rigen por un solo esquema, suelen tener hibridos adaptados segun el funcionamiento interno ',
                '- El enfoque Top-Down es más rigido y estructurado, mientras que el enfoque Bottom-Up es más flexible y colaborativo ',
            ]),
        new Item(Keys.ESTRATEGIAS_DESARROLLO_TLD_TDD,
            [
                '- Estas se dan una vez se ha terminado el codigo y las posibles refactorizaciones que este sufra ',
                '- Este tipo de estrategia se puede usar de 2 maneras distintas: ',
                '',
                '<strong>Funciones completas:</strong> Las pruebas cubriran todas las funciones y sus posibles escenarios, menor cantidad de bugs y mejor calidad ',
                '<strong>Proto funciones:</strong> Las pruebas cubren los escenarios minimos para que la función cumpla con sus requerimientos, mayor rapidez en la liberación ',
                '',
                '<strong>TLD vs TDD</strong>',
                '- Este enfoque es ideal si el tiempo de desarrollo es escaso ',
                '- Su curva de aprendizaje es menor en comparación con TDD ',
                '- El mantenimiento se reducen al usar TDD, pero la productividad aumenta con TLD (gastos y mano de obra) ',
                '- Hay un mayor numero de pruebas en TDD, sin embargo el codigo con TLD es más entendible ',
                '- Los cambios suelen tener menos impactos negativos con TDD, a cambio de más complejidad inherente al codigo ',
            ]),
        new Item('bduf',
            [
                '- Es una implementación de la metodologia en cascada, donde las etapas son consecuentes y largas ',
                '- Este enfoque puede ser usado para paginas web, aplicaciones o softwares complejos, donde es necesario ',
                ' - que todo el diseño este completo y haya sido perfeccionado por adelantado de cualquier implementación (programación)',
                '- Esto era costoso y demorado, hasta que llegaron los enfoques agiles para mejorar estas y otras falencias ',
                '',
                '- Esta estrategia funciona muy bien bajo ciertos suspuestos: ',
                ' - Se conocen los objetivos y requisitos por adelantadao, además de que es poco probable de que cambien ',
                ' - Las revisiones de diseños son dificiles y costosas, por lo que se refinan al inicio para que sufran minimos cambios ',
                ' - Una solución de diseño debe ser juzgada si es buenan o efectiva, antes de ser funcional ',
                ' - Se pueden identificar desafios de desarrollo antes de llegar al codigo ',
                ' - No se puede iniciar nada, sin diseñar ni planificar antes',
                '',
                '- Puntos fuertes: ',
                ' - Si se tiene un objetivo bien definido es una manera muy eficiente de alcanzarlo ',
                ' - Es más facil de hacer estimaciones certeras de tiempo y costos ',
                '',
                '- Debilidades: ',
                ' - No se adapta con facilidad a los cambios, por lo que es posible que se deban repetir etapas ',
                ' - No se tiene un producto terminado para probar hasta etapas tardias y finales del proceso ',
                '',
                '<strong>Diseños agiles y emergentes </strong>',
                '- Estas metodologias dividen los proyectos en etapas más pequeñas, las cuales iteran constantemente ',
                ' - esto con el fin de obtener un producto funcional, mucho más rapido ',
                '',
                '- Supuestos de los diseños emergentes: ',
                ' - No se puede saber la solución ideal desde el priciopio, por lo que se empieza a construir con lo que se conozca ',
                ' - El aprendizaje continuo es esencial para mejorar cada vez que sea posible ',
                ' - La documentación y el sobrediseño se evitan, ya que suelen ser desperdicio frente al cambio constante ',
                '',
                '- Puntos fuertes: ',
                ' - El diseño evoluciona y se aprovechan los nuevos aprendizajes ',
                ' - Es una metodologia colaborativa y no un proceso solitario ',
                ' - Diseño y desarrollo suelen ser paralelos, permitiendo resolver problemas antes de que sean incendios ',
                ' - Se hacen implementaciones en base a datos con poca incertidumbre ',
                '',
                '- Debilidades: ',
                ' - Se centra en la fabricación de funciones, tanto que aveces no dan valor alguno ',
                ' - Los diseños suelen ser cambiantes por lo que es dificil terminar con un diseño fijo ',
                ' - Los ciclos son volatiles por lo que pueden quedar tareas pendientes, que no son prioridad para siguientes ciclos ',
                '',
                '<strong>Just Enough Design Up Front (JEDUF) </strong>',
                '- Es un punto medio, que reconoce que se requiere el mejor diseño posible para empezar, al mismo tiempo ',
                ' - que es vital responder frente al cambio y darle valor al usuario ',
                '',
                '- Aun asi BDUF y Agile son 2 extremos de un solo espectro, donde es importante saber adaptar las estrategias a nuestra necesidades ',
                ' - para evitarnos vernos truncados al seguirlas a raja tabla, con caracteristicas que nos son completamente inutiles ',
                '- Tanto BDUF como Agile pueden implementar aspectos positivos del otro si dejar de ser lo que son ',
            ]),
        new Item(Keys.ESTRATEGIAS_DESARROLLO_SCREAMING_DESIGN,
            [
                '- DDD trata basicamente de delimitar lineas, y crear contextos acotados, donde cada componente tenga su propia responsabilidad y se pueda ',
                ' - seguir comunicando con otros, para descubrir estos limites, el <strong>Tio Bob</strong> ha dicho <em>Trazar líneas entre las cosas que importan y las que no</em>',
                '',
                '- El objetivo de esta arquitectura debe ser discutir el dominio detras del sistema, en lugar de los detalles especificos o sus implementaciones ',
                '- Si al mirar la estructura de carpetas, se pueden identificar funcionalidades y no las tecnologias que se usan',
                '- Las arquitecturas de software deben respaldar inherentemente los casos de uso, y expresar claramente sus propositos, ',
                ' - de manera similar como los planos de un edificio o de una casa, expresan claramente los propositos de cada espacio ',
                '',
                '<strong>Puntos claves</strong>',
                '- Las arquitecturas deben girar en torno a los casos de uso, y respaldar al sistema',
                '- Los marcos de trabajo, no deben ser el foco principal de una arquitectura, estos deben ser herramientas utilizadas dentro de la arquitectura ',
                '- Los marcos se deben adaptar de acuerdo a los casos de uso, no se debe permitir que las herramientas den forma a los componentes a su alrededor ',
                '- Una buena arquitectura, da lugar para que decisiones tecnicas se puedan posponer y cedan el foco a los casos de uso',
                '- Tambien permite flexibilidad en cuanto al cambio de tecnologias, herramientas, y marcos de trabajo ',
                '- Realizar pruebas, sin necesidad de depender de marcos, BD o otras complejidades, o en su defecto depender lo menos posible ',
            ]),
        new Item(Keys.ESTRATEGIAS_DESARROLLO_SLDC,
            [
                '- El ciclo de vida del desarrollo de software difiere de acuerdo a la necesidades de cada empresa, sin embargo existen etapas en comun ',
                '',
                '<strong>Analisis de requerimientos:</strong> Proceso de recopilación de las necesidades, especificaciones y expectativas ',
                '',
                '<strong>Diseño:</strong> Se analizan una gran cantidad de aspectos, ocupandose de la forma en que funcionara y se hara el software, aspectos como: ',
                '  - Arquitectura                     - Seguridad',
                '  - Stack de tecnologias             - Plataforma de despliegue ',
                '  - Interfaz de usuario              - Prototipos ',
                '- Ninguna decisión es inamovible, pero entre más tarde se cambie, mayor sera el costo para el proyecto',
                '',
                '<strong>Desarrollo:</strong> Una vez se tenga concenso sobre la mayoria de temas, se puede empezar a codificar, que tomara la gran parte de tiempo y recursos ',
                '- No importa que modelo de gestión se use, pueden ser metodologias agiles o tradicionales, el resultado sera siempre un codigo funcional ',
                '',
                '<strong>Pruebas:</strong> Las areas encargadas de control de calidad realizaran las pruebas pertinentes para detectar errores, fallas o incumplimientos ',
                '  - Testing Unitario                 - Testing de Integración',
                '  - Testing de Seguridad             - Pruebas de carga & Estres',
                '  - Calidad de codigo                - Pruebas de Aceptación ',
                '- Si en esta o en etapas previas no se encuentran defectos, sera mucho más costoso y complicado corregirlos más adelante',
                '',
                '<strong>Implementación:</strong> Tambien conocida como despliegue, y deberia estar altamente automatizada, además de contar con la capacidad de reversión ',
                '',
                '<strong>Documentación:</strong> La documentación proporciona un esquema del sistema y ayuda a los interesados a comprender mejor el proyecto ',
                '  - Requisitos                       - Arquitectura',
                '  - Codigo fuente                    - Plan de pruebas',
                '',
                '<strong>Mantenimiento:</strong> Con el proyecto estable y debidamente documentado, esta fase considera el exito a largo plazo ',
                '',
                'Bien definido ayuda a gestionar los recursos y tener canales de comunicación fluidos, siempre deberia estar claro para todos los involucrados '
            ]),
        new Item(Keys.ESTRATEGIAS_DESARROLLO_BFF,
            [
                '- A medida que las aplicaciones se vuelven cada vez más distribuidas han surgido patrones para satifacer a la multitud de dispositivos conectados ',
                '- Esta arquitectura proporciona un backend dedicado para cada interfaz de frontened, en lugar de depender de un API monolitica o un <em>API Gateway</em> ',
                '- Cada backend es independiente y se encarga de: ',
                ' - Consolidar u orquestar las llamadas a los multiples servicios involucrados ',
                ' - Prepara los datos en un formato util para cada cliente ',
                ' - Maneja la logica especificada por cada frontened ',
                '',
                '<strong>Beneficios</strong>',
                '- Experiencias personalizadas, cada interfaz sin importar que tipo sea, obtiene los datos que necesita sin desorden adicional ',
                '- Complejidad reducida, al tener un solo componente encargado de todas las peticiones de obtención de datos ',
                '- Rendimiento mejorado, al reducir los llamados a API innecesarios, además de posibilitar guardar datos en cache ',
                '- Seguridad, al controlar las interacciones con los servicios, pueden exponer mecanismos de seguridad y limites de peticiones ',
                '',
                '<strong>¿ Cuando usarse ?</strong>',
                '- Aplicaciones multiplataforma, asi cada dispositivo tiene tiene una experiencia personalizada ',
                '- Orquestación por microservicios, Se consultan todos los microservicios necesarios y se unen los datos de forma coherente ',
                '- Optimización de APIs, al usar microservicios o API heredadas se ayuda a ocultar las complejidades de la arquitectura subyacente ',
                '',
                '<strong>Desafios</strong>',
                '- Mayores cantidades de recursos deben ser destinadas a su mantenimiento ',
                '- Problemas de coherencia, si las transformaciones o el diseño es incorrecto, los datos entre clientes van a variar ',
                '- Cuellos de botella, si estas capas no estan optimizadas para manejar numerosas solicitudes o realizan calculos pesados ',
                '',
                '<strong>Buenas practicas</strong>',
                '- Limitar la logica empresarial presente, solamente se deberia de encargar la orquestación y union de los datos ',
                '- Usar almacenamiento en cache, especialmente en consultas que requieren de poca latencia y sufren pocos cambios ',
                '- Manejo de errores, centralize el manejo de errores para evitar problemas que afecten al cliente ',
                '- Seguridad, la autenticación y autorización como el uso de limites ayudan a proteger los servicios frente a posibles ataques ',
            ]),
        new Item(Keys.ESTRATEGIAS_DESARROLLO_DDD_MADURITY,
            [
                '- Este esquema se inspiro en el modelo de madurez de una API REST o modelo Richardson y como se aplica con <strong>DDD</strong>',
                '- Igual que en una piramide, los niveles iniciales son los fundamentos, sobre la cual se pueden construir elementos arquitectonicos más complejos ',
                '',
                '<strong>Nivel 0 - SOLID:</strong> Es aquel codigo que puede o no tener alguna arquitectura, tambien es aquel que esta bien escrito y con buenas practicas ',
                '- Codigo sintacticamente correcto y con una guia de estilo clara ',
                '- <em>Calistenia de objetos</em> como guia aporta a la mantenibilidad y claridad del codigo ',
                '- Fundamentos de <strong>POO</strong> como composición, Herencia, Polimorfismo, Ley de Demeter, Interfaces, etc...',
                '- Principios <strong>SOLID</strong> además de patrones segun sea el caso ',
                '',
                '<strong>Nivel 1 - Arquitectura Hexagonal:</strong> Es el elemento más basico de DDD, donde existe una clara separación entre la infraestructura y la aplicación ',
                '- Separación clara entre la logica de la aplicación(Negocio) y su uso con la infraestructura(Implementación) ',
                '- Reglas de dependencias, La infraestructura ó capas más externas dependen del Nucleo, y el Nucleo se encuentra aislado de la infraestructura ',
                '- Uso claro y definido de los puertos y adaptadores ',
                '- Tests que ayudan a mantener la arquitectura y/o prueben la integración entre componentes, además de los tests unitarios ',
                '',
                '<strong>Nivel 2 - Arquitectura Limpia:</strong> Aunque se suelen usar de manera intercambiable, existen mas arquitecturas limpias que solo la hexagonal ',
                '- Los casos de uso son el mayor diferenciador de este nivel de madurez y suelen estar alrededor del Nucleo/Entidades de dominio ',
                '- Cada caso de uso implementa un escenario de negocio distinto, distinguible mediante la estructura de los paquetes y el lenguaje ubicuo ',
                '- Existe un flujo de control identificable, donde cada actor y paso estan definidos, además de los efectos esperados y las condiciones previas ',
                '- Este nivel implica pensar en la complejidad de la solución, de manera que los casos de uso sean lo más independientes posible ',
                '- Tambien el manejo de errores se debe tener en cuenta, ya que siempre existira el camino existoso, los caminos erroneos y los excepcionales ',
                '',
                '<strong>Nivel 3 - DDD:</strong> Con el Nucleo y la infraestructura debidamente organizados',
                '- El lenguaje Ubicuo es natural y esta presente en todas las capas y partes de la aplicación ',
                '- Todas las reglas empresariales estan encapsuladas en el modelo o en los casos de uso ',
                '- Separación clara de responsabilidades entre los casos de uso y las entidades de dominio ',
                '- Se crean componentes adicionales de DDD como Value Objects y Agregados, con el fin de obtener un modelo más "profundo" ',
            ])
    ];

export const MALAS_PRACTICAS =
    [
        new Item('callbackhell',
            [
                '- Generalmente es un problema al hacer codigo con caracteristicas asincronas (generalmente javascript) ',
                '- El orden en que se copia el codigo no necesariamente es en el que va a ser ejecutado',
                '- Cambiar el orden de las llamadas puede evitar el anidamiento innecesario',
                '- Usar promesas ó el Async/Await que hara que el codigo se comporte de manera más sincronica ',
            ]),
        new Item('contraCalidad',
            [
                '- Desconocimiento del negocio, clases mal diseñadas o condiciones sin sentido',
                '- Mala o nula formulación de requerimientos y requisitos ',
                '- Desconocimiento de las tecnologias que se usen, la experiencia de un desarrollador toma tiempo para conseguirse ',
                '- Malas estimaciones de los tiempos, obligando a mucho trabajo extra',
                '- No aplicar patrones y/o arquitecturas',
            ]),
        new Item('contraGestion',
            [
                '- Asignación erronea del personal en roles inadecuados o sin la experiencia necesaria ',
                '- Asumir información sin tener una confirmación previa',
                '- Empezar a planear sin tener todas las variables a tener en cuenta',
                '- No se debe abusar de la capacidad de multitarea del equipo',
                '- La falta de comunicación en el equipo puede conllevar al desastre',
                '- No poner limites es tan malo como ser inflexible, siempre hay un punto medio',
                '- Entregar productos incompletos, lo ideal seria pedir más tiempo o recursos',
                '- Asignación erronea del personal en roles inadecuados o sin la experiencia necesaria ',
                '- Exceso de control, cerrando el paso a nuevas iniciativas y causando descontento en el equipo'
            ]),
        new Item('contraAgilidad',
            [
                '- Usar practicas tecnicas o metodos sin los comportamientos de una cultura agil ',
                ' - no es realmente agilidad es solo algo cosmetico que enmascara otro modelo de desarrollo ',
                '',
                '<strong>Temor de compromiso:</strong> Los procesos de cambio son complejos, ',
                ' ya que estos retan las viejas costumbres, y funcionaron en los viejos tiempos, ',
                ' por eso se toman mejores practicas que no requieran poca adaptación ',
                '',
                '<strong>Falta de disciplina:</strong> La busqueda de la perfección es un camino sin fin, ',
                ' por eso es necesario experimentar y mantener constancia con las practicas que se realizen, ',
                '',
                '<strong>Persona con multiples roles:</strong> Cada rol tiene sus deberes y responsabilidades, ',
                ' romper estas barreras puede conllevar problemas en el personal y su productividad ',
                '',
                '<strong>Grupos de individuos:</strong> En un equipo cada integrante tiene sus actividades y responsabilidades ',
                ' definidas, que al final se suman para armar un todo, que puede resultar en un Frankenstein ',
                ' ,en un grupo todos los integrantes deben poder participar y llenar vacios de ser necesarios, ',
                ' de manera que no hayan silos de especialidades ',
                '',
                '<strong>Falta de auto organización:</strong> Los equipos agiles buscan ser autogestionados, ',
                ' por medio de una inteligencia colectiva, la colaboracion de los miembros y la experiencia compartida, ',
                ' sin necesidad de tener un gestor que este controlando las dinamicas del grupo',
                '',
                '<strong>Falta de formación:</strong> Tambien existe la posibilidad de que los antipatrones se den ',
                ' por simple desconocimiento, por lo que manejar espacios de capacitación siempre va a ser necesario ',
            ]),
        new Item('malasPracticasSCRUM',
            [
                '- SCRUM es una metodologia agil, que te da guias, pero no reglas, por lo que esta subjetividad puede llegar a crear problemas, ',
                ' - a la hora de que cada equipo interprete e implemente los ajustes al marco de trabajo base ',
                '',
                '<strong>Usarlo no significa ser agil</strong>, sin conocer el manifiesto agil o sus 12 principios, solo se estaria usando el <strong>como</strong> sin saber el <strong>porque</strong>',
                '',
                '<strong>En la planeación, el PO dice como hacer el trabajo al desarrollador</strong>',
                ' - Esto atento en contra de la autonomia el compromiso y la autoorganización que los desarrolladores tienen',
                '',
                '<strong>Usar el <em>Daily</em> como reunión de seguimiento</strong>',
                ' - Esta debe ser para la comunicación entre desarrolladores, el seguimiento debe ser una consecuencia del avance ',
                '',
                '<strong>Eventos incompletos</strong>',
                ' - Si un evento se realiza sin todos los roles que deben estar involucrados, es posible que otros eventos se entremezclen, ',
                '  - debido a la falta de información de los roles que se han ausentado ',
                '',
                '<strong>Eventos que perdieron el sentido </strong> ',
                ' - Cuando se pierde el sentido de eventos como las <em>Reviews</em> se conviertes en simples reuniones que solo consumen tiempo ',
                '',
                '<strong>Combinaciones de roles </strong> ',
                ' - Una persona no deberia fungir 2 posiciones, ya que además de tener más responsabilidades, desdibuja los roles y sus funciones ',
                '',
                '<strong>Sprints convertidos en Cronogramas</strong>',
                ' - La agilidad implica usar y medir el tiempo diferente, por lo que no se deben usar cronogramas apretados disfrazados de sprints',
                '',
                '<strong>SCRUM permite terminar antes</strong>',
                ' - Una falsa creencia, SCRUM permite fallar y evaluar de manera mas rapida, no terminar antes pero si corregir más rapido ',
                '',
                '<strong>Ampliar los Sprints</strong>, evita que se tenga constancia y puede arruinar las estadisticas del equipo ademas de futuras estimaciones ',
                '',
                '<strong>Dividir o priorizar mal las Historias de Usuario</strong>',
                ' - Esto puede desencadenar en una cascada agil, donde no se ven incrementos pequeños ni funcionales, solo partes terminadas e inconexas ',
            ]),
        new Item(Keys.MALAS_PRACTICAS_DEATH_BY_MICROSERVICES,
            [
                '- La complejidad excesiva no es sinonimo de buenos sistemas, y tener un sistema complejo, adaptado para crecer, pero que simplemente nunca crecera ',
                ' - es un desperdicio de tiempo y dinero, solo por estar al lado de las grandes compañias tecnologicas y sus practicas ',
                '',
                '- Los sistemas distribuidos eran uno de los ultimos recursos a usar, ya que son complejos y resuelven problemas igual de complejos ',
                '- Un monolito no es malo, mantienen una base solida y evitan una constelación de microservicios más paquidermica que un monolito bien mantenido ',
                '',
                '- Tambien esta la cuestión de si es necesario crecer mediante microservicios, la escalabilidad y el rendimiento son realmente un problema ? ',
                ' - esta interrogante es dificil de responder pero lo más seguro es guiarse de los principios, como <strong>KISS</strong>, entre otros, ',
                ' - si no es un problema, no necesita ser resuelto y menos aun desperdiciar recursos en un tal vez',
                '',
                '- La teoria dicta que equipos pequeños, pueden manejar microservicios pequeños, sin grandes problemas de versiones o compatibilidad ',
                '- Un monolito no sera una panacea, pero no agrega más problemas de los que ya existen, cosa que los microservicios pueden hacer con solo existir ',
                '',
                '- Un gran perdida y que poco se menciona con el uso de microservicios, es que se deja de aplicar <strong>DRY</strong>, ya que es preferible copiar y pegar, ',
                ' - lo que se necesite, y en caso de que sea aplique y se extraiga en una libreria en comun, esta introduce nuevos aspectos a tener en cuenta, ',
                ' - como el manejo de las versiones, manejo de los repositorios de codigo, hasta problemas de contexto y de alcance ',
                '',
                '- Tampoco se pueden ignorar las pruebas de integración, las unitarias puede que sigan funcionando con normalidad, pero la división y distribución ',
                ' - de los componentes, hace que probarlos sea un autentico calvario, por lo que para solventar este problema, se dice que un microservicio debe ',
                ' - ser <em>observable</em>, una manera más elegante de depurar, esto no cambia que es una forma reactiva para encontrar errores, en vez de proactiva ',
            ]),
        new Item(Keys.MALAS_PRACTICAS_ANTI_PATRONES_ARQUITECTURAS,
            [
                '- Por mejor pensada que este alguna arquitectura, siempre tendra algun defecto o problema conocido, no hay ninguna que sea perfecta ',
                '- Esto tambien depende del manejo, correctamente solo seran problemas de poco peso, ó de lo contrario seran problemas sistemicos ',
                '',
                '<strong>Multiinquilino</strong>',
                '<strong>- Fiesta de fantasmas:</strong> No separar adecuadamente los datos de inquilinos puede provocar fugas entre estos y violar leyes de protección de datos ',
                '<strong>- Mantenimiento Frankestein:</strong> Las personalizaciones puede hacer que el codigo base sea confuso y dificil de mantener, más si esta mal modularizado ',
                '',
                '<strong>Backend For Frontened(BFF)</strong>',
                '<strong>- The poltergeist payload:</strong> Sin optimizaciónes adecuadas, la recuperación de datos puede ser excesiva o insuficiente ',
                '<strong>- Duplicacion Is Evil:</strong> La logica de negocio se puede llegar a ver duplicada, en multiples fronts, y multiples servicios ',
                '',
                '<strong>Outbox pattern</strong>',
                '<strong>- Lost in phantom zone:</strong> Si la publicación de eventos falla, es posible que los mensajes se atasquen en la bandeja de salida ',
                '<strong>- Zombie messages:</strong> Sin mecanismos de deduplicación adecuados, los consumidores pueden procesar el mismo mensaje, multiples veces ',
                '',
                '<strong>CQRS</strong>',
                '<strong>- Eventual Terror:</strong> La consistencia eventual puede sorprender a los desarrolladores que no estan acostumbrados y conllevar a estados impredecibles ',
                '<strong>- The Two-Faced monster:</strong> Tener modelos separados para lectura y escritura, aumenta la complejidad y necesita mecanismos de sincronización ',
                '',
                '<strong>API Gateway</strong>',
                '<strong>- Bottleneck:</strong> Si no se escala u optimiza adecuadamente, la entrada del sistema se convertira en un cuello de botella ',
                '<strong>- The Hexed Transformation:</strong> Una dependencia excesiva de esta entrada para realizar transformaciones, puede conllevar a problemas monoliticos ',
                '',
                '<strong>Circuit Breaker</strong>',
                '<strong>- Premature Haunting:</strong> Umbrales mal configurados pueden hacer que el circuito se abre con mucha frecuencia, aun cuando el servicio esta funcionando ',
                '<strong>- Ghouls Delay:</strong> Si el intervalo de reinicio no se optimiza, puede provocar interrupciones prolongadas ',
                '<strong>- Eternal Nights Lock:</strong> En sistemas mal configurados, los circuitos pueden quedarse abiertos indefinidamente, ',
                ' - ya sea por fallas en el reinicio, o fallas continuas cuando intenta cerrarse, permaneciendo en un estado de falla permanente ',
            ]),
        new Item(Keys.MALAS_PRACTICAS_ANEMIC_DOMAIN,
            [
                '- Se refiere a un modelo de dominio que carece de detalles y profundidad, en el contexto de <em>DDD</em>',
                '- Este modelo no proporciona una comprensión suficiente del dominio, ni de los problemas que se pretenden resolver ',
                '- Esto hace dificil aplicar tecnicas propias de <strong>DDD</strong> como analisis de contexto, o la identificación de entidades ',
                '- Tambien limita la capacidad del modelo, para abordar temas complejos o tomar decisiones bien informadas',
                '- Un sintoma inequivoco es que aparenta ser real, tienen nombres de sustantivos asociados al dominio y con las relaciones indicadas',
                '- El problema surge cuando se observan sus comportamientos, de los cuales carecen o son bastante pobres ',
                '- En cambio La logica y la manipulación de los objetos, suele estar en los servicios, o capas superiores al dominio',
                '- El principal problema de este enfoque es que encurre en los costos de <em>DDD</em> sin aprovechar sus beneficios',
                '- Este antipatron suele ser comun, ya que hay tecnologias y frameworks que fomentan este enfoque',
            ]),
        new Item(Keys.MALAS_PRACTICAS_TRAIN_WECKS,
            [
                '- En la vida real un choque de trenes son acontecimientos nefastos, donde suelen resultar gente herida',
                '- Sin embargo no es raro que suceda en el desarrollo de software, cuando un metodo llama a otro y a otro, creando una cadena demasiado larga',
                '- <strong>Ejemplo:</strong><em> university().getFaculty().getDean().getName() </em>',
                '- Cosas como estas existen debido a problemas de fondo como una mala modularización ó una división ineficaz de responsabilidades ',
                '- Esto atenta contra los principios de POO ya que existe un acoplamiento indebido ó una envidia de caracteristicas, dependiendo del caso ',
                '- Tambien esta en contra de la <em>Ley de demeter</em> que consiste en no hablar con extraños, ni inmiscuirnos en sus responsabilidades',
                '- No es una excepción, pero tampoco esta mal visto, que este mismo encadenamiento de metodos se de, en flujos y/o operaciones con datos'
            ]),
    ];