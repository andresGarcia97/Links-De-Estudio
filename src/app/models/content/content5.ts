import * as Keys from '../keys';
import { Item } from "../models";

export class Content5 {

    public temas: Item[] = [
        ...NUBE,
        ...APIS,
        ...META_ESTRUCTURAS,
        ...MICRO_SERVICES
    ];

}

export const NUBE =
    [
        new Item('nube',
            [
                '<strong>- Nube Publica:</strong> Los recursos son del proveedor y estos son compartidos con otros usuarios, sin necesidad alguna de mantenimiento ',
                '<strong>- Nube Privada:</strong> Los recursos son propios y no estan compartidos con terceros, un entorno más escalable y con un gran control ',
                '<strong>- Nube Hibrida:</strong> Los recursos son propios pero el espacio puede ser compartido con otros usuarios, marcando fronteras claras para su acceso ',
            ]),
        new Item(Keys.NUBE_IAAS_PAAS_SAAS,
            [
                '- Estos 3 modelos de servicios actualmente ayudan a las empresas a ahorrar costos, en software y hardware, además de multiples ventajas ',
                '',
                '<strong>IaaS - Infraestructura como servicio:</strong> Aca todo la infraestructura necesaria se contrata con un tercero, a cambio de una cuota o un alquiler, ',
                ' - esto es muy conveniente ya que se compra lo que se necesita; algunos de los más conocidos son Amazon Web Services Y Microsoft Azure ',
                '',
                '<strong>PasS - Plataforma como servicio:</strong> En este caso solo se provee la infraestructura, y el cliente solo se preocupa de su aplicación, ',
                ' - delegando la administración a un tercero, algunos de los más conocidos son Google App Engine Y Bungee Connect ',
                '',
                '<strong>SaaS - Software como Servicio:</strong> se aloja el software y la infraestructura, el usuario solo se preocupa por usarlo y sus necesidades ',
                ' - algunos de los más conocidos son Microsoft Office 365 y WordPress ',
            ]),
        new Item('caas-daas-faas',
            [
                '- En la actualidad la computación en la nube, ha revolucionado la forma en que operan las empresas, ofreciendo soluciones escalables y flexibles ',
                '- De manera rentable, abarcando multiples necesidades, convirtiendose en componentes que impulsan la innovación y la eficiencia en la nube ',
                '',
                '<strong>CaaS - Contenedores como Servicio:</strong> Los contenedores permiten empaquetar aplicaciones de forma estandarizada y de manera liviana, ',
                ' - por lo que tambien existen plataformas para escalarlos y administrarlos de manera facil ',
                '',
                '<strong>FaaS - Función como Servicio:</strong> Ejecute fragmentos de codigo sin administrar servidores ni contenedores, en este modelo se pueden escribir ',
                ' - e implementar funciones pequeñas con un solo proposito, sin preocuparse por temas como infraestructura o despliegues complicados ',
                '',
                '<strong>DaaS - Escritorio como Servicio:</strong> Proporciona a los usuarios, una infraestructura de escritorio virtual, alojada en la nube, ',
                ' - y es accesible desde cualquier lugar y cualquier dispositivo con conexión a internet ',
            ]),
        new Item('factores12',
            [
                '<strong>Codigo base:</strong> Todo el codigo debe ser controlado mediante un sistema de versiones, ',
                ' - y este no deber ser compartido entre proyectos, de ser el caso esta seria una libreria en comun ',
                '',
                '<strong>Dependencias:</strong> Todas las dependencias a usar siempre deben estar declaradas y aisladas del entorno de ejecución ',
                ' - la aplicación no puede depender de que estas esten instaladas en el host, ya el modo de su gestión es de libre albedrio ',
                '',
                '<strong>Configuraciones:</strong> Si existen diferentes despliegues y entornos de ejecución, estos deben tener sus propias configuraciones ',
                ' - esto se puede lograr mediantes variables de entorno y el manejo de distintos archivos de configuración ',
                '',
                '<strong>Backing services:</strong> Todo sistema que consuma la aplicación (bases de datos, mensajeria, colas, cache, etc.. ), ',
                ' - deberia poder conectarse y cambiarse por medio de simples configuraciones, sin modificar el codigo base ',
                '',
                '<strong>Separacion de etapas:</strong> Cada etapa deberia ser manejada de manera diferente, ya que en esencia lo son ',
                '<strong> - Construccion:</strong> Convierte el codigo base en un ejecutable listo para funcionar ',
                '<strong> - Distribución:</strong> Se toma la construcción previa y se crea una o n instancias de acuerdo a una configuración ',
                '<strong> - Ejecución   :</strong> Es la aplicación ya funcional en el entorno previamente preparado ',
                '',
                '<strong>Procesos:</strong> Para que la aplicación se ejecute de manera adecuada, esta no deberia contemplar guardar estados ',
                ' - esto significa que todos los procesos deben ser individuales e independientes entre si ',
                '',
                '<strong>Puertos:</strong> Estas aplicaciones son autocontenidas y se comunican mediante puertos HTTP ',
                '',
                '<strong>Concurrencia:</strong> Toda aplicación deberia ser su propia encargada de autogestionarse su crecimiento, ',
                ' - de acuerdo a la demanda y a la disponibilidad de recursos, ya sean hilos, procesos, uso de memoria, asincronia, etc.. ',
                '',
                '<strong>Desechabilidad:</strong> Todos los procesos de las aplicaciones deberian ser desechable, y tener un tiempo de arranque minimo, ',
                ' - esto con el proposito de iniciar cuando sean requeridos, realizar su función, y devolver los recursos consumidos al finalizar ',
                '',
                '<strong>Igualdad de ambientes:</strong> Desarrollo y producción deben ser lo más parecidos posibles ',
                ' - tener diferencias entre estos ambientes puede traer errores inesperados, al intercambiar entre tecnologias o herramientas ',
                '',
                '<strong>Historiales:</strong> Además de ser utiles a la hora de depurar, estos permiten tener mediciones y metricas de la aplicación ',
                ' - se pueden observar en tiempo real, o guardarse en ficheros que seran consultados despues ',
                '',
                '<strong>Administración de procesos:</strong> Estas tareas deberian tener los mismos comandos y secuencias de realización, ',
                ' - independientemente del ambiente o sus configuraciones',
            ]),
        new Item(Keys.NUBE_MIGRATIONS,
            [
                '- Toda migración hacia la nube, generalmente recoge 6 alternativas ',
                '<strong>Realojar:</strong> Consiste en mover la aplicacion tal y como existia originalmente, una medida apresurada que no siempre funciona ',
                '<strong>Replataformar:</strong> Consiste en modificar la estructura subyacente, sin modificar la arquitectura central de aplicación ',
                '<strong>Readquirir:</strong> Consta de una migración de una nube o servicio a otro, de acuerdo a las necesidades del negocio ',
                '<strong>Refactorizar/Rediseñar:</strong> No solo es un movimiento de ambiente, tambien son mejoras de escalabilidad ó rendimiento ',
                '<strong>Retirar:</strong> A veces hay recursos que estan obsoletos o ya no se necesitan, por lo que se eliminan ó se desactivan ',
                '<strong>Retener:</strong> Son ocasiones donde es necesario soportar tecnologias legacy que no son compatibles con la nube',
            ]),
        new Item(Keys.NUBE_CAP_TEOREMA,
            [
                '- Este teorema sostiene que no es posible que un sistema distribuido cumpla o garantice más de 2/3 de las siguientes propiedades ',
                '',
                '<strong>- Consistency  (Coherencia):</strong> Todos los clientes ven los mismos datos de manera simultanea ',
                '<strong>- Availability (disponibilidad):</strong> Todos los clientes disponen de acceso de lectura y escritura en cualquier momento ',
                '<strong>- Partitions (tolerancia a la particion):</strong> El sistema sigue funcionando como un todo, despues de que las partes fallen o se incomuniquen ',
                '',
                '<strong>- Sistema CP:</strong> Coherencia y tolerancia a la particion (sistemas de DNS)',
                '<strong>- Sistena AP:</strong> Disponibilidad y tolerancia a la partición (BD relacionales) ',
                '<strong>- Sistema CA:</strong> Coherencia y disponibilidad (aplicaciones financieras)',
            ]),
        new Item('dns',
            [
                '- Es la manera como accedemos a una pagina web por medio de nombres(dominios) y no de direcciones IP ',
                '- Este proceso de traducción de direcciones es realizado por estos servidores que estan esparcidos por el mundo ',
                '- Al estar esparcidos por el mundo esto permite una administración descentralizada, pero sigue estando interconectada ',
                '- Aunque este metodo es normal hoy en dia, tambien se puede acceder a los sitios directamente por medio de una IP obteniendo el dominio del sitio ',
                '- Si un servidor no encuentra la información solicitada, este la restransmite a otros en la red hasta dar con un resultado ',
            ]),
        new Item(Keys.NUBE_FALACIES_DYSTRIBUTED_SYSTEMS,
            [
                '- Que un sistema sea Distribuido no solo tiene beneficios, tambien enfrenta nuevos problemas, que son iherentes a los microservicios y a su separación ',
                '- Suelen haber falacias a nivel generalizado, que no siempre se contemplan a la hora de solucionar problemas, pero que siempre estan presentes ',
                '',
                '<strong>La red es confiable:</strong> Para construir un programa confiable, se debe aceptar el hecho de que toda comunicación puede fallar, ',
                ' - y se debe tener una politica para recuperarse, como realizar reintentos o el patron <em>store and forward</em> para poder recuperarse ',
                '',
                '<strong>Sin Latencia:</strong> Directamente relacionada a las distancias fisicas, siempre esta presente en toda comunicación y nunca es <strong>0</strong>',
                '',
                '<strong>Ancho de banda infinito:</strong> Cada viaje es costoso, no solo por la latencia, sino lo que se ha de enviar o recibir, ',
                ' - el tamaño de esta comunicación puede crecer hasta el punto que sature la red y provoque caidas en el sistema ',
                '',
                '<strong>La red es Segura:</strong> Asumir esto como confiar en las personas, puede ser un error critico, por lo que un buen analisis, ',
                ' - correción de errores y un diseño pensado para ser seguro no deberian faltar ',
                '',
                '<strong>La topologia no cambia:</strong> La estructura de la red, no siempre sera la misma, ¿ nuestro sistema esta preparado, ',
                ' - si un sistema critico dejara de funcionar ?, tecnologias como Docker y Kubernetes casi nos hacen olvidar que esto no es fiable al 100%',
                '',
                '<strong>Administración:</strong> No todo se puede controlar todo el tiempo, eventualmente el sistema crecera y evolucionara, ',
                ' - por lo que la dependencia con otros sistemas seran inevitables, por lo que el monitoreo y la observabilidad deben estar al orden del dia ',
                '',
                '<strong>El costo del Transporte:</strong> Enviar datos entre sistemas es un costo omnipresente, pero esto no significa que no se pueda ',
                ' - optimizar o migrar a protocolos de comunicación más ligeros ',
                '',
                '<strong>La red es Homogenea:</strong> La interoperabilidad es algo fundamental en la actualidad, pero no todo es tan ordenado y funcional, ',
                ' - y como no todos los sistemas son iguales, se deben crear soluciones genericas que puedan ser adaptadas para nuevos sistemas ',
                '',
                '- No existe ninguna formula magica para solucionar estos problemas, lo maximo a lo que se llegara seran soluciones que solventen las consecuencias ',
            ]),
        new Item(Keys.NUBE_LOAD_BALANCING,
            [
                '- Es un metodo para distribuir el trafico de red de manera equitativa, en un conjunto de recursos que admite una aplicación ',
                '- Las aplicaciones modernas deben procesar millones de peticiones de miles de usuario, de manera simultanea rapida y fiable ',
                '',
                '<strong>Beneficios:</strong>',
                '- Aumentan la tolerancia a fallos, al detectar automaticamente fallas en el servidor y redirigir este trafico a servidores disponibles ',
                '- Se pueden ejecutar mantenimientos y/o actualizaciones con un minimo o sin tiempo de inactividad de la aplicación ',
                '- Recuperación de desastres al apuntar a sitios con copias de seguridad ',
                '- Evitar cuellos de botella en alguno de los servidores ',
                '- Predecir el trafico para que el escalamiento de la aplicación sea más eficiente ',
                '- Monitoreo del trafico y bloqueo de contenido malicioso',
                '- Enrutamiento del trafico a traves de firewalls de red para una mayor seguridad ',
                '- Reducción de la latencia al poder redirigir a sitios cercanos geograficamente ',
                '',
                '<strong>Algoritmos:</strong> Conjunto de reglas para determinar el mejor servidor para cada una de las solicitudes y se dividen en 2 categorias ',
                '',
                '<strong>Carga estatica:</strong> siguen reglas fijas y no tienen en cuenta el estado de los servidores actual ',
                '<strong>&bull; Metodo turnorotativo:</strong> Cada servidor tiene una IP asignada en su grupo(granja) y los servidores se van rotando por turnos ',
                '<strong>&bull; Metodo de turno rotativo ponderado:</strong> Asigna diferentes pesos a cada servidor en función de su prioridad/capacidad, a mayor ponderación mayor carga ',
                '<strong>&bull; Metodo Hash de IP:</strong> Este lleva algun calculo matematico para convertir la IP del cliente en un <em>hash</em> con el que se le asigna algun servidor ',
                '',
                '<strong>Carga Dinamica:</strong> Examinan el estado actual de los servidores antes de distribuir el trafico ',
                '<strong>&bull; Metodo de Conexión minima:</strong>',
                '- Una conexión es un canal abierto entre un cliente y un servidor, estas conexiones se comprueban para saber cuales tienen la mayor cantidad activa,',
                ' - y enviar a los servidores con menos conexiones, este metodo supone que todas las conexiones requieren la misma potencia de procesamiento ',
                '<strong>&bull; Metodo de respuesta minimo:</strong>',
                '- Se toma el tiempo de respuesta total del servidor, lo cual se combina con la cantidad de conexiones activas, para determinar la mejor opción, ',
                ' - con el fin de garantizar un servicio más rapido para todos los usuarios',
                '<strong>&bull; Metodo basado en recursos:</strong>',
                '- Cada servidor cuenta con un software especializado llamado <em>agente</em> para calcular el uso de recursos y estimar los recursos libres, ',
                ' - asi se se comprueban si son suficientes para distribuir el trafico a ese servidor ',
                '',
                '- Tambien se pueden clasificar por tipo de tecnologia, ya sean si realizan la acción mediante <em>hardware</em> o <em>software</em>',
                '- Ademas de la clasificación por tipo de carga, donde se clasifican por <em>aplicación</em>, de <em>red</em>, de <em>servidor global</em> y <em>DNS</em>',
            ]),
        new Item(Keys.NUBE_LATENCY,
            [
                '- Los sistemas con una gran latencia y que estan orientados al uso de los usuarios, el tiempo perdido son ganancias perdidas',
                '- Algunas Estrategias para reducir la latencia: ',
                '',
                '<strong>Indices:</strong> Crear indices, optimizar y reducir las consultas a las BD',
                '',
                '<strong>Cache:</strong> Almacenar los datos que son frecuentemente consultados, disminuye tiempos a la apliaccion y reduce las consultas a las BD',
                '',
                '<strong>Load Balancer:</strong> La distribución apropiada de las cargas de trabajo, hara que los tiempos sean más uniformes',
                '',
                '<strong>CDN:</strong> Cachear el contenido estatico cerca de los usuarios que lo usen, reduciento distancias a nivel geografico',
                '',
                '<strong>Procesos Asyncronos:</strong> Ejecutar peticiones en segundo plano y no bloquear las peticiones cuando sean muy demoradas',
                '',
                '<strong>Comprensión:</strong> Comprimir la información antes de enviarse mediante la red',
            ]),
        new Item(Keys.NUBE_OBSERVABILIDAD,
            [
                '- Es la capacidad de comprender lo que esta pasando en un sistema complejo, en tiempo real si es posible, los principios fundamentales son: ',
                '',
                '<strong>Participación:</strong> Toda información que no este curada es inutil y solo consume recursos, esto no debe afectar la participación, ',
                ' - ya que cualquiera puede enviar datos para ser analizados, sin importar la diversidad de las fuentes',
                '',
                '<strong>Democratización:</strong> No solo aquellas personas que tengan conocimiento del sistema deberian saber que esta pasando, ',
                ' - toda la organización puede beneficiarse de la plataforma y obtener resultados utiles para diferentes areas de negocio ',
                '',
                '<strong>Eficiencia:</strong> Es la caracteristica más deseable, tanto que si la velocidad se degrada ya no tendria sentido su uso, ',
                ' - se debe minimizar el tiempo entre que suceda algun evento importante y su notificación, sin importar el reto del volumen de datos ',
                '',
                '- Esta observabilidad en el software se debe a 3 areas principales, y aunque se puedan solapar, tambien pueden existir de manera independiente',
                '',
                '<strong>Metricas:</strong> Son los atomos logicos e información medible, que permiten la generación de contadores, graficas y estadisticas, ',
                ' - ya sean en intervalos de tiempo ó incluso en tiempo real, pero carecen de detalles, para lo cual estan los <em>logs</em>',
                '',
                '<strong>Logging:</strong> Se encarga de eventos discretos que suelen ser enriquecidos con un contexto, que añade información valiosa',
                ' - al evento, permitiendo conocer que, cuando y porque ha ocurrido, debido al enorme volumen de datos y al ruido que esto puede generar, ',
                ' - se debe tener una politica clara de cuando y como usar los logs',
                '',
                '<strong>Tracing:</strong> Esta definición esta estrechamente relacionada con la definición de <em>request</em> que es considerada una transacción en nuestro sistema,',
                ' - que tiene un principio y fin (<em>lifecycle</em>), en los sistemas modernos es posible realizar este seguimiento ',
                ' - a todo lo largo de su proceso, inclusive si pasa a travez de diferentes sistemas, cada salto entre sistema es un <em>span</em>',
            ]),
        new Item(Keys.NUBE_TWO_PHASE_COMMIT,
            [
                '- En la computación distribuida, uno de los problemas más importantes es lograr un concenso entre multiples nodos, lo cual no es facil de lograr ',
                '- La confirmación de 2 fases, tambien conocida como <strong>2PC</strong> es un algoritmo para lograr la confirmación atomica de las transacciones ',
                '- Sin importar la cantidad de nodos que participen, ya que todos deben confirmar o negar al unisono, esto se logra mediante 2 fases',
                '',
                '<strong>- Fase de preparación:</strong> Preguntar a los nodos involucrados, si pueden confirmar la transacción propuesta ',
                '<strong>- Fase de confirmación:</strong> Ordenar a todos los nodos que confirmen o cancelen la transacción propuesta ',
                '',
                '- Si durante la preparación el nodo acepta la transacción propuesta debe confirmar la transacción si el nodo coordinador envia la solicitud ',
                '- Independientemente ante cualquier escenario de falla para respetar esta promesa, los datos se deben persistir para que puedan ser recuperados ',
                '- Un caso de uso comun es cuando se tiene el requisito estricto de tener una vista consistente de los datos en todo momento ',
                '',
                '- Un cuello de botella suele ser que debido a la necesidad de bloqueos, si un coordinador muere, todos los nodos deben esperar la decisión final ',
                '- Hasta que el coordinador se recupere, o la transacción sea abortada, se deben prohibir las operaciones sobre los datos involucrados ',
                '- En caso de fallo extremo y que el coordinador no pueda tomar una decisión, los nodos no estan en potestad para hacerlo tampoco, ',
                ' - lo que hace estrictamente necesario que se tome una decisión manualmente en cada nodo participante ',
            ]),
        new Item(Keys.NUBE_DISPONIBILITY,
            [
                '- La disponibilidad es la medida para determinar que un recurso es accesible para los usuarios, durante un periodo de tiempo determinado ',
                '- Las migraciones a la nube, ha obligado que los proveedores de servicios ofrezcan disponibilidades cada vez más altas ',
                '- Una alta disponibilidad no es sinonimo de completa disponibilidad, ningun servicio puede ofrecer el 100% ya que se deben tener en cuenta factores como: ',
                ' - Mantenimiento                                     - Desastres naturales',
                ' - Actualizaciones                                   - Casos fortuitos',
                '',
                '- Esto se deja explicito en los acuerdos a nivel de servicios <strong>SLA</strong> con una disponibilidad de 99.999% que es lo más parecido ',
                '- Este nivel de disponibilidad no es fortuito, requiere de inversiones y mantenimientos significativos, además de cambios organizacionales ',
                '',
                '<strong>Acciones y costos:</strong>                                   ---------------------------------------------------------',
                '- Una arquitectura madura que permita CD/CI          &brvbar;            <strong>Nivel</strong>              &brvbar;    <strong>%</strong>     &brvbar;   <strong>Tiempo</strong>   &brvbar;',
                '- Planes de recuperación y copias de seguridad       ---------------------------------------------------------',
                '- Sistemas distribuidos y manejo de redundancias     &brvbar; Servidor convencional         &brvbar; 99%      &brvbar; 87 H 40 m  &brvbar;',
                '- Automatización de tareas                           &brvbar; Servidor publico cloud        &brvbar; 99.9%    &brvbar;  8 H 46 m  &brvbar;',
                '- Supervisión y solución de problemas constante      &brvbar; Grupo de alta disponibilidad  &brvbar; 99.99%   &brvbar;  0 H 56 m  &brvbar;',
                '- Actualizaciones y mantenimientos periodicos        &brvbar; Disponibilidad continua       &brvbar; 99.999%  &brvbar;  5 m 16 s  &brvbar;',
            ]),
        new Item(Keys.NUBE_PACELC,
            [
                '- Los sistemas distribuidos tienen diversos puntos de fallos, como los servidores, la red, perdida de datos, etc.. ',
                '- Anteriormente el <strong>Teorema CAP</strong> establece que es imposible que un sistema distribuido proporcione simultaneamente: <strong>C</strong> Coherencia',
                '- Sin embargo, un sistema <strong>CA</strong> que no tolera Particiones, no es coherente                                           <strong>A</strong> Disponibilidad',
                '- Debido a esto, los <strong>DBMS</strong>, tuvieron que escoger entre Consistencia(<strong>ACID</strong>) y Disponibilidad(<strong>BASE</strong>)                   <strong>P</strong> Tolerancia a particiones ',
                '',
                '- Este teorema cubre aspectos faltante de CAP y establece que un sistema que replique datos: ',
                ' - Si hay una Partición(<strong>P</strong>) un sistema distribuido puede equilibrar entre Disponibilidad(<strong>A</strong>) y Consistencia(<strong>C</strong>) ',
                ' - Si no hay(<strong>E</strong>) Particiónes, el sistema se equilibrara entre Latencia(<strong>L</strong>) y Consistencia(<strong>C</strong>)',
            ]),
        new Item(Keys.NUBE_NATIVE,
            [
                '                  &brvbar; 1980-1990 &brvbar;    2000    &brvbar;     2010...    &brvbar;',
                '-------------------------------------------------------------',
                '&brvbar;   <strong>Proceso de</strong>    &brvbar;  Cascada  &brvbar;   Agiles   &brvbar;     DevOps     &brvbar;  Los ciclos de desarrollo se aceleran junto a las          ',
                '&brvbar;   <strong>desarrollo</strong>    &brvbar;           &brvbar;            &brvbar;                &brvbar;   necesidades y expectativas de los consumidores           ',
                '-------------------------------------------------------------',
                '&brvbar;  <strong>Arquitecturas</strong>  &brvbar; Monolitos &brvbar;     N      &brvbar; Microservicios &brvbar;  Las Arquitecturas se adaptan para que puedan cambiar      ',
                '&brvbar;    <strong>más usadas</strong>   &brvbar;           &brvbar;   Capas    &brvbar;                &brvbar;   y crecer sin necesidad de estar acopladas                ',
                '-------------------------------------------------------------',
                '&brvbar;   <strong>Despliegue &</strong>  &brvbar; Servidor  &brvbar;  Maquinas  &brvbar; Contenedores & &brvbar;  El consumo de recursos se torna más controlado y su       ',
                '&brvbar;   <strong>empaquetado</strong>   &brvbar;  fisico   &brvbar;  virtuales &brvbar; Orquestación   &brvbar;   asignación se vuelve más eficiente y adaptable           ',
                '-------------------------------------------------------------',
                '&brvbar; <strong>Infraestructura</strong> &brvbar; Centro de &brvbar; Servidores &brvbar;      Nube      &brvbar;  Los servidores locales dejan de usarse y las aplicaciones ',
                '&brvbar;    <strong>& Hosting</strong>    &brvbar;   datos   &brvbar;  locales   &brvbar;                &brvbar;   distribuidas y altamente disponibles se vuelven comunes  ',
            ]),
        new Item(Keys.NUBE_SRE,
            [
                '- Es el uso de herramientas de software para automatizar tareas de infraestructura como la administración de sistemas y monitoreo de aplicaciones ',
                '- Esto mejora la confiabilidad de los sistemas escalables al no tener que administrar cientos de maquinas manualmente ',
                '- La experiencia del cliente es bastante importante actualmente, por lo que es vital reducir cualquier afectación negativa ',
                '- Automatizar el ciclo de vida del software reduce los errores y los problemas de cara al usuario final ',
                '- El mantenimiento y la inclusión de nuevas funcionalidades se ven sustancialmente mejoradas ya que no afectan la fiabilidad de la aplicación ',
                '- <strong>SRE</strong> es la implementación practica de varias practicas de <strong>DevOps</strong> la cual es una cultura disruptiva de los roles de Desarrollo & Operaciones ',
                ' - de manera que se logre el equilibrio entre velocidad, estabilidad, calidad y los plazos cortos de desarrollo ',
                '',
                '<strong>Principios Clave</strong>',
                '<strong>- Monitoreo:</strong> Los errores son parte de cualquier sistema, no hay soluciones perfectas, por eso es necesario observar las aplicaciones de manera constante ',
                '<strong>- Cambios graduales:</strong> Implementar cambios pequeños de manera frecuente ayudan a mantener la fiabilidad del sitio ',
                '<strong>- Automatización:</strong> Tareas como testing, construcción, versionamiento, etc..  aseguran la fiabilidad en pasos comunes ',
                '',
                '<strong>Observabilidad:</strong> Ayudan a detectar comportamientos anomalos y recopilan información importante para que los desarrolladores comprendan los problemas ',
                '<strong>- Metricas:</strong> Valores cuantificables que reflejan el estado del sistema, rendimiento, recursos, etc.. ',
                '<strong>- Logs:</strong> Información con una marca temporal y detalles necesarios para comprender los problemas o eventos que sucedan ',
                '<strong>- Tracing:</strong> Son identificadores que ayudan a rastrear información a travez de un sistema distribuido(microservicios)',
                '',
                '<strong>Monitoreo:</strong> Observación de metricas de una aplicación, definiendo que es importante y que no para este proposito ',
                '<strong>- Latencia:</strong> Tiempo transcurrido entre una solicitud y su respectiva respuesta ',
                '<strong>- Trafico:</strong> Cantidad de usuarios que acceden simultaneamente al servicio, de manera que se puedan estimar costos ',
                '<strong>- Errores:</strong> La aplicación no funciona o no entrega el resultado esperado, estos se deben de identificar y corregir ',
                '<strong>- Saturación:</strong> Capacidad de la aplicación, si esta pasa los umbrales establecidos, suele haber una degradación del servicio ',
                '',
                '<strong>Metricas Clave</strong>',
                '<strong>Objetivos de nivel de servicio(SLO):</strong> Metas especificas y cuantificables que el software debe lograr, con costos razonables ',
                ' &bull; Por ejemplo un tiempo de actividad del 99,95% para todas las aplicaciones del sistema ',
                '<strong>Indicadores de nivel de servicio(SLI):</strong> Medidas reales de las metricas definidas, si difieren del SLO pueden estar incumpliendolo ',
                ' &bull; Por ejemplo existen aplicaciones que tienen un funcionamiento del 99,92% lo cual es inferior al SLO prometido ',
                '<strong>Acuerdos de nivel de servicio(SLA):</strong> Documentos legales que establecen lo que sucederia cuando no se cumplen uno o más SLO ',
                ' &bull; Por ejemplo el equipo tecnico resolvera el problema de su cliente dentro de las 24 horas posteriores al informe ó se reembolsara al cliente ',
                '<strong>Presupuesto de errores:</strong> Margenes admisibles para fallos del SLO, si este se sobrepasa, se deben destinar recursos para cumplirlo ',
                ' &bull; Por ejemplo si se tiene un tiempo de actividad del 99,95% se permite un periodo de inactividad del 0,05% ',
            ])
    ];

export const APIS =
    [
        new Item(Keys.APIS_API,
            [
                '- Son las siglas de <em>Interfaz de Programación de Aplicaciones</em>',
                '- Conjunto de reglas y especificaciones por el cual se puede comunicar diferentes componentes de software',
                '- La interfaz puede considerarse un contrato de servicio entre aplicaciones, definiendo la forma de comunicación, las solicitudes y las respuestas ',
                '- Permiten compartir y reutilizar funciones ya existentes, evitando reiventar la rueda',
                '- Suelen ser la entrada principal a los sistemas distribuidos y explicarse en terminos de cliente-servidor, por lo que deberian estar bien documentadas ',
                '',
                '<strong>Funcionamiento</strong>',
                '<strong>&bull; SOAP:</strong> Utiliza el protocolo simple de acceso a objetos, en formato <em>XML</em>, poco flexible pero bastante popular en el pasado ',
                '<strong>&bull; RPC:</strong> Se denominan llamadas a procedimientos remotos, donde el cliente completa una función en el servidor y este devuelve el resultado',
                '<strong>&bull; WebSocket:</strong> Funcionan de manera bidireccional, por lo que suelen ser más eficientes que los mecanismos de petición-respuesta ',
                '<strong>&bull; REST:</strong> Son flexibles ya que generalmente usan el formato <em>JSON</em>, aca el cliente envia la solicitud se procesa y se devuelve la respuesta',
                '',
                '<strong>Ciclo de vida</strong>',
                '<strong>&bull; Planificación:</strong> Las especificaciones de una API como OpenAPI proporcionan un esquema a seguir segun los estandares actuales ',
                '<strong>&bull; Creación:</strong> Se crean prototipos o versiones iniciales para encontrar mejoras internas y posibles mejoras durante el desarrollo ',
                '<strong>&bull; Pruebas:</strong> Cumplen las mismas especificaciones que las de una Aplicación normal, y deben hacerse para buscar y corregir errores o brechas de seguridad ',
                '<strong>&bull; Documentación:</strong> Aunque uno de los objetivos es que sean explicativas, la documentación sirve de guia para mejorar su uso y conocer bien sus comportamientos ',
                '<strong>&bull; Comercialización:</strong> La API se expone al publico en general con posibilidades de monetización o solo de manera parcial para los involucrados y/o interesados ',
            ]),
        // new Item('tiposApi',
        //     [
        //         '<strong>- Locales:</strong> Ofrecen servicios del SO o como middleware entre apliaciones, como el acceso a una BD ',
        //         '<strong>- Web:</strong> Ampliamente utilizadas para acceder a recursos expuestos mediantes el protocolo HTTP mediante una URL',
        //         ' - estas generalmente son de tipo REST pero tambien existen con el protocolo SOAP ',
        //         '<strong>- Programación:</strong> Se basan en llamar procedimientos remotos y que aparenten ser locales, como las apis de la serie WS de Microsoft',
        //     ]),
        new Item(Keys.APIS_REST_FULL,
            [
                '- Rest Es un estilo de arquitectura para sistemas distribuidos, que usa el protocolo HTTP ',
                '- Restful es la evolución y va más alla de simplemente exponer los datos a travez de una API para que sean consultados y/o modificados ',
                '',
                '<strong>Caracteristicas</strong>',
                '<strong>- Arquitectura cliente-servidor:</strong> Comunicación continua entre estos 2 agentes ',
                '<strong>- Stateless:</strong> No se deberia almacenar los datos del cliente para mantener el estado de este ',
                '<strong>- Cacheable:</strong> Algunas peticiones pueden ser cacheables para aumentar el rendimiento y la escabilidad ',
                '<strong>- Interfaz uniforme:</strong> Independencia del servidor, ya que siempre se garantizara la misma respuesta ',
                '<strong>- Mensajes:</strong> Todos los mensajes deben ser coherentes con la función que representan, halla un error ó no ',
                '<strong>- HATEOAS:</strong> Es incluir todo lo necesario en la respuesta para que el usuario pueda seguir haciendo peticiones ',
                '',
                '<strong>Web Restfull</strong>',
                '<strong>- Uri del recurso:</strong> Cada metodo deberia contar con una url unica para identificar la función ',
                '<strong>- Representación de recurso:</strong> Se puede añadir a la cabecera de la petición, definiendo el formato que se procesara ',
                '<strong>- Operaciones:</strong> Usar los metodos HTTP de manera idonea (GET, POST, PUT DELETE) ',
                '<strong>- Hipervinculos:</strong> Se pueden incluir vinculos para más acciones con el objeto, dentro de la respuesta ',
                '',
                '<strong>100% Restfull</strong>',
                '<strong>- Versionamiento:</strong> Las apis tambien cambian y esto no debe evitar que las versiones anteriores dejen de funcionar ',
                '<strong>- Autenticación:</strong> Esto garantiza un minimo de seguridad e integración en las operaciones a realizar, para esto se puede usar OAuth2 o JWT',
                '<strong>- Paginación:</strong> Mostrar todos los resultados es inviable en varios terminos, por lo que deberia haber una forma de segmentar la información ',
                '<strong>- Documentación:</strong> Cuando algo cambia la documentación tambien debe hacerlo, de lo contrario puede haber problemas e inconsistencias ',
                '<strong>- Respuestas:</strong> Los codigos deben reflejar lo que haya sucedido, es una mala practica siempre devolver <strong>200</strong>, en especial si han sucedido errores ',
            ]),
        new Item(Keys.APIS_MADURITY,
            [
                '- Entre más niveles se implementen, más util y completa se puede considerar una API',
                '',
                '<strong>Nivel 0:</strong> Se puede considerar simplemente como una conexión http con una sola URI y un solo metodo ',
                '<strong>Nivel 1:</strong> Usa varias URIs y un solo metodo http por cada una, esto ayuda a la separación de recursos ',
                '<strong>Nivel 2:</strong> Ademas de usar varias URIs, tambien se usan más metodos y tipos para cada URI, a su vez este expone más recursos ',
                '<strong>Nivel 3:</strong> Este hace uso de todo lo anterior además de incluir HATEOAS, esto facilita su navegación al punto de ser más intuitivo ',
            ]),
        new Item(Keys.APIS_HTTP_CODES,
            [
                '<strong>Respuestas informativas(1xx):</strong> Son poco usadas y se enfocan más a aspectos de la red y la comunicación ',
                '- 100 Continue              Repuesta provisional, indica que todo esta bien y que el cliente debe continuar o ignorar la solicitud',
                '- 102 Processing            El servidor ha recibido la solicitud y aun se encuentra procesandola, sin respuesta disponible ',
                '',
                '<strong>Respuestas satisfactorias(2xx):</strong> Se usan para denotar el exito de una operación ',
                '- 200 OK                    Respuesta estandar para peticiones correctas ',
                '- 201 Created               Solicitud aceptada y se ha creado un nuevo recurso ',
                '- 204 No Content            Solicitud completada con exito, la respuesta no tiene contenido ',
                '',
                '<strong>Redirecciones(3xx):</strong> Son cuando es necesario tomar acciones extras para efectuar la acción ',
                '- 300 Multiple Choices      Multiples opciones con varias respuestas ',
                '- 301 Moved Permanently     La URI solicitada ha sido movida a otra URI ',
                '- 304 Not Modified          Para propositos de cache, indicando que no ha sido modificado ',
                '',
                '<strong>Errores del cliente(4xx):</strong> La solicitud es incorrecta ya sea por sintaxis o información errada ',
                '- 400 Bad request           La solicitud no puede ser interpretada por una sintaxis invalida ',
                '- 401 Unauthorized          La autenticacion del usuario es posible pero incorrecta ',
                '- 403 Forbidden             No se cuenta con los permisos necesarios para el contenido ',
                '- 404 Not Found             El contenido solicitado no pudo ser encontrado ',
                '',
                '<strong>Errores del servidor(5xx):</strong> La solicitud es valida pero no pudo ser ejecutada debido a errores del servidor ',
                '- 500 Internal Server Error El servidor ha tenido un error que no sabe manejar ',
                '- 501 Not Implemented       El metodo solicitado no es soportado por el servidor ',
                '- 502 Bad Gateway           Al obtener una puerta de enlace se obtiene una respuesta invalida ',
                '- 503 Service unavailable   Servicio no disponible ',
            ]),
        new Item(Keys.APIS_HATEOAS,
            [
                '- Los servicios REST son más simples, por eso son una gran opción sobre SOAP, pero tambien se puede abusar de esto ',
                '- <strong>Hypermedia As The Engine Of Application State</strong> (hipermedia como motor del estado de la aplicación)',
                '- Basicamente se busca poder navegar y descubir sus recursos solo con las respuestas, sin depender exclusivamente de la documentación ',
                '- Para que esto se cumpla, parte de la respuesta deben ser hipervinculos a sus recursos asociados ',
                '- Esto con el fin de mantener compatibilidad con versiones más antiguas, y evitar problemas a sus consumidores ',
            ]),
        new Item(Keys.APIS_STANDARS,
            [
                '- Tener estandares para una API, es una manera simple de mejorar la coherencia, la estabilidad ',
                ' - la generalidad y su usabilidad, ya sean estandares de la comunidad, comerciales o propios ',
                '- Aunque equilibrar esto con con el desarrollo no siempre van en la misma linea, siendo inflexibles algunas veces ',
                '',
                '- Las palabras <strong>Must</strong>(debe), <strong>Should</strong>(deberia), <strong>May</strong>(puede) deberian ser usadas segun la definición RFC 2119',
                '',
                '<strong>Principios y terminos a conocer</strong>                       ',
                ' - REST                      - REST Model               - Tipos de API:  ',
                ' - DDD                       - Eventos y sucesos         - Negocio       ',
                ' - Madurez del API                                       - Mediadora     ',
                '',
                '<strong>Manejo del ciclo de vida</strong>   5 Estados & 3 Etapas principales',
                ' - Diseño    ->  Testing      ->  Publicación   ->  Deprecación   -> Retiro   ',
                ' - Validar       Tests            Soporte                                     ',
                ' - Modelo        Evaluación       Observación                                 ',
                '',
                '<strong> - Manejo de versiones</strong> Ya sea semantico, por estabilidad, o un enfoque más practico y despreocupado, en la misma url',
                '<strong> - Implementar (IAM)</strong> <em>Identity Access Management</em> controlando que recursos son protegidos y el como ',
                '<strong> - Documentación y Herramientas de diseño</strong> La especificación de OpenApi (OAS), define un estandar agnostico para las APIs REST ',
                '<strong> - Integrar DevOps y CD/CI</strong> Reduciendo el tiempo entre etapas y agilizando el depliegue y mantenimiento con cada versión ',
                '<strong> - Control de documentación</strong> La documentación debe estar presente y ser accesible, además de concordar con lo expuesto ',
                '',
                '<strong>Rutas y convenciones de nombres</strong>',
                ' - Estos facilitan la coherencia y la predictibilidad, pero hay que tener muchos factores a consideración, como: ',
                '  - Lenguajes, protocolos, frameworks, participantes, codigo heredado, etc... ',
                '<strong>- Campos y parametros</strong> Estos deben ser consistentes, ya sea lowerCamelCase o snake_case; si son arreglos puede ser plural ("names") ',
                '<strong>- Recursos</strong> Deberian ser sustantivos que indiquen la pluralidad o la singularidad como tal ',
                '<strong>- Identificadores</strong> Unicos e inmutables y que los soporte la URL ',
                '<strong>- Rutas</strong> Su composición deberia ser secuencial y predecible, primando la usabilidad ',
                '',
                '<strong>Convenciones para carga util</strong>',
                '<strong>- Codificación</strong> El formato Unicode-8 (UTF-8) es el tipo de codificación estandar para todo el texto y sus representaciones textuales ',
                '<strong>- Formato de datos interoperables</strong> Datos comunes como fechas o direcciones deberian ser compartidos y/o compatibles con terceros ',
                '<strong>- Documentar la respuesta y la petición</strong> Estas deberian ser los más simples y livianas posibles ',
                '<strong>- Datos binarios y multi contenido</strong> Estos deben analizarse para evitar problemas de serialización/deserialización ó rendimiento ',
                '<strong>- HATEOAS, Links y Paginación</strong> Utiles para dispensar y navegar en grandes volumenes de datos ',
                '',
                '<strong>Protocolos de Peticiones y Respuestas ',
                '<strong>- HTTPS</strong> Solo exponer endpoints encriptados ',
                '<strong>- Metodos HTTP</strong> Breve explicación de que metodos pueden ser usados y en que escenarios ',
                '<strong>- Encabezados HTTP</strong> Describir que Headers son usados para las peticiones y las respuestas ',
                '<strong>- Codigos HTTP</strong> Cada recursos puede responder con diferentes codigos de acuerdo al exito/error de la solicitud',
                '<strong>- Cache</strong> Como impacta su uso o no, en la API, ya sea en rendimiento, disponibilidad, coherencia, etc... ',
                '',
                '<strong>Manejo de errores</strong>',
                '- Devolver un codigo de error HTTP puede ser rapido y transmite información a grandes rasgos, sin exponer datos confidenciales ',
                '- Sin embargo esto entorpece el registro y analisis de errores; debiendo devolver errores más detallados, que eviten lo tecnico ',
                '',
                '<strong>Seguridad:</strong> Toda la información que se exponga debe ser debidamente controlada, para evitar filtraciones y comprometer datos sensibles ',
                '<strong>- Alcance</strong> Se pueden definir que rutas necesitan autenticación y cuales no, definiendo diferentes alcances ',
                '<strong>- Transporte</strong> Exponer solo endpoints encriptados o versiones especificas de TLS ',
                '<strong>- Gateway API</strong> Otra manera de brindar seguridad, ocultando el procesamiento de la petición ',
                '',
                '<strong>Registro y Trazabilidad ',
                '<strong>- Logging & Tracing</strong> Contenido clasificado o sensible no debe ser almacenado en los logs, a menos que sea seguro ',
                '<strong>- Audit Logs, Security Incident & Event Management</strong> Cada incidente debe analizarse y actuar en consecuencia ',
                '',
                '<strong>Consideraciones:',
                ' - Todo lo anteriormente recopilado es una guia, por lo cual debe ser adaptado de acuerdo a cada nuevo contexto ',
                ' - Y no se excluye de que este abierto a posibles cambios y mejoras por venir, despues de nuevas iteraciones',
                ' - Además de que cada tema y subtema a su vez tiene fuentes de profundización, presentes en el articulo original ',
            ]),
        new Item(Keys.APIS_GATEWAY,
            [
                '- Aunque sean terminos similares, un Api gateway y un Balanceador de carga son soluciones diferetes, para muchos problemas similares ',
                '<strong>- Api Gateway:</strong> Son una capa de filtración para las ya conocidas APIs, permitiendo que los clientes puedan realizar llamados y obtener el recurso ',
                '<strong>- Balanceador de carga:</strong> Es un sistema para equilibrar todo el trafico de nuestra aplicación, permitiendo que no se sobrecarguen los servidores ',
                '',
                '- Una de las principales diferencias radica en que el Api Gateway puede realizar tratamientos a la petición entrante, ',
                ' - como autenticación, validaciones, formateo, priorización, además de ofuscamiento y funcionar como posible limitador ',
                '- Por otro lado su contraparte, solo le interesa distribuir el trafico de la red, de manera que ningun nodo o servidor, ',
                ' - llegue a saturarse mientras que otros no esten realizando ninguna acción, y en algunos casos hasta puede funcionar como firewall ',
            ]),
        new Item(Keys.APIS_ARQUITECTURAL_STYLES,
            [
                '<strong>REST (Representational State Transfer)</strong> El campeon en cuanto a simplicidad y ubicuidad, este aprovecha los metodos HTTP y Json',
                ' - permitiendo una acercamiento amigable con los recursos, siendo al dia de hoy uno de los estilos más usados ',
                '',
                '<strong>SOAP (Simple Object Access Protocol)</strong> Es una implementación robusta y compleja, que usa principalmente XML para definir ',
                ' - una comunicación estructurada, y aunque requiera un cliente-servidor, es compensada por su resiliencia ',
                '',
                '<strong>GraphQL</strong> Un contendiente nuevo en el campo que ofrece flexibilidad y precisión, permitiendo solicitar a los clientes exactamente ',
                ' - lo que necesitan, reduciendo la redundancia y las sobrecargas de la red, aunque en algunos casos pueda conllevar a problemas de rendimiento ',
                '',
                '<strong>gRPC (Google Remote Procedure Call)</strong> Es el más veloz de todas las APIs actualmente, este corre sobre HTTP/2 y puede utilizar datos binarios ',
                ' - especialmente util para microservicios, donde la comunicación rapida y fiable es vital ',
                '',
                '<strong>WebSockets</strong> Comunicación en tiempo real y bidirecional, bastante util en aplicaciones en vivo y con una constante transmision de datos ',
                '',
                '<strong>Webhooks</strong> Estos notifican a los clientes cuando ocurren ciertos eventos, desde el lado del servidor, asi todos los clientes',
                ' - se mantienen enterados ante cualquier evento, perfectos para arquitecturas basadas en eventos ',
                '',
                '<strong>MQTT (Message Queuing Telemetry Transport)</strong> Es un mensajero liviano, diseñado para entorno con recursos limitados, redes inestables ',
                ' - y con problemas de ancho de banda, que siempre intenta ser lo más confiable posible ',
                '',
                '<strong>AMQP (Advanced Message Queuing Protocol)</strong> Una cola de mensajes robusta y estandarizada, sobresaliente al trabajar como middleware ',
                ' - aca los mensajes son sumamente confiables ',
                '',
                '- No todos los estilos son ideales, para todas las tareas, aca se deben evaluar los requerimientos y requisitos tecnicos ',
                '&bull; El tipo de datos que se van a enviar/recibir, el formato y su compatibilidad entre ambas partes ',
                '&bull; Los requerimientos relacionados al rendimiento e interoperabilidad entre sistemas, ya que rara vez son negociables ',
                '&bull; Que tanta seguridad se requiere ',
                '&bull; Proyecciones de escalabilidad ',
            ]),
        new Item(Keys.APIS_URI,
            [
                '<strong>U</strong>niversal <strong>R</strong>esource <strong>I</strong>dentifier: Es una secuencia de caracteres que identifica un recurso logico(abstracto) o fisico ',
                '&bull; <strong>U</strong>niversal <strong>R</strong>esource <strong>L</strong>ocator: Es el más comun ya que se usa para las direcciones web',
                '&bull; <strong>U</strong>niform   <strong>R</strong>esource <strong>N</strong>ame:    Ubicación persistente que nombra un recurso sin simplificar su ubicación ',
                '&bull; <strong>U</strong>niform   <strong>R</strong>esource <strong>C</strong>haracteristics: Es la metadata que describe un recurso particular  ',
                '',
                '- Esto facilita las interacciones de los protocolos de internet, con una sintaxis generica de: <strong>scheme://authority:port/path?query#fragment</strong>',
                '&bull; <strong>Scheme:</strong> Nombre del esquema como http, https, ftp, file y es separado por (:)',
                '&bull; <strong>Authority:</strong> Se compone de un nombre(dominio) registrado o una dirección IP, autenticacion(opcional), puerto(opcional) ',
                '&bull; <strong>Path:</strong> La ruta al recurso, separada por (/) y no puede empezar con (//)',
                '&bull; <strong>Query:</strong> Cadena de datos no jerarquicos, que suele ser una secuencia de pares atributo-valor, separados por (&) generalmente ',
                '&bull; <strong>Fragment:</strong> Contiene un identificador que proporciona dirección a un recurso secundario, separado por (#) ',
            ]),
        new Item(Keys.APIS_TESTING,
            [
                '<strong>Pruebas de humo:</strong> Validación simple de que el API funcione y nada se rompa',
                '<strong>Pruebas funcionales:</strong> Crea un plan de pruebas basado en los requisitos funcionales, y compara los resultados con los esperados ',
                '<strong>Pruebas de integración:</strong> Prueba la comunicación entre varias APIs y los servicios de extremo a extremo ',
                '',
                '<strong>Pruebas de regresión:</strong> Garantiza que la correción de errores o nuevas funcionalidades, no alteren el comportamiento del API ',
                '<strong>Pruebas de carga:</strong> Mide el redndimiento de la aplicación, simulando diferentes cargas de trabajo, y calcular su capacidad ',
                '<strong>Pruebas de estres:</strong> Se crean cargas elevadas de manera deliberada y se prueba si el API funciona con normalidad ',
                '',
                '<strong>Pruebas de seguridad:</strong> Se prueban posibles fallos de seguridad y posibles amenazas externas ',
                '<strong>Pruebas de UI:</strong> Es la interacción entre la interfaz de usuario y el API, para asegurarse que los datos se muestren correctamente ',
                '<strong>Pruebas fuzz:</strong> Se ingresan datos no validos o inesperados, para intentar bloquear el API, y/o encontrar vulnerabilidades ',
            ]),
        new Item(Keys.APIS_IDEMPOTENCIA,
            [
                '- La idempotencia es un concepto informatico, que describe una operación o función que cuando se aplica varias veces, ',
                ' - tiene el mismo efecto que si se aplicara una vez, esto en informatica es bastante necesario por 2 razones: ',
                '',
                '<strong>Reintentos:</strong> Permite reintentar operaciones fallidas, sin temor a causar efectos segundarios, o problemas indeseados ',
                ' - en escenarios donde ocurren problemas de red, tiempo de espera, o fallas recurrentes, aumentando la tolerancia a los fallos ',
                '<strong>Sistemas distribuidos:</strong> En sistemas distribuidos las operaciones repetidas pueden generar efectos adversos, con esto ',
                ' - las solicitudes repetidas dan resultados más consistentes, permitiendo resultados predecibles y un sistema estable ',
                '<strong>Operaciones con Bases de Datos:</strong> El volver a aplicar operaciones sobre registros ya existentes, no debe cambiar el estado actual ',
                '',
                '- Diseñar y crear un API Idempotente en sistemas de diferentes tipos y arquitecturas conlleva su propio conjunto de desafios ',
                '',
                '<strong>Arquitectura de sistemas distribuidos y microservicios</strong>',
                '<strong>- Limites:</strong> Cuando se manejan transacciones, es comun tener limites, por lo que coordinar estas operaciones ',
                '  - entre multiples servicios como si fuera un unico contexto transaccional, requiere un modelo claro de transacciones distribuidas ',
                '<strong>- Cache Distribuido:</strong> Mantener un cache actualizado y coordinado, para que pueda ser distribuido',
                '  - requiere tener ciertas consideraciones, en especial si se tienen actualizaciones parciales ',
                '',
                '<strong>Operaciones asyncronas y Arquitecturas basadas en eventos</strong>',
                '<strong>- Ordenamiento y entrega de eventos:</strong> Garantizar el orden de las operaciones y que los eventos duplicados ',
                ' - no provoquen efectos segundarios es un desafio',
                '<strong>- Rollbacks:</strong> La reversión de cambios, en especial cuando es desencadenada por eventos asyncronos o se dan ',
                ' - en sistemas distribuidos, requiere de una planificación cuidadosa y un proceso meticuloso',
                '',
                '<strong>Componentes Stateful & Stateless</strong>',
                '<strong>- Sesiones:</strong> Las sesiones deben ser diseñadas para tener en cuenta la Idempotencia ',
                ' - y más si es necesario tener en cuenta diferentes estados o se manejan multiples sesiones ',
                '<strong>- Tokens:</strong> Gestionar la reutilización o la singularidad de los tokens, esta intrinsecamente ',
                ' - ligado al manejo de las sesiones, asi como si aceptar o denegar peticiones que provengan de sesiones caducas ',
                '<strong>- Solicitudes sin estado:</strong> Obtener información que requiere de sesiones en sistemas sin sesiones ',
                ' - requiere alternativas como el uso de tokens idempotentes y su debida implemetación ',
                '<strong>- Autenticación y Autorización:</strong> Toda solicitud debe ser debidamene autorizada y contar ',
                ' - con una autenticación previa, sin depender de los datos de sesion y al mismo tiempo ser eficiente ',
            ]),
        new Item(Keys.APIS_REST_VS_MESSAGING,
            [
                '- Los microservicios han llegado para quedarse, ampliamente adoptados debidos a las ventajas que ofrecen',
                '- Aun asi, para un correcto funcionamiento, deben poder comunicarse entre si, convirtiendo esta forma en un aspecto critico ',
                '-<em> Martin Fowler</em> defiende lo que el llama <strong>smart endpoints and dumb pipes</strong> para la comunicacion entre microservicios ',
                '- En el pasado los <em>Enterprise Service Buses</em> dominaban junto a <strong>SOA</strong> donde era comun integrar la logica de integración ',
                ' - y la transformación de los datos en la infraestructura, convirtiendola en una arquitectura de tipo <strong>smart pipes</strong> y <strong>dumb endpoints</strong>',
                '',
                '<strong>REST</strong> como se conoce hoy en dia, fue definida por <em>Roy Fielding</em> en su tesis doctoral',
                ' - <strong>Architectural Styles and the Design of Network-based Software Architectures</strong>, además de ser parte del proceso de definición de <strong>HTTP</strong> que ',
                ' - desde entonces es vital para la industria y es una base fundamental del desarrollo moderno de aplicaciones, debido a sus multiples fortalezas: ',
                '',
                '<strong>- Solicitud/Respuesta Sincrona:</strong> Este comportamiento es la base del protocolo de red sobre el que esta REST, por lo que practicamente es heredado ',
                '<strong>- Publico y estandarizado:</strong> Gracias al trabajo del <em>IETF</em> REST y su capa de transporte es interoperable entre todos los lenguajes de programación ',
                ' - además de contar con multiples herramientas para documentación y el manejo de la seguridad ',
                '',
                '- Aun asi, hay escenarios donde no es ideal, o no es posible tener este tipo de comunicación sincrona, por lo que no todo se puede solucionar con Rest',
                '',
                '<strong>- Acoplamiento Indeseado:</strong> Con un servicio Rest se asume que un dato es solicitado solamente por el sitio que lo necesita, que sucede cuando otro ',
                ' - servicio o componente se conecta y necesita los datos, desafiando el proposito de un unico objetivo, y convirtiendose en un orquestador no deseado ',
                '<strong>- Bloqueos:</strong> Al ser sincrono, cada petición debe esperar la respuesta, mediante un bloqueo, que evita la liberación y reutilización de estos recursos ',
                '',
                '<strong>Mensajeria y manejo de eventos</strong> Muchas deficiencias asociadas al sincronismo de Rest, se pueden solucionar al implementar microservicios controlados ',
                ' - por eventos, esto los hace inheremente asincronicos, asi solamente actuan cuando necesitan publicar o subscribirse a lo que les importa o necesitan ',
                '',
                '<strong>- Acoplamiento flexible:</strong> Al usar un patron de publicación/subscripción los servicios no se conocen entre si, por lo que cualquier servicio ',
                ' - solo debe publicar o subscribirse a lo que le interesa y/o necesita',
                '<strong>- Sin bloqueos:</strong> Ya no es necesario esperar hasta que se complete la solicitud, ahora se pueden realizar multiples tareas, sin bloquear los recuros, ',
                ' - dejando espacio para que se puedan hacer más tareas, de la manera más eficiente posible ',
                '<strong>- Escalable:</strong> A medida que la demanda crece, es fundamental crecer para aumentar la capacidad, por lo que al tener servicios más pequeños, ',
                ' - estos pueden crece/decrecer, de una manera fiable, rapida y de manera individual, especialmente cuando se detectan cuellos de botella ',
                '<strong>- Resiliencia y Errores:</strong> Al tener plataformas que garantizan la entrega de mensajes, se reduce la logica al no tener que lidiar con mensajes perdidos ',
                ' - y la consistencia de los datos, eventualmente se recuperara, al procesar todos los mensajes acumulados, durante el tiempo que habian errores ',
            ]),
        new Item(Keys.APIS_API_GOVERNANCE,
            [
                '- La integración entre sistemas por medio de apis, crece todos los dias y se convierten en piezas claves para las estrategias comerciales ',
                '- Es especialmente beficiosa si es una arquitectura de microservicios, ya que entre mayor sea la empresa, mayor numero de Apis creara/consumira ',
                '',
                '<strong>Centralización:</strong> Tener un punto central donde se creen y se hagan cumplir las politicas, para toda la organización ',
                '<strong>Contratos:</strong> Algunas empresas estan adoptando un enfoque API-First, ayudando a establecer que sean coherentes y reutilizables ',
                '<strong>Guia de estilo:</strong> La estandarización del diseño garantiza que todas las APIs sean coherentes entre si',
                '<strong>Reutilizabilidad:</strong> La estandarización además de garantizar la coherencia, tambien contempla que existan componentes reutilizables ',
                '<strong>Automatización:</strong> Los contratos, la documentación y el seguimiento, son procesos que pueden y deberian ser automatizados ',
                '<strong>Versionamiento:</strong> Ayuda a realizar un seguimiento y mantener diferentes versiones, sin afectar a los consumidores',
                '<strong>Deprecación:</strong> En la medidad que las APIs queden obsoletas, se debe controlar cuando y como dejaran de utilizarse ',
                '<strong>Tracking:</strong> El seguimiento de los aspectos de una API deberia ser parte de su gestión, como, quien, cuando, ciclo de vida, etc..',
                '<strong>Discovery:</strong> Tambien es necesario un metodo para representar las depedencias y ayudar a analizar posibles futuros impactos ',
            ]),
        new Item(Keys.APIS_API_FIRST,
            [
                '- Las APIs han existido casi a la par que la informatica moderna, surgieron por la necesidad de que multiples aplicaciones de software se comunicaran ',
                '- Siguen cumpliendo esa función, trabajando de forma invisible, mientras que en segundo plano comunican millones de dispositivos y aplicaciones ',
                '- El enfoque <strong>API-First</strong> prioriza las API al comienzo del desarrollo, posicionandose como un componente basico del software ',
                '- El diseño se realiza antes de que se inicie el desarrollo, pensando en el servicio que se va a exponer y no como un resultado del desarrollo ',
                '',
                '<strong>API Publicas:</strong>',
                '- Proveen acceso publico a datos y servicios ofrecidos por cualquier organización',
                '- Pueden ser totalmente gratuitas o cobrar tarifas por sus servicios ',
                '- Pueden ser integradas en aplicaciones de terceros sin problemas de licencias generalmente ',
                '',
                '<strong>API Privadas:</strong>',
                '- Usadas para conectar aplicaciones y componentes de software de una misma empresa ',
                '- No se exponen para ser usadas ante terceros',
                '- Las empresas suelen tener cientos o miles de API, tantas como sean necesarias ',
                '',
                '<strong>API Partners:</strong>',
                '- Son establecidas entre una o varias compañias, como medios eficaces de compartir información y colaboración ',
                '- No son expuestas al publico en general, pero tampoco son totalmente privativas ',
                '- Suelen tener mecanimos de seguridad y autenticación, para restringir el acceso indebido ',
                '',
                '<strong>API Lifcycle:</strong>',
                '- Toda API tiene un ciclo de vida, por esto es preciso que se defina y coordina de manera precisa, estas suelen ser las etapas más comunes ',
                '<strong>- Productor:</strong>  Definición -> Diseño -> Desarrollo -> Tests -> Seguridad -> Despliegue -> Observación -> Distribución ',
                '<strong>- Consumidor:</strong> Descubrimiento -> Evaluación -> Integración -> Tests -> Despliegue -> Observación ',
                '',
                '<strong>Beneficios:</strong>',
                '- Aumenta la productividad, al tener una colaboración estrecha a lo largo de todo el ciclo de vida ',
                '- Simplifica la gobernanza al tener un panorama claro en todas las etapas, y una comprensión de todo el ecosistema empresarial ',
                '- Es un modelo compatible con multiples rutas de trabajo, siendo adaptable segun la necesidades ',
                '- Cumplir con esta designación, implica que se deben seguir mas procedimientos, etapas, iteraciones, etc.. que aumentan la calidad del software '
            ]),
        new Item(Keys.APIS_LATENCY_THROUGHPUT_BANDWITH,
            [
                '- La velocidad de la red es el termino general para describir la velocidad en que los datos viajan a traves de la red ',
                '- Esta se divide en 3 conceptos principales que no deben ser confundidos, a pesar de su correlación ',
                '- La relación entre estas 3 caracteristicas pueden darse de diferentes maneras y algunas pueden ser hasta contraituitivas',
                '',
                '<strong>Latencia:</strong> Se refiere al tiempo que tarda un paquete de datos para viajar de un punto a otro de la red ',
                '- Entre menor sea la latencia, menor sera el retraso para el usuario final, aunque no se garantize un buen rendimiento ',
                '',
                '<strong>Rendimiento(throughput):</strong> Cantidad de datos que viajan correctamente a traves de la red, durante un intervalo especifico ',
                '- Se ve afectado por multiples factores, desde fisicos como el estado de la infraestructura, hasta la cantidad de usuarios y el tipo de datos ',
                '',
                '<strong>Ancho de banda:</strong> Capacidad maxima de la transferencia de datos de la red, se define de manera teorica en un periodo especifico ',
                '- Suele ser comparados con los carriles de una autopista y como esta soporta una gran cantidad de automoviles(paquetes) de manera simultanea ',
                '',
                '&brvbar;                    <strong>Factores influyentes</strong>                    &brvbar;',
                '&brvbar;     <strong>Latencia</strong>     &brvbar;     <strong>Rendimiento</strong>     &brvbar;  <strong>Ancho de banda</strong>   &brvbar;',
                '&brvbar; Distancia        &brvbar; Ancho de banda      &brvbar; Capacidad teorica &brvbar;',
                '&brvbar; Numero de saltos &brvbar; Latencia            &brvbar; Enrutamiento      &brvbar;',
                '&brvbar; Medios fisicos   &brvbar; Perdida de paquetes &brvbar; Interferecias     &brvbar;',
                '&brvbar; Congestión       &brvbar; Congestión          &brvbar; Congestión        &brvbar;',
                '&brvbar; Hardware         &brvbar; Hardware            &brvbar; Hardware          &brvbar;',
                '&brvbar; Infraestructura  &brvbar; Infraestructura     &brvbar; Infraestructura   &brvbar;',
                '',
                '- Otros factores importantes a tener en cuenta son que los sistemas pueden deliberadamente limitar la velocidad <strong>Rate Limit</strong> ',
                '- Esto con el fin de proteger el sistema y se suele definir en solicitudes por minuto <strong>RPM</strong> o solicitudes por segundo <strong>RPS</strong> ',
                '- Este <em>limite de velocidad</em> permite que los recursos no sean acaparados y garantiza una circulación fluida evitando la saturación del sistema '
            ]),
        new Item(Keys.APIS_RATE_LIMITING,
            [
                '- La limitación del consumo es una estrategia imprescindible en cualquier aplicación Backend, evitando que los usuarios sobre utilizen los recursos ',
                '- Generen degradaciones en los servicios, salvaguardar recursos ó como proteccion contra ataques DDoS; <strong>Estrategias comunes:</strong> ',
                '',
                '<strong>Token bucket</strong>',
                '- Un cubo contiene una cantidad fija de fichas ',
                '- Los tokens se agregan al cubo a una tasa fija y cuando llega una solicitud: ',
                '- Si hay un token disponible se elimina del cubo y se permite la solicitud, si no la solicitud se rechaza o se retrasa ',
                '- Permite un alto trafico de solicitudes o rafagas siempre y cuando haya capacidad ',
                '',
                '<strong>Leaky bucket</strong>',
                '- Se puede ver como un cubo de agua que pierde agua a un ritmo fijo ',
                '- Las solicitudes entrantes se agregan al cubo ',
                '- Las solicitudes se procesan o se "filtran" a un ritmo constante  ',
                '- Si el deposito esta lleno cuando llegue una nueva solicitud, esta se descarta ',
                '- Suaviza los picos y emite solicitudes a un ritmo constante ',
                '',
                '<strong>Fixed Window counter</strong>',
                '- El tiempo se divide en ventanas de tamaño fijo ',
                '- Un contador rastrea la cantidad de solicitudes por cliente/IP en la ventana actual ',
                '- Si el recuento excede el limite se rechazan hasta la siguiente ventana ',
                '',
                '<strong>Sliding window counter</strong>',
                '- Cada registro tiene la fecha en que fue hecha la petición, ',
                '- Con cada solicitud se cuentan los registros para saber la cantidad en <strong>X</strong> tiempo determinado ',
                '- Si esta por debajo del limite se procesa, de lo contrario se rechaza ',
            ]),
        new Item(Keys.APIS_API_FIRST_VS_CODE_FIRST,
            [
                '- El diseño de un API determina la comunican entre componentes, convirtiendose en un elemento fundamental de las aplicaciones y sus integraciones ',
                '- Existen 2 formas para su desarrollo con ventajas y desventajas, su elección es determinada por las necesidades del proyecto y las capacidades del equipo ',
                '',
                '<strong>API First:</strong> Prioriza el diseño antes de cualquier implementación, y se define mediante lenguajes de descripción como OpenAPI ',
                '- Se crean contratos, especificaciones y comportamientos que debera tener ya finalizada ',
                '',
                '<strong>Ventajas</strong>',
                '&bull; Consistencia y reusabilidad ya que se definieron y analizaron de forma conjunta en su etapa inicial ',
                '&bull; Colaboración entre los multiples actores involucrados, testers, stakeholders, desarrolladores, desde un inicio ',
                '&bull; Documentación automatica a partir de una especificación y en algunos casos generación de codigo tambien ',
                '&bull; Desarrollo paralelo de manera que cada equipo implemente y pruebe componentes basados en las especificaciónes previas ',
                '<strong>Desventajas</strong>',
                '&bull; Requiere más tiempo inicial para diseñar y acordar todas las especificaciones ',
                '&bull; Presenta rigidez ante cambios rapidos que se puedan presentar durante el desarrollo ',
                '',
                '',
                '<strong>Code First:</strong> Implica escribir el codigo primero y luego generar la documentación y las especificaciones a partir de este ',
                '- Este enfoque es el más tradicional en el cual ya existe la implementación de la logica que expondra el API ',
                '',
                '<strong>Ventajas</strong>',
                '&bull; Rapidez de construcción y de proyectos pequeños que funcionan como prototipos ',
                '&bull; Flexibilidad para generar cambios y ajustes rapidos durante el desarrollo ',
                '&bull; La fase inicial del diseño no es tan extensa ',
                '<strong>Desventajas</strong>',
                '&bull; Puede resultar una API inconsistente si varios desarrolladores trabajan en el proyecto y no existe alguna guia en comun ',
                '&bull; La documentación es posterior llegando a ser menos precisa y/o extensa ',
                '&bull; Como no todas las partes estuvieron involucradas desde el inicio, los stakeholders y testers pueden tener dificultades '
            ])
    ];

export const META_ESTRUCTURAS =
    [
        new Item(Keys.META_ESTRUCTURAS_SCOPE,
            [
                '- Se puede definir como el alcance que tendran las variables en tu codigo, donde se pueden ver y acceder',
                '',
                '<strong>Scope Local o interno:</strong> Las variables seran accesibles solamente en el ambito declarado como: dentro de una función o una sentencia de control ',
                '<strong>Scope Global o externo:</strong> Se pueden acceder desde cualquier parte de tu codigo y por consiguiente ser mutada, trayendo posibles bugs consigo ',
                '',
                '<strong>Ambito Lexicografico o estatico:</strong> Las entidades solo pueden ser vistas desde el el bloque al que pertenecen o bloques internos ',
                '- Es el ambito más conocido y utilizado por muchos lenguajes y se da en tiempo de compilación ',
                '',
                '<strong>Ambito Dinamico:</strong> Se pueden crear entidades que pueden ser llamadas desde bloques independientes al que fueron definidas ',
                '- Muy pocos lenguajes de programación lo implementan y si lo hacen es como una extensión, ya que esto dificulta la comprensión del codigo ',
                '',
                '<strong>Contexto:</strong> Si el ambito es la <em>visibilidad</em> de las variables, el contexto se refiere a la pertenencia de las entidades a un objeto ó estructura ',
                '- Por ejemplo, 2 objetos de la misma clase, ambos tienen implementaciones iguales en sus metodos, pero contextos totalmente diferentes cuando se instancian ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_PRECEDENCIA,
            [
                '- Los operadores en las expresiones tienen una jerarquia predeterminada que determina el orden de evaluación ',
                '- La precedencia puede cambiar entre lenguajes, por lo que se recomienda saber las especificaciones de cada uno ',
                '',
                '- Operadores con igual prioridad se evaluan de izquierda a derecha ',
                '- Operadores logicos y de operación bit a bit de izquierda a derecha ',
                '- Operadores matematicos respetan la jerarquia matematica, a menos que se involucren parentesis(<strong>asociatividad</strong>) ',
                '- Los parentesis afectan el orden de evaluación, al mismo tiempo que permiten asociar expresiones ',
                '- Tambien se pueden lograr un <strong>cortocircuito</strong> donde ciertos operadores como <strong>&&</strong> ó <strong>||</strong> pueden romper las expresiones ',
                '- Por ejemplo <em>a && (b || c)</em> si a es false no se evaluara el resto o en caso de que b sea verdadera, c no se evaluara',
            ]),
        new Item(Keys.META_ESTRUCTURAS_VERTICAL_AND_HORIZONTAL,
            [
                '- Una buena estructura es primordial para todo proyecto, sin embargo no siempre debe reflejar la arquitectura del proyecto',
                '',
                '    Products      Orders                  Customers                    ',
                '-------&darr;------------&darr;-----    Views     -----&darr;------     <strong>Estructura horizontal:</strong>',
                '-------&darr;------------&darr;-----   Presenter  -----&darr;------     - Estaba fuertemente ligado al modelo en cascada, ',
                '-------&darr;------------&darr;-----    Domain    -----&darr;------      - donde se realizaban capas transversales a todo el sistema,',
                '------ &darr;------------&darr;-----   Services   -----&darr;------      - de manera que todo los componentes estaban separados entre si',
                '-------&darr;------------&darr;-----   Entities   -----&darr;------     - Suele ser compleja de entender si no se entiende el negocio ',
                '-------&darr;------------&darr;----- Repositories -----&darr;------      - además de que no todos necesitan las mismas partes para funcionar',
                '-------&darr;------------&darr;-----  DataSource  -----&darr;------     ',
                '',
                '',
                '    Products           Orders          Customers     ',
                '|    Views     |  |    Views     |  |    Views     |     <strong>Estructura vertical:</strong>',
                '|   Presenter  |  |   Presenter  |  |   Presenter  |     - Aca prima el dominio, por lo que cada capa esta aislada entre si',
                '|    Domain    |  |    Domain    |  |    Domain    |     - Toda la estructura de un componente es independiente entre si',
                '|   Services   |  |   Services   |  |   Services   |     - Esta aislación permite cambios más rapidos y faciles',
                '|   Entities   |  |   Entities   |  |   Entities   | ',
                '| Repositories |  | Repositories |  | Repositories | ',
                '|  DataSource  |  |  DataSource  |  |  DataSource  | ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_REGEX,
            [
                '- Un patrón es un modelo, plantilla, molde, diseño, que nos permite obtener varias cosas identicas ',
                '- Una expresion regular es una forma de buscar coincidencias de acuerdo a un patrón de manera optimizada ',
                '- Tambien permiten el reconocimiento de patrones, donde se analiza y extrae información para obtener un patrón ',
                '',
                '- Se basan en diagramas de estado, ya que todas las transiciones se deben cumplir, para que el texto a evaluar cumpla con las condiciones dadas ',
                '- Estas expresiones son independientes del lenguaje que se use y tienen un alfabeto, simbolos y reglas para ser escritas',
                '- Los compiladores de muchos lenguajes se basan en analizadores sintacticos, para analizar el codigo copiado, ',
                ' - estos a su vez se basan en expresiones regulares para saber si se cumplen con las condiciones del lenguaje ',
                '',
                '<strong>Usos:</strong>',
                '- <em>Buscar</em> coicidencias con los patrones        - <em>Contar</em> todas las coicidencias segun el patrón ',
                '- <em>Remplazar</em> lo encontrado por otra cosa       - <em>Posiciónes</em> de cada coicidencia que se haya encontrado ',
                '- <em>Separar</em> un elemento en diversas partes      - <em>Transformación</em> de un texto a otro segun el patrón ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_ESTRUCTURAS_DATOS_I,
            [
                '- Es un concepto general que comparten muchos lenguajes de programación ',
                '- Que a su vez pueden cambiar y/o tener variaciones segun el lenguaje, dependiendo de cada implementación ',
                '- Una estructura es una colección de valores organizados, sobre los cuales se pueden administrar y hacer operaciones con ellos ',
                '- Tambien existe una manera estandarizada o implementada por el mismo lenguaje para acceder a los datos, y suelen ser de distintos tipos: ',
                '',
                '<strong>- Contiguamente asignadas:</strong> Compuestas por bloques de memorias unicos e incluyen a: <em>Arrays, Matrices, Heaps, Hash Tables</em>',
                '<strong>- Estructuas enlazadas:</strong> Son distintos fragmentos de memoria unidos por punteros e incluyen: <em>Listas, Arboles y Grafos </em>',
                '<strong>- Contenedores:</strong> Permiten almacenar y recuperar datos en un orden determinado y contienen: <em>Pilas y colas</em>',
                '',
                '- Existen más tipos de estructuras, pero estas son de las más comunes y usadas generalmente ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_ESTRUCTURAS_DATOS_II,
            [
                '<strong>Arrays:</strong> Colección de elementos de una o varias dimensiones con un tamaño fijo y de un tipo especifico <strong>Aplicaciones:</strong> ',
                '  - Resultados de busquedas             - Sistemas GPS                  - Calendarios',
                '',
                '<strong>Colas:</strong> Siguen la estructura <em>FIFO</em>; primero en entrar, primero en salir <strong>Aplicaciones:</strong> ',
                '  - Atención de usuarios                - Mensajeria                    - Impresiones ',
                '',
                '<strong>Listas enlazadas:</strong> Son elementos separados formados de manera lineal, pero cada elemento contiene algun enlace del siguiente elemento, ',
                '- Tambien pueden enlazarse con el elemento anterior si son del tipo doblemente enlazadas <strong>Aplicaciones:</strong>',
                '  - Reordenación                        - Eliminación                   - Inserción ',
                '',
                '<strong>Pilas:</strong> Sigue la estructura <em>LIFO</em>; ultimo en entrar, primero en salir, solo se puede ingresar/eliminar elementos, no permite busquedas <strong>Aplicaciones:</strong>',
                '  - Acciones tipo Undo/Redo             - Evaluación de expresiones     - Backtracing ',
                '',
                '<strong>Arboles:</strong> Estructura de datos jerararquica, que consta de nodos conectados, no tienen relaciones ciclicas ',
                '- Cada nodo solo tiene un camino de acceso, facilitando las busquedas y las modificaciones <strong>Aplicaciones:</strong>',
                '  - Sistemas de archivos                - Inteligencia Artificial       - Enrutamiento de redes',
                '  - Indexación de bases de datos        - Compiladores                  - Compresión de datos  ',
                '',
                '<strong>Grafos:</strong> Consta de Vertices(nodos) conectados mediante aristas que pueden ser caminos con una sola dirección o bidireccioneales ',
                '- La dirección los convierte en Grafos Dirigidos o No dirigidos respectivamente <strong>Aplicaciones:</strong>',
                ' - Modelado de relaciones              - Analisis de redes              - Redes sociales',
                ' - Sistemas de recomendación           - BD No relacionales ',
                '',
                '<strong>Hash Tables:</strong> Almacen de datos de tipo clave-valor de manera que facilitan su busqueda y permiten crecer de manera dinamica ',
                '- Especialmente utiles cuando los valores son grandes y/o complejos, a los cuales se les aplica una funcion hash para identificarlos ',
                '- Hay datos que siendo diferentes pueden generar hashs repetidos(colisiones), aunque sea improbable hay formas de solventarlo <strong>Aplicaciones:</strong> ',
                ' - Cache                               - Motores de busqueda         ',
                ' - Detección de duplicados             - Cifrado/descifrado de datos ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_SEARCH_AND_SORT,
            [
                '- Son herramientas para resolver calculos matematicos complejos y estan intrinsecamente relacionados con la informatica ',
                '- <em>Es una secuencia de instrucciones que describe una forma de resolver un problema especifico en un periodo de tiempo finito</em> ',
                '',
                '<strong>- Diagramas de flujo:</strong> Es una representación visual del control de un algoritmo ',
                '<strong>- Pseudocodigo:</strong> Es una representación textual que se aproxima al codigo fuente original ',
                '',
                '<strong>Algoritmos de ordenamiento:</strong> Colocan los elementos del conjunto en un orden determinado, ASC, DESC, Alfabetico, etc... ',
                '',
                '<strong>- Bubble Sort:</strong> Recorre la lista que esta ordenando y compara los elementos adyacentes y los intercambia si estan en el orden incorrecto ',
                '<strong>- Complejidad temporal</strong> Peor: Θ(n*n) - Mejor: Θ(n)',
                '',
                '<strong>- Selection Sort:</strong> Es una combinación de busqueda y ordenación, colocando los elementos en la posición adecuada ',
                '<strong>- Complejidad temporal</strong> Θ(n2) - <strong>Espacio Auxiliar:</strong> Θ(1)',
                '',
                '<strong>- Insertion Sort:</strong> Recorre la lista consumiento un elemento de entrada a la vez y construye una nueva version ya ordenada al final ',
                '<strong>- Complejidad temporal</strong> Peor: Θ(n) - Mejor: Θ(n)',
                '',
                '<strong>- Quick Sort:</strong> Algoritmo de ordenamiento rapido y recursivo, que funciona con un pivote el cual usa divide y venceras con cada parte, de manera sucesiva ',
                '<strong>- Complejidad temporal</strong> Peor: Θ(n2) - Mejor: Θ(n log(n))',
                '',
                '<strong>- Merge Sort:</strong> Tambien es recursivo y funciona con el principio divide y venceras, solo que aca las listas individuales se combinan despues, ',
                ' - y los elementos se insertan o se fusionan en el lugar correcto de la lista ',
                '<strong>- Complejidad temporal</strong> Θ(n log(n))',
                '',
                '<strong>Algoritmos de Busqueda:</strong> Una acción comun en las operaciones de negocio, la cual devuelve un conjunto de elementos segun las propiedades solicitadas ',
                '',
                '<strong>- Busqueda Lineal ó secuencial:</strong> Es la forma de buscar más simple, donde se busca uno a uno el elemento ó hasta que llegue al final de la secuencia ',
                '- Es un algoritmo de fuerza bruta, ineficiente para grandes volumenes de datos con una complejidad temporal de Θ(n)',
                '',
                '<strong>- Busqueda Binaria:</strong> Teniendo una conjunto de datos ya ordenados, se divide la colección en mitades iguales, ',
                ' - se escoge la mitad en que probablemente este y el proceso se repite hasta que se reduzca a la mitad donde deberia estar, complejidad temporal de Θ(log n)',
            ]),
        new Item(Keys.META_ESTRUCTURAS_HOMOICONICIDAD,
            [
                '- Es una propiedad que comparten algunos lenguajes de programación en los cuales el propio lenguaje, se puede manipular y comportarse como un dato más ',
                '- La representación primaria de esto tambien es una estructura de datos en un tipo primitivo del lenguaje ',
                '<strong>Ventajas:</strong> ',
                '- Extender el lenguaje con nuevos conceptos es más sencillo ',
                '- Los datos pueden ser pasados entre capas, como lo son la capa base y meta del programa ',
                '- Permite realizar operaciones de manipulacion de codigo en tiempo de compilación en vez de ejecución ',
                '- Se puede modificar el arbol de sintaxis del lenguaje ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_MAQUINA_ESTADOS,
            [
                '- Es una modelización conceptual en forma de diagrama de un problema ',
                '- En esta situación siempre se encuentra un inicio, el cual es la espera de un estimulo ',
                '- Esto nos da una base para modelar problemas que pueden ser sustancialmente complejos, además de extensos ',
                '- Este sistema "simple" y en casos trivial, evoluciono para ser parte fundamental de la informatica y de la electronica ',
                '',
                '<strong>Estados:</strong> Posición/acción donde se encuentra actualmente y de la cual puede saltar a otro estado, o a si mismo, impulsado por una acción/resultado concreto ',
                '<strong>Entradas:</strong> Interacciones o acciones que pueden alterar un estado y hacerlo cambiar a otro ',
                '<strong>Salidas:</strong> Acciones con las cuales el estado responde despues de ser previamente alterado ',
                '<strong>Eventos:</strong> Son las acciones o interacciones que puede tener un estado, internas o externas ',
                '<strong>Transiciones:</strong> Caminos que se pueden tomar entre estados, estos deberian estar acotados, y comprobar que las condiciones se dan para realizar el cambio',
                '',
                '&bull; <strong>Maquina de Mealy:</strong> Genera la salida en base a su estado actual y la entrada recibida ',
                '&bull; <strong>Maquina de Moore:</strong> La salida solo depende del estado actual y la entrada solo funciona como el activador ',
                '',
                '<strong>Pasos para su construcción</strong>',
                '- Para realizar estos esquemas lo primero es definir las entradas, salidas y sus estados ',
                '- Despues se realiza una tabla donde se definen las relaciones entre estos (estado, entrada) -> salida',
                '- Finalmente se grafica teniendo en cuenta las entradas y salidas de cada estado ',
                '- Si se llegan a complicar o extender demasiado, se pueden realizar simplificaciones mediante algebra de Boole',
                '',
                '- Generalmente se contempla el estado general de <strong>error</strong> al que cualquier estado puede transicionar si el estado rechaza la entrada o faltan transiciones ',
                '- El estado de <em>error</em> suele estar implícito en cualquier diagrama pero no se incluye visualmente, ya que interrumpen el flujo normal al ser una excepción ',
                '- Estos errores son terminales y no se deben confundir con los estados de "error", transiciones o interacciones propias del autómata'
            ]),
        new Item(Keys.META_ESTRUCTURAS_SISTEMAS_COMPLEJOS,
            [
                '<strong>Caracteristicas:</strong>',
                '<strong>- Comportamiento impredecible:</strong> Son sensibles a las condiciones iniciales ',
                '<strong>- Conectividad:</strong> Los subsistemas se afectan mutuamente, aun sin conexión directa ',
                '<strong>- Auto organización:</strong> Tendencia constante de generar patrones de comportamiento ',
                '<strong>- Jerarquia:</strong> Cualquier cambio de una jerarquia, afectara a esta ',
                '<strong>- Contexto-dependientes:</strong> Los sistemas varian para adaptarse al medio externo ',
                '<strong>- Historico-dependientes:</strong> El tiempo es un factor muy importante a tener en cuenta ',
                '<strong>- Irreductubilidad:</strong> La estructura o no se puede, o es muy dificil de reducir a estados más simples',
                '<strong>- Dialogicos:</strong> Los opuestos no se excluyen, se complementan ',
                '<strong>- Recursivos:</strong> Las causas y los resultados se alternan en el tiempo ',
                '<strong>- Hologrametricos:</strong> Hay identidad estructural entre las partes y su todo ',
                '',
                '<strong>Principios:</strong>',
                '<strong>- Equifinidad:</strong> Los estados finales son alcanzables sin importar las condiciones iniciales ',
                '<strong>- Heterogeneidad auto organizacional:</strong> La complejidad aumenta en medida que se interactua con la entropia del entorno ',
                '<strong>- Complejidad organizada:</strong> Los sistemas abiertos conjugan complejidad y orden ',
                '<strong>- Abundancia organizacional:</strong> Las estructuras complejas, son encontradas con facilidad ',
                '<strong>- Teleologico:</strong> Finalidades especificas dependen de sistemas especificos ',
                '<strong>- Retroalimentación:</strong> Se pueden tener feedbacks positivos y negativos ',
                '<strong>- Complejidad jerarquica:</strong> A mayor complejidad, mayor jerarquización ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_FUNCIONES_LAMBDA,
            [
                '- Son una subrutina definida no enlazada a un identificador, tambien llamadas funciones anonimas o literales ',
                '- Suelen ser usadas como argumentos o contruir respuestas en funciones de orden superior ',
                '- Comunes en los lenguajes funcionales y/o multiparadigma y permiten desde expresiones simples hasta logica compleja con multiples instrucciones',
                '- Tambien son capaces de inferir los tipos de los parametros de entrada y ajustarse polimorficamente',
                '- Cualquier interfaz que defina exactamente un metodo abstracto, es una interfaz funcional y puede ser usada como una lambda ',
                '',
                '<strong>Lambda de expression</strong>  -> (parametros) => expression ',
                '<strong>Lambda de instruccion</strong> -> (parametros) => { sequencia de expresiones } ',
                '',
                '- Su sintaxis suele ser más concisa y combinada con otras caracteristicas como los Stream permiten el paradigma funcional en Java ',
                '- Tambien el uso de metodos por referencia, mejorar la manipulación de colecciones y simplificar fragmentos de codigo con clases anonimas '
            ]),
        new Item(Keys.META_ESTRUCTURAS_VALUE_OBJECTS,
            [
                '- Es apliamente usado en <strong>DDD</strong> (Domain Driven Design)',
                '- Estos son una modelación de un concepto en nuestro sistema, como pueden ser fechas, precios, monedas, cantidades, etc.. ',
                '',
                '<strong>Caracteristicas</strong>',
                ' - Estan concebidos para medir o describir un concepto en nuestro dominio, no son simplemente valores, sino que cumplen alguna función ',
                ' - Son inmutables y su construcción no debe ser demasiado compleja ',
                ' - Siempre son validos, y si no lo son deben de lanzar una excepción, se pueden usar constructores semanticos para facilitar su creación ',
                ' - No poseen identidad, por lo que su comparación se basa solamente en sus valores ',
                '',
                '<strong>Testing</strong>',
                ' - Testear un VO esta relacionado directamente a la complejidad de los valores que represente ',
                ' - Generalmente solo se validan sus valores y que sus operaciones no incumplan la inmutabilidad (side-effects)',
            ]),
        new Item(Keys.META_ESTRUCTURAS_DYNAMIC_PROGAMING,
            [
                '- Es una tecnica de programación informatica en la que un problema algoritmico se divide en subproblemas y los resultados se guardan, ',
                ' - y los subproblemas se optimizan para encontrar la solución general, generalmente relacionado con encontrar valores limites y optimizaciones ',
                '- Al tratarse de problemas largos y complicados almacenar los resultados en vez de calcularse cada vez es considerablemente más optimo ',
                '- Pero solo es aplicable cuando los problemas son dividibles y hay valores que se pueden repetir y/o necesitar en varios lugares (superpuestos)',
                '- La programación recursiva es una manera de optimizar algunos problemas que son solucionables mediante recursividad ',
                ' - sin contar con los problemas de esta, como el crecimiento desmedido de la pila de llamados y el uso de memoria poco optimizado ',
                '',
                '<strong>Ventajas:</strong>',
                '- Dividir los problemas más grandes en varios más pequeños y manejables',
                '- Permite almacenar y reutilizar los subproblemas',
                '- Facilita la depuración a la hora de buscar errores ',
                '- Reduce la complejidad temporal al no usar recursividad y optimiza el uso de recursos',
                '- Toma decisiones del alcance de los subproblemas, para que sean reutilizables y decide como se combinaran ',
                '',
                '<strong>Algoritmos principales</strong>',
                '<strong>- Algoritmos codiciosos:</strong> Son herramientas de optimización, optando por valores optimos locales que no necesariamente seran los globales ',
                '<strong>- Floyd-Warshall:</strong> Encuentra la ruta más corta entre todos los vertices en un grafo con pesos, ya sean dirigidos o no dirigidos ',
                '<strong>- Bellman Ford:</strong> Encuentra la ruta más corta entre desde un vertice fuente a un vertice destino ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_SERIALIZATION_DESERIALIZATION,
            [
                '- Son 2 conceptos importantes en la programación en general, que permiten que los objetos puedan ser almacenados, transmitidos y reconstruidos ',
                ' - ya sea para su persistencia, ser transmitidos a traves de una red o ser almacenados en un cache en memoria ',
                '',
                '<strong>Serialización:</strong> Un objeto tiene 3 caracteristicas principales, Identidad, estado y comportamiento, ',
                ' - La serialización es el proceso de convertir el estado(valor o datos) de un objeto en un flujo de bytes ',
                '',
                '<strong>Formatos:</strong> Se pueden usar diferentes formatos, como <em>Json</em> o <em>Xml</em> porque son formatos legibles y/o faciles de interpretar por otro sistema ',
                ' - o en cambio el <em>Binario</em> para temas de rendimiento al ser más rapidos de leer y escribir que aquellos basados en texto ',
                '',
                '<strong>Deserialización:</strong> Es justamente el proceso inverso, donde se toma este flujo de bytes y se convierte de nuevo en un objeto, como el original ',
                ' - para esto, existen librerias e implementaciones propias de los lenguajes',
                '',
                '<strong>Consideraciones:</strong> ',
                '<strong>- Rendimiento:</strong> Entre más complejo y/o grande sea el objeto, más costara Serializar o Deserializar para el sistema ',
                '<strong>- Plataformas y dependencias:</strong> Este proceso tambien depende en que se haga y que lenguaje, por lo que puede haber incompatibilidades ',
                '<strong>- Versiones:</strong> Los objetos cambian, se modifican con el tiempo, por lo que versiones más nuevas puede haber problemas entre versiones diferentes ',
                '<strong>- No serializables:</strong> En ciertos casos, hay objetos que no se pueden serializar, como identificadores de archivos o sockets ',
                '<strong>- Seguridad:</strong> Suplantar los flujos de bytes con fines malintencionados, puede exponer las vulnerabilidades de un programa ',
                '<strong>- Legibilidad:</strong> Los datos que se serializan generalmente no son legibles para los humanos, lo que dificulta la solución de problemas ',
                ' - directamente relacionados con los datos en este estado, ya sea en la transmision o el almacenamiento ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_DEPRECATION,
            [
                '- En Java, como en otros lenguajes es comun encontrar metodos o clases marcadas de esa manera, una clara indicación de que esta en desuso ',
                '- Muchos lenguajes conformen van evolucionando se optimizan o se corrigen, sin dejar de promover pero no garantizando la <em>retrocompatibilidad</em> ',
                '- En la practica sirven como advertencia para no usar los metodos ó clases deprecados, ya que esta marcados para ser removidos en proximas actualizaciones ',
                '- Esto tambien puede suceder en desarrollos propios y no solamente en librerias ó frameworks ',
                '- Posponer estos cambios puede obstaculizar el mantenimiento, crear riesgos de seguridad, problemas de rendimiento y acelerar la conversión a <em>Legacy Code</em>',
                '',
                '<strong>¿ Como mantener una base de codigo actualizada ?</strong>',
                '<strong>- Priorize:</strong> Los metodos deprecados a cambiar, en base a multiples factores como seguridad, uso, importancia y riesgos',
                '<strong>- Documentación:</strong> Generalmente cualquier deprecación tiene una o varias opciones por el cual cambiarlo y contempla posibles efectos segundarios ',
                '<strong>- Herramientas:</strong> Para encontrar posibles candidatos, además de buenas practicas como el analisis de calidad, Como <em>Digma</em> o <em>SonarQube</em>',
                '<strong>- Refactorización, pruebas y cambios incrementales:</strong> De esa manera no se convierte en una osadia que comprometa la estabilidad del codigo ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_LOGS,
            [
                '- Son etiquetas que indican la gravedad ó urgencia de los eventos que suceden en cualquier aplicación ',
                '- Ya sean mensajes para indicar el correcto funcionamiento ó advertencias para describir problemas y agregar información contextual ',
                '- Los logs se pueden remontar hasta el nacimiento de la informatica moderna, cuando en 1980 <em>Syslog</em> introdujo un marco estandarizado, ',
                ' - para el manejo de los niveles de acuerdo a su urgencia e impacto, en orden descendente de gravedad ',
                '',
                '<strong>emerg:</strong> El sistema esta inutilizado y requiere atención inmediata ',
                '<strong>alert:</strong> Se requieren acciones inmediatas para resolver un problema critico ',
                '<strong>crit:</strong> Condiciones Criticas para el sistema que demandan acciones para prevenir un fallo del sistema ',
                '<strong>error:</strong> Han sucedido errores que afectan la operación, pero son menos graves que las situaciones criticas',
                '<strong>warn:</strong> Problemas potenciales que pueden provocar errores ó comportamientos inesperados ',
                '<strong>notice:</strong> Condiciones normales pero significativas que pueden requerir de monitoreo ',
                '<strong>info:</strong> Mensajes que representan el correcto funcionamiento normal del sistema ',
                '<strong>debug:</strong> Información detallada con fines de depuración ',
                '',
                '- Frameworks modernos han reconocido la importancia de los logs y perfeccionarón el concepto, más no significa que sea un estandar ',
                '- Estos niveles de logs pueden ser diferentes entre los lenguajes, pero su significado no se altera ',
                '- Tambien se ha de tener cuidado con su uso, que aunque idealmente no interferieren con el sistema, tambien consumen ',
                ' - ancho de banda, CPU, Memoria, Disco, etc...',
                '- El volumen de logs se puede descontrolar si no se establece un nivel base adecuado, hasta el punto de degradar el rendimiento ',
                ' - y genera ruido que ayuda a enmascarar problemas de fondo si no se filtran los logs verdaderamente relevantes ',
                '- Los logs tambien pueden ser cambiados de manera dinamica, en casos donde se necesita más información de manera instantanea ',
                '',
                '<strong>FATAL:</strong> Reservado para los problemas más graves y que requieren accion inmediata ',
                '<strong>ERROR:</strong> Indican condiciones erroneas que evitan ó dañan alguna operación',
                '<strong>WARN:</strong> Suelen ser advertencias y la aplicación debe estar en capacidad de seguir funcionando ',
                '<strong>INFO:</strong> Captura eventos importantes de manera que denotan un correcto funcionamiento ',
                '<strong>DEBUG:</strong> Ayudan a idenficar errores ó problemas durante la sesión de depuración/desarrollo ',
                '<strong>TRACE:</strong> Diseñado para rastrear rutas de ejecución a nivel de codigo y obtener aun más detalles ',
                '',
                '<strong>¿ Como usarlos ?</strong>',
                '<strong>Filtros y busquedas:</strong> Son un valioso mecanismo para limitar el analisis a niveles de gravedad y eventos relevantes, ',
                ' - asi se prioriza las areas que requieren atención debido a su complejidad o importancia para el negocio ',
                '<strong>Alertas:</strong> Pueden activar mecanismos de alerta y notificación para abordar eventos criticos de formas proactiva, ',
                ' - por ejemplo enviar correos a soporte cuando se detecten multiples errores en un intervalo corto de tiempo ',
                '<strong>Calculo de metricas:</strong> Ayudan al analisis del comportamiento de la aplicación en ausencia de herramientas más especializadas ',
            ]),
        new Item(Keys.META_ESTRUCTURAS_QUEUES,
            [
                '- La teoria de colas es el estudio matematico de las colas, usado para analizar y optimizar practicas de procesos como: ',
                '&bull; Capacidad de respuesta de servicio al cliente ',
                '&bull; La planificación Kanban de la gestión de proyectos ',
                '&bull; Colas de mensajes y comunicación entre procesos ',
                '&bull; Pipelines de implementación de DevOps ',
                '',
                '<strong>Tipos:</strong> Describen como la cola elige que elementos procesar ',
                '&bull; Primero en entrar, Primero en salir(FIFO): Procesar el elemento más antiguo ',
                '&bull; Ultimo en entrar, Primero en salir(LIFO): Procesar el elemento más reciente ',
                '&bull; Priorización: Los elementos se pueden escoger unos sobre otros de acuerdo al nivel o caracteristica que se defina ',
                '&bull; Tiempo compartido: Procesar a todos al mismo tiempo, la capacidad se distribuye equitativamente entre todos los que esperan ',
                '',
                '<strong>Tasa de utilización ρ = λ / μ</strong>',
                '&bull; λ Mide la velocidad con la que llegan nuevos artículos a la cola ',
                '&bull; μ Mide la velocidad con la que se procesan los elementos en la cola ',
                '&bull; ρ = 1 La tasa de llegada es igual a la tasa de servicio; la cola permanece del mismo tamaño ',
                '&bull; ρ > 1 La tasa de llegada es mayor que la tasa de servicio; la cola se está haciendo más grande ',
                '&bull; ρ < 1 La tasa de llegada es menor que la tasa de servicio; la cola se está haciendo más pequeña ',
            ])
    ];

export const MICRO_SERVICES =
    [
        new Item(Keys.MICROSERVICES_ANALISIS,
            [
                '- Un microservicio como componente de software que prioriza la modularidad y la escalabilidad, es importante que cumpla ciertas caracteristicas: ',
                '',
                '<strong>Principio de responsabilidad unica:</strong> Centrarse en una sola función, es un principio que aplica a multiples niveles en el desarrollo ',
                '- Gestionar multiples responsabilidades puede generar dificultades en el mantenimiento, su comprensión, y sus acciones ',
                '- La especialización trae grandes beneficios, desde una mejor comprensión, pasando por mejores tests, hasta un escalado más eficiente ',
                '',
                '<strong>Alta integración, Bajo acoplamiento:</strong> Es un principio de <em>POO</em>, pero tambien puede aplicarse para evitar Alto Acoplamiento, Baja Cohesión  ',
                '- Un acoplamiento estrecho genera fragilidad, haciendo que cualquier cambio en un microservicio interrumpa los servicios conectados ',
                '- La baja cohesión da lugar a responsabilidades poco claras y fronteras difusas ',
                '',
                '<strong>Escalabilidad y Resiliencia:</strong> Cualquier sistema debe ser capaz de gestionar picos de trafico y recuperarse de fallos ',
                '- Un sistema se diseña con esto en mente desde el principio, adaptandose a cualquier trafico y reduciendo tiempos de interrupciones ',
                '',
                '<strong>Autonomia y Evolución:</strong> Los ciclos de cambios, no se deberian ver ralentizados entre microservicios ',
                '- Que un microservicio implique cambios en otros ralentiza el desarrollo e inevitablemente complica el mantenimiento del sistema ',
                '- Un acoplamiento estrecho inhibe la evolución y capacidades de escalamiento creando cuellos de botella ',
                '',
                '<strong>Diseño evolutivo y mejora continua:</strong> Los sistemas deben adaptarse y evolucionar en pro de cubrir nuevas necesidades y expectativas ',
                '- Los sistemas se van refinando y adaptando constantemente, de lo contrario se volverian obsoletos e insostenible ',
                '',
                '<strong>Consideraciones:</strong>',
                '- Diseñar microservicios, es una maratón, no un sprint, estos principios son pautas que deben ser adaptados segun cada necesidad ',
                '- Aplicar estos principios ayuda a crear sistemas robustos, escalables y mantenibles, con el objetivo de brindar valor, y no solo crear codigo ',
            ]),
        new Item(Keys.MICROSERVICES_FUNDAMENTALS,
            [
                '- Los monolitos y los microservicios son de las arquitecturas más usadas, debido a que son conceptualmente simples ',
                ' - y que pueden ser adaptadas con facilidad a multiples contextos y necesidades',
                '- Pero los microservicios aunque son una opción muy prometedora, no siempre deben ser usados, ya que en ciertos casos, ',
                ' - suelen ser contraproducentes y van en contravia de lo que se necesita ',
                '',
                '- Para entender mejor cuando usarse, y cuando no, se daran unas pequeñas pautas para un mejor discernimiento ',
                '',
                '           <strong>Fortalezas</strong>                                         <strong>Debilidades</strong>           ',
                ' - Componentes independientes                    - Desarrollo y diseño más complejo         ',
                ' - Agiliza el conocimiento del negocio           - Dificultad para realizar testing         ',
                ' - Escalabilidad a la medida                     - Complejidad para el Monitoreo y registro ',
                '',
                '        <strong> Monolitico cuando</strong>                                 <strong>Microservicios cuando</strong>          ',
                ' - Equipo pequeño o inexperto                    - Equipo con experiencia y manejo de la nube ',
                ' - Aplicación simple y pocos requerimientos      - Se puede y se sabe descomponer el negocio  ',
                ' - Rapidez para lanzar el MPV                    - Aplicación compleja y con miras a crecer   ',
                '',
                '<strong>- Escalabilidad:</strong> De acuerdo al libro <em>The Art of Scalability</em>, se puede expresar como un cubo donde:',
                '<strong>Eje X:</strong> Duplicación horizontal, Donde la carga se distribuye entre n instancias creadas ',
                ' - Si n instancias son insuficientes, siempre se pueden crear más, teniendo en cuenta que el crecimiento no siempre es lineal ',
                '<strong>Eje Z:</strong> Partición de datos: El codigo fuente es identico en cada copia, pero la base de datos esta segmentada ',
                ' - Por lo tanto debe haber un componente capaz de enrutar las solicitudes, a quien tenga los datos indicados ',
                '<strong>Eje Y</strong> Descomposición funcional: La aplicación se divide en subsistemas más pequeños, que sean independientes entre si ',
                ' - Asi se puede escalar solamente las partes que tengan una alta demanda, sin aumentar todo innecesariamente ',
            ]),
        new Item(Keys.MICROSERVICES_BENEFITS,
            [
                '- Los microservicios son servicios implementables de forma independiente modelados en torno a un dominio empresarial(negocio) ',
                '',
                '<strong>Caracteristicas claves</strong>',
                '<strong>&bull; Despliegues independientes</strong>',
                '- Los cambios de un microservicio deberian ser independientes e implementables sin necesidad de involucrar a otros',
                '- Cambios pequeños permiten ciclos más rapidos y generan menos riesgos, sin tener que coordinar lanzamientos de multiples versiones ',
                '',
                '<strong>&bull; Enfoque en el dominio, la logica del negocio</strong>',
                '- Estos se deberian organizar en base a las capacidades empresariales, no por capas tecnicas ',
                '- Asi los cambios evitan en la medida de lo posible afectar a funcionalidades y servicios no relacionados ',
                '',
                '<strong>&bull; Gobierno de los datos</strong>',
                '- Al encapsular partes especificas del dominio, estos manejan la recuperación a traves de interfaces claramente definidas ',
                '- No existe una BD comun y cada servicio deberia ser propietario exclusivo de sus datos ',
                '- El modelo de datos interno puede cambiar sin afectar a otros, mientras proporciona una API estable para que los otros servicios accedan ',
                '',
                '<strong>&bull; Comunicación</strong>',
                '- Cada red de microservicios tiene necesidades diferentes, pero siempre seran sistemas distribuidos ',
                '- Se suelen usar peticiones API REST, Colas de mensajes, gRPC además de otras formas o protocolos segun cada necesidad ',
                '',
                '<strong>Beneficios claves</strong>',
                '<strong>&bull; Flexbilidad y adaptabilidad</strong>',
                '- Cuando los requisitos cambian, los cambios se pueden hacer de manera que solo los involucrados sean modificados ',
                '- Se pueden introducir nuevas capacidades como nuevos servicios sin interrumpir lo previamente existente ',
                '',
                '<strong>&bull; Diversidad tecnologica</strong>',
                '- Cada servicio es indpendiente de usar la mejor tecnologia y frameworks de acuerdo a sus necesidades, de manera que sea poliglota ',
                '- Esta flexibilidad permite escoger la mejor herramienta para el trabajo, en lugar de comprometerse bajo un enfoque unico ',
                '',
                '<strong>&bull; Desarrollo paralelo</strong>',
                '- Multiples equipos pueden trabajar simultaneamente sin interferir entre si, acelerando el trabajo en organizaciones grandes ',
                '- Cada equipo puede gestionar su propio calendario de lanzamientos, generalmente sin necesidad de tener que coordinarse con los demás ',
                '- Aca entra en acción la <em>Ley de Conway</em> que suele ser la forma como se estructuran los servicios o grupos de servicios relacionados ',
                '',
                '<strong>&bull; Alineación organizacional</strong>',
                '- Ayudan a alinear su arquitectura tecnica con su estructura organizativa, los servicios y aplicaciones nacen de acuerdo a las necesidades ',
                '- Se reducen los traspasos y costos de coordinación entre equipos, los limites son claros antes las responsabilidades ',
                '- En lugar de que la estructura de comunicación cree accidentalmente la arquitectura, se diseñan de manera deliberada los equipos ',
                ' - y servicios en función de las capacidades del negocio, generando estructuras y limites estables en el tiempo ',
                '',
                '<strong>Desafios a considerar</strong>',
                '<strong>&bull; Complejidad del sistema:</strong> La comunicación de la red no siempre sera perfecta, por eso existen estrategias de <strong>Tracing Distribuido</strong>',
                '<strong>&bull; Gastos operativos:</strong> Numerosos servicios que mantener, monitorizar, automatizar, descubrir, alertar, etc hace necesario tener una cultura solida de <strong>DevOps</strong>',
                '<strong>&bull; Consistencia de datos:</strong> Sin la seguridad de las transacciones de una BD, es necesario tener mecanismos de idempotencia, compensaciones y orquestación ',
                '<strong>&bull; Service Coordination:</strong> Procesos que parecen simples a primera vista, pueden convertirse en coreografias complejas, por lo que requieren un buen diseño ',
                '<strong>&bull; Migraciónes:</strong> Migrar de un monolito deberia hacerse solo si se justifica la sobrecarga y los costos, ya que estos bien diseñados suelen ser más estables ',
            ]),
        new Item(Keys.MICROSERVICES_ARQUITECTURAS,
            [
                '- Se pasa del concepto de un nucleo central y robusto a tener diferentes partes más pequeñas, ligeras y debidamente acotadas ',
                '- Esto permite que sean autonomos y su desarrollo no afecte generalmente el codigo de otros servicios ó funcionalidades ',
                '- Cada micro servicio esta diseñado de manera que pueda ser especializado, resolviendo problemas particulares con requisitos especificos ',
                '- Las partes se intercomunican entre si y funcionan de manera separada, aumentando la tolerancia a fallos ',
                '- Los servicios pueden ser independientes de las tecnologias, además de que tambien se pueden subdividir en caso de tener gran complejidad ',
                '- Tambien se pueden escalar/desescalar de manera individual optimizando el uso de recursos ',
            ]),
        new Item(Keys.MICROSERVICES_BEST_PRACTICES,
            [
                '- Los microservicios deben ser eficientes escalables y resilientes, para esto se deben tener lineamientos y seguir buenas practicas ',
                '',
                '<strong>Responsabilidad unica:</strong> Se deben enfocar en una sola función, la simplicidad mejora la mantenibilidad y la flexibilidad ',
                '',
                '<strong>Contenendores:</strong> Los contenedores como Docker, sirven para empaquetar e implementar aplicaciones de forma rapida, coherente y agil ',
                '',
                '<strong>Orquestación:</strong> Los contenedores se debe orquestar y relacionar, para que puedan ser escalables y facilmente administrables ',
                '',
                '<strong>Resiliencia y Tolerancia a fallos:</strong> Las fallas deben contenerse y manejarse de manera elegante, para evitar fallos criticos ',
                '- Implemente elementos como reintentos, circuit breakers, contingencias, con el fin de de garantizar la confiabiabilidad ',
                '',
                '<strong>Escalabilidad:</strong> Estos deben de crecer de manera independiente y segun las necesidades, ya sea de manera programada o reactiva ',
                '',
                '<strong>CI/CD:</strong> Elementos como testing, despliegues, analisis de calidad, builds pueden ser realizados por canales de Integración continua y Despliegue continuo ',
                '',
                '<strong>Observabilidad:</strong> Monitorear los micro servicios de manera que el logging y el tracing sean robustas y utiles para entender el comportamiento del sistema ',
                '',
                '<strong>Seguridad:</strong> Mecanismos como Autenticación, Autorización, cifrado, para proteger los datos y cumplir con las normas ',
                '',
                '<strong>API Gateway:</strong> Gestión y enrutamiento de las solicitudes, además de otras funcionalidades como balanceo de carga y mecanismo de seguridad ',
                '',
                '<strong>Stateless:</strong> Evite el manejo de estados en la medida de lo posible, permitiendo que cualquier instancia pueda manejar cualquier petición ',
                '',
                '<strong>BD per service:</strong> Cada microservicio debe se independiente, implicando que tenga su propia BD, evitando puntos de falla unicos ',
                '',
                '<strong>Event-Driven Architecture:</strong> Un enfoque basado en el manejo de eventos, permitiendo un menor acoplamiento y un manejo asyncronico de los eventos ',
            ]),
        new Item(Keys.MICROSERVICES_BY_DEFAULT,
            [
                '- Los monolitos no son malos, ni contienen codigo mal hecho, esto siempre sera responsabilidad de los desarrolladores a cargo ',
                '- Un punto que siempre va a estar en contra de los microservicios, es la capacidad para testearse de manera conjunta ',
                '- El alcance de una prueba es determinado por cuanto se puede testear en una sola prueba, entre menor sea el alcance, ',
                ' - más se alejara de la experiencia final del usuario ',
                '',
                '- En un monolito el scope(alcanze) es facil debido a que todo esta contenido dentro de una aplicación que hace todo ',
                '- En cambio en los microservicios, la complejidad del testing es directamente proporcional a sus relaciones y su funcionamiento en conjunto ',
                '- Para hacer estas pruebas es necesario en ciertos escenarios usar <em>dummies</em> o <em>mocks</em> que son equivalentes, más no iguales, al comportamiento real ',
                '',
                '- En cambio en un monolito este mismo conjunto de pruebas puede hacerse relativamente con menos esfuerzo y recursos ',
                '- Otro motivo en contra, es la infraestructura y la comunicación entre microservicios, que no deben ser ignoradas ',
                ' - ya que hacen parte fundamental del diseño de la aplicación, además de las complejidades inherentes que conllevan ',
                '',
                '- Un monolito no es mala idea, tampoco los microservicios, la gran diferencia es que no se deberian implementar en las primeras versiones ',
                '- La complejidad extra y las divisiones entre dominios, desviaran el foco real de la aplicación de prestar un servicio de calidad ',
                '- Realizar un monolito, permite que las necesidades y los requerimientos puedan madurar y evolucionar de manera natural ',
                '- Esto no evita que se pueda hacer un modelado que facilite una futura migración a microservicios, cuando sea necesaria ',
            ]),
        new Item(Keys.MICROSERVICES_TRADEOFFS,
            [
                '- El estilo arquitectonico de los microservicios no es la solución definitiva a los problemas, hay ocasiones donde pueden ser el problema ',
                '- Esto se debe a que hay tantas opciones y criterios a tener en cuenta, que lo que funciona para algunos equipos, puede derrumbar a otros ',
                '- Estos no estan exentos igual que muchas practicas y tecnologias de tener costos y beneficios implicitos y ocultos ',
                '',
                '<strong>Beneficios:</strong>',
                '<strong>Limites entre modulos:</strong>',
                '- Esta fuerte delimitación tambien se puede lograr en un monolito, pero aca se da de una manera más solida y es más dificil de eludir ',
                '- Especialmente util cuando el software crece, permitiendo que esta división facilite el mantenimiento y los cambios tengan un impacto menor ',
                '- Esto tambien depende de la disciplina de los equipos, ya que se puede copiar y pegar el codigo en vez de implementar librerias en comun ',
                '- Tambien aplican puntos como la <em>Ley de Conway</em> y que idealmente es mejor iniciar con monolitos y solo migrar despues de cierta maduración ',
                '',
                '<strong>Implementación Independiente:</strong>',
                '- La complejidad del negocio siempre va a estar presente, pero algo que ha ido cambiando con el tiempo es la forma de desplegar las aplicaciones ',
                '- Actualmente areas como <em>CD/CI</em> los despliegues suelen ser automatizados y tienen multiples mecanismos de recuperación ',
                '- Esto hace que los microservicios no deberian existir sin buenas practicas de <em>DevOps</em> y una infraestructura que lo soporte ',
                '',
                '<strong>Diversidad Tecnologica:</strong>',
                '- Al ser unidades tienen libertad para ser creadas y mantenidas por multiples equipos y usar el stack tecnologico más apropiado ',
                '- No estan atados a usar las mismas librerias, lenguajes ó bases de datos, si no que se escoge la mejor opción para cada requerimiento ',
                '- Esto le da un gran valor a la experimentación y su capacidad de encontrar mejores opciones para actualizar decisiones iniciales ',
                '',
                '',
                '<strong>Contras:</strong>',
                '<strong>Distribución:</strong>',
                '- Distribuir las funcionalidades y consultarlas para crear un proceso suele tener un rendimiento menor y problemas de latencia ',
                '- Los mecanismos para solventar este problema suelen cambiar la forma de la programación y darle un protagonismo que no es ideal a la infraestructura ',
                '- Tambien puede cambiar el diseño del sistema para que sea asincrono, una forma de programar cognitivamente más compleja y dificil de realizar ',
                '- Esto tambien hace que haya que tener más consideraciones y tener mecanismos de resiliencia ante las posibles fallas que se puedan presentar ',
                '',
                '<strong>Consistencia Eventual:</strong>',
                '- Además de ser un problema relacionado con la usabilidad ya que aunque exista un proceso <strong>Y</strong> en alguna parte que finalizo ',
                ' - la actualización de la información se realiza por el proceso <strong>X</strong> en otra parte del sistema, entonces el exito/fracaso no sera inmediato ',
                '- En algun momento todos los cambios se veran reflejados, pero siempre existira un lapso de tiempo en el que no se sabra que fue lo que paso ',
                '- Si los errores no son corregidos o observados esto inevitablemente terminara afectando al negocio junto a la coherencia/confibialidad de los datos',
                '',
                '<strong>Complejidad Operativa:</strong>',
                '- El usar unidades pequeñas e independientes es una gran ventaja para el desarrollo, pero esto se puede convertir en una presión adicional ',
                ' - ya que se multiplican la cantidad de acciones y funcionalidades que se deben observar y/o gestionar ',
                '- Tambien existe el riesgo de no eliminar la complejidad, simplemente se traslada a la intercomunicación entre servicios ',
                '- EL panorama general es más dificil de dislumbrar, la base de codigo esta repartida en multiples partes igual que las responsabilidades ',
            ]),
        new Item(Keys.MICROSERVICES_PATTERNS,
            [
                '<strong>Patron Saga:</strong> Proporciona una gestión eficaz de la transacciones, usando una secuencia de transacciones locales ',
                ' - de manera que todas las operaciones se puedan ejecutar, o se realizen acciones de compensación, para deshacer los cambios anteriores ',
                ' - todo esto de manera idempotente, para que se puedan autogestionar, sin intervención manual, esto se puede realizar de 2 maneras: ',
                '<strong> - Coreografia:</strong> Cada microservicio produce y escucha, y se comunican a traves de un canal en comun ',
                '<strong> - Orquestación:</strong> Un orquestador es el responsable de tomar las decisiones, y los servicios solo ejecutan ',
                '',
                '<strong>BD por microservicio:</strong> Cuando se reemplaza un monolito, por microservicios, una decisión importante es la de mantener o fragmentar la BD',
                ' - Mantener una sola BD es un beneficio a corto plazo, por lo que se puede optar por que cada servicio tenga una propia, o incluso compartida ',
                ' - Permitiendo que la aplicación sea más resiliente y escalable, al mismo tiempo que la persistencia puede llegar a ser poliglota ',
                '',
                '<strong>Agregador:</strong> Se refiere a un programa que recopila elementos relacionados y los muestra, ya sea despues de juntarlos y/o transformarlos ',
                ' - Esto permite escalar en varios ejes, y un unico acceso al que consultar, evitando sobrecargar a los modulos de manera individual ',
                '',
                '<strong>Event Sourcing:</strong> Define un enfoque impulsado por la secuencia de eventos, los cuales son constantemente registrados ',
                ' - Esto con el fin de obtener historicos y realizar acciones sobre estos, como notificar o realizar operaciones a los registros existentes ',
                '',
                '<strong>CQRS</strong> Util cuando solo existe una BD, por eso es necesario dividir la aplicación en 2 partes, Comandos y consultas ',
                '<strong> - Comandos:</strong> Manejan todo lo relacionado con la creación, Eliminación y actualización ',
                '<strong> - Consultas:</strong> Maneja las consultas y la obtención de datos ',
                ' - Esta separación garantiza, que se pueda recuperar o modificar información, pero no ambas acciones al mismo tiempo ',
                '',
                '<strong>API Gateway:</strong> Adecuado para multiples aplicaciones de tipo cliente, donde se entrega un unico punto de entrada al sistema ',
                ' - Esto minimiza la cantidad de llamdos necesarios entre el cliente y la aplicación además de ser seguro mediante sistemas de aunteticación ',
                '',
                '<strong>Circuit Breaker:</strong> Es una manera de proteger la aplicación, si se llegara a presentar un fallo catastrofico, que se convierta en una cascada ',
                ' - Este maneja 3 estados principales, y como si de una maquina de estados se tratase, controla el flujo de la aplicación ',
                '<strong> - Abierto:</strong> La solicitud falla y se devuelve una excepción, cerrando el acceso por un tiempo determinado ',
                '<strong> - Cerrado:</strong> Enruta las solicitudes y cuenta la cantidad de fallas, hasta que no pasen de un umbral ',
                '<strong> - Half-Open:</strong> Solo se permite un pequeño numero de operaciones, cambiando entre estados de acuerdo a si fallan o son exitosas ',
            ]),
        new Item(Keys.MICROSERVICES_ANTI_PATTERNS,
            [
                '<strong>Monolito en microservicios:</strong> Conservar una arquitectura monolitica encontrara inevitablemente multiples problemas como: ',
                '- Tolerancia a fallos, problemas de escalabilidad y una implementación más compleja debio a la codependencia entre equipos ',
                '- Bases de datos compartidas, esto dificultara el crecimiento de la aplicación además de convertirse en un punto critico si llega a fallar ',
                '',
                '<strong>Microservicios habladores:</strong> Los microservicios necesitan comunicarse entre si para poder funcionar, sin embargo esto no siempre es ideal ',
                '- Si es demasiado frecuente, ya sea por solicitudes de datos ó realizar tareas menores, se puede generar trafico en la red y retrasar otras respuestas ',
                '- Si las APIs y los Eventos son demasiados atomicos al punto de requerir multiples llamados para cualquier operación/transacción ',
                ' - se debe considerar que cada uno requiere procesamiento de serialización/deserialización que pueden generar operaciones bloqueantes ',
                '- Esto puede degradar en el punto de requerir una cadena entre multiples Microservicios en el que una sola falla afectara a los demás ',
                '',
                '<strong>Monolito Distribuido:</strong> Es una aplicación diseñada como un sistema distribuido, pero en realidad solo son multiples componentes ',
                '- Falta de autonomia de cada servicio, debido a que su equipo no es independiente frente a otros requisitos/funcionalidades desde otros equipos ',
                '- Si los componentes necesitan un estado compartido se debe tener en cuenta como se sincronizaran ',
                '',
                '<strong>Exceso de microservicios:</strong> Un error comun es pensar en divir todas las funciones incluso las simples, hasta tener demasiados ',
                '- Baja cohesión los microservicios individuales no tienen coherencia dentro del conjunto, solo complican su entendimiento ',
                '- Alto acoplamiento debido a las multiples interacciones e interdependencias entre servicios ',
                '',
                '<strong>Exceso de funcionalidades:</strong> Tambien existe la posibilidad de que los microservicios tengan demasiadas responsabilidades ',
                '- Ya sea por una planificación inadecuada ó un desconocimiento del negocio, las delimitaciones se vuelven difusas ',
                '- Mala interpretación de requisitos, haciendo que se introduzcan funcionalidades irrelevantes ó en componentes equivocados ',
                '',
                '<strong>Arquitectura Spageti:</strong> Es una arquitectura sin ninguna organización o división logica, solamente una maraña de componentes conectados ',
                '- El flujo de control es complejo y enrevesado, de manera que rastrear errores es un martirio ó se generan comportamientos impredecibles ',
                '- Acoplamiento indeseado al estar estrechamente conectados, cualquier modificación puede afectar otros componentes y asi empezar una ola de cambios ',
                '',
                '<strong>Falta de observabilidad:</strong> La aplicación no proporciona información adecuada sobre el estado internos y sus operaciones ',
                '- Logs limitados en especial a la hora de registrar errores o sucesos importantes, dificultando el seguimiento de los problemas ',
                '- Rastreo disperso ya que se carece de capacidades para rastrear el flujo de la solicitud entre los componentes involucrados ',
                '',
                '<strong>Ignorar el costo humano:</strong> Se centra tanto la necesidad de cumplir objetivos que generan plazos irreales ',
                '- El trabajo excesivo empieza a afectar la vida personal y el tiempo libre de los colaboradores, disminuyendo su productividad a larga ',
                '- Las capacidades del equipo no son tenidas en cuenta a la hora de planear los plazos y generan expectativas poco realistas ',
                '- Microgestión o falta de apoyo, ya sea por parte de los lideres o del mismo equipo respectivamente ',
            ]),
        new Item(Keys.MICROSERVICES_PRODUCER_CONSUMER_PROBLEM,
            [
                '- Es un problema clasico de sincronización en los sistemas operativos y sistemas que funcionan con eventos ',
                '- El problema se define de la siguiente manera, hay un buffer o cola de tamaño fijo, un productor y un consumidor ',
                '',
                '<strong>Productor:</strong> Crea un elemento "<em>mensaje</em>" y lo agrega al bufer compartido',
                '<strong>Mensaje:</strong> Contiene la información producida, ya sea en formato Json, Objetos, numeros, textos, etc.. ',
                '<strong>Consumidor:</strong> Extrae elementos del buffer y los procesa "<em>consume</em>"',
                '',
                '<strong>Condiciones:</strong>',
                '- El productor no debe producir un elemento si el medio compartido esta lleno ',
                '- El consumidor no debe consumir elementos si el buffer esta vacio ',
                '- El acceso al buffer compartido debe ser mutuamente excluyente; esto significa que cualquier instancia dada, ',
                ' - solo un proceso(consumidor/productor) dado debe poder acceder al buffer y hacer cambios sobre el (borrar/agregar)',
                '- En casos donde existan multiples productores y consumidores, un mismo mensaje puede ser procesado por varios consumidores ',
                '',
                '<strong>Semaforo:</strong>',
                '- Monitorear el espacio disponible en la cola/buffer despues de cada consumo/produccion',
                '- Rastrear el espacio y valida para que se puedan producir mensajes',
                '- Notifica que se han producido mensajes y pueden ser consumidos ',
                '- Permite un solo cambio en la cola de manera sincrona, aunque hay implementaciones que permiten concurrencia en ambos extremos '
            ]),
        new Item(Keys.MICROSERVICES_PRODUCER_CONSUMER_IDEMPOTENCY,
            [
                '- Manejar eventos inherentemente conlleva la posibilidad de duplicación y su manejo, ya que esto puede causar problemas en los consumidores ',
                '- Es normal que los eventos manejen un ID(hash, UUID, etc..), para procesos de identificación, esto con el fin de crear <em>consumidores idempotentes</em> ',
                '- La duplicación se debe manejar ya que hay procesos de negocio criticos y que son sensibles a operaciones duplicadas, especialmente operaciones bancarias ',
                '- La confirmación(<strong>ACK</strong>) puede no recibirse(red) en el broker de mensajeria, como el consumidor puede no realizar la confirmación del procesamiento ',
                '',
                '- El <strong>orden</strong> es importante para que los eventos sean procesados correctamente, pero los brokers o no lo garantizan, o lo hacen bajo condiciones especificas ',
                '- La garantia de entrega de <strong>Exactly-Once</strong> pareciera la mejor opción para evitar esta duplicación, pero esto tiene diversos puntos a tener en cuenta ',
                '- <strong>Reintentos y DLQ</strong> son importantes para evitar perder mensajes, pero pueden inducir multiples consumos repetidos, aumentan la complejidad del consumidor ',
                ' - y suelen tener tiempos exponenciales entre cada reintento, incrementando el tiempo de procesamiento ',
                '',
                '- Las <strong>Transacciones</strong> inician el momento en que se consume cada mensaje, esto evita inconsistencias pero agrega complejidad e impacta el rendimiento ',
                ' - las transacciones por si solas no evitan la duplicación, deben ser combinadas con procesos de negocio que lo validen ',
                '- El <strong>Patron Outbox</strong> es otra forma de crear transacciones, cubriendo el proceso completo de consumo-procesamiento-publicación-confirmación ',
                '- Tambien se puede aplicar <strong>Change Data Capture</strong> de manera que todos los datos(mensajes ya procesados) seran enviados consecuentemente mediante ',
                ' - un componente extra, diferente de la aplicación, sino un proceso general asociado que informa cualquier cambio en la BD <em>(insert, update, delete)</em> ',
                '',
                '- Tambien existen otras opciones como <strong>almacenar los ID</strong> de cada mensaje consumido, confirmando instantaneamente cualquier mensaje duplicado ',
                ' - estos almacenamientos deben estar debidamente optimizados(indices) e incluso pueden tener una politica de borrado de datos(<strong>TTL</strong>)',
                '- Usar un almacenamiento externo que permita busquedas <strong>clave-valor</strong> que sean resilientes y con una alta disponibilidad, como caches distribuidos o BD NoSQL, ',
                ' - estas no garantizan la consistencia y siempre suman tiempo, aunque suele ser minimo, ya que tienen latencias muy bajas y relativamente constantes ',
                '- Finalmente se puede tener en cuenta el enfoque tradicional, que es un <strong>upsert</strong> es la tecnica más simple y eficiente generalmente si no hay un gran <em>throughput</em> ',
            ]),
        new Item(Keys.MICROSERVICES_CACHE_FAILS,
            [
                '- Los caches son sistemas que ayudan a resolver problemas de rendimiento, reducir la latencia, además de otros beneficios ',
                '- Esto no los excluye de que puedan tener fallos ó generar problemas mientras se usan ',
                '',
                '<strong>Thunder Hurd Problem:</strong> Sucede cuando una gran cantidad de claves caducan al mismo tiempo, obligando a ir masivamente a la Base de datos',
                '- Una forma de solventarlo es aleatorizando la vida de los datos en el cache para que no caduquen en masa ',
                '- Permitir que solo los datos criticos puedan ir a la base de datos y el resto solo esperar hasta que se haga la copia en el cache ',
                '',
                '<strong>Cache Penetration:</strong> Sucede cuando el dato a buscar no existe en el cache ni en la BD, generando una sobrecarga en ambos sistemas ',
                '- Se pueden almacenar valores nulos para llaves inexistentes, evitando buscar en la BD ',
                '- Tambien se puede hacer un filtro de bloom y determinar si estadisticamente el dato puede existir en la BD, y solo en ese caso buscarlo ',
                '',
                '<strong>Cache Breakdown:</strong> Similar al <em>Thunder Hurd</em> pero aca solo sucede con uno o varios datos que son muy utilizados ',
                '- Conociendo estos valores, es conveniente tenerlas sin caducidad ',
                '',
                '<strong>Caidas:</strong> Por alguna razón el cache esta fuera de servicio y todas las solicitudes deben ir a base de datos ',
                '- Se puede usar un circuit breaker para evitar que los problemas se propagen aun más ',
                '- Configurar un cluster para mejorar la disponibilidad del cache ante imprevistos ',
            ]),
        new Item(Keys.MICROSERVICES_DISTRIBUTED_TRACING,
            [
                '- La computación en la nube, los microservicios, herramientas de codigo abierto y el uso de contenedores, ',
                ' - ha hecho que las aplicaciones cada vez sean más distribuidas y se vuelvan más complejas ',
                '- El rastreo distribuido sigue una interacción y la marca con un identificador unico, este identificador pertenece ',
                ' - con la transacción a medida que se va interactuando con los microservicios e infraestructura ',
                '- Esto genera desafios de colaboración interna, si una organización no podia identificar el microservicio afectado, ',
                ' - no podia determinar que solución aplicar ni como abordar el problema ',
                '',
                '<strong>Tipos de rastreo</strong>',
                '<strong>- Rastreo por codigo:</strong> Un desarrollador interpreta manualmente los resultados de cada linea de codigo dentro de una aplicación ',
                ' - Se monitorea los valores de una variable y sus cambios a traves de la ejecución, este metodo solo es idoneo para metodos pequeños y aislados ',
                '<strong>- Rastreo de datos:</strong> Realizan controles de precisión y calidad de los datos en elementos criticos ',
                '<strong>- Rastreo de programa:</strong> Proporciona un indice de las instrucciones ejecutadas y a que datos ha hecho referencia ',
                ' - ampliamente usado para mejorar codigo ó como mecanismo de depuración durante el desarrollo del software ',
                '',
                '<strong>Desafios:</strong>',
                '<strong>Instrumentación manual:</strong> Aunque esta pensando para ser automatico, hay algunas herramientas que requieren un trabajo adicional ',
                '<strong>Cobertura:</strong> No siempre adoptan un enfoque de extremo a extremo, por lo que las interacciones desde el front-end quedan ocultas ',
                '',
                '<strong>Trace &ne; Logs',
                '- Los logs son parte fundamental para poder registrar y realizar el seguimiento, esto en si es un arte ya que deben contener información suficiente, ',
                ' - sin llegar a ser grandes ni verbosos para evitar problemas de rendimiento ',
                '<strong>- Logs centralizados:</strong> Requieren un esfuerzo adicional para ser llevados desde la fuente hasta un almacenamiento compartido donde sean utiles ',
                '<strong>- Logs distribuidos:</strong> Sus fuentes son diversas y solo se buscan cuando son requeridos, evitando transportalos y almacenarlos ',
            ]),
        new Item(Keys.MICROSERVICES_DEAD_LETTER_QUEUE,
            [
                '- Una cola de mensajes no entregados es un componente esencial en los sistemas que usan colas de mensajes ',
                '- Sirve como area de retención para los mensajes que no se pueden entregar ó procesar debido a errores ',
                '- Esto evita interrumpir el flujo de la cola principal y almacena temporalmente los mensajes para darles el debido tratamiento ',
                '- Permiten que el sistema sea resiliente y confiable, sin necesidad de generar inactividad alguna ',
                '- Las <strong>Dead Letter Queue</strong> No son exclusivas de los sistemas de colas, tambien existen las <strong>Dead Letter Topic</strong> en Kafka ',
                '- Esto ayuda a mantener la integridad de los datos y no afectar el rendimiento con ciclos infinitos de reintentos ',
                '- Tambien ayudan al cumplimiento de requerimientos, y el analisis de fallos al segregar los registros problematicos ',
                '- Estas suelen tener alertas y son constantemente monitoreadas para dar una pronta solución a cualquier problema ',
                '',
                '<strong>Ciclo de Vida:</strong>',
                '<strong>- Llegada:</strong> Ingresa a esta cola despues de no haberse podido procesar correctamente ',
                '<strong>- Identificación:</strong> Administradores del sistema ó procesos automaticos identifican que causo el error ',
                '<strong>- Revisión:</strong> Determina si es un problema recurrente ó transitorio ',
                '<strong>- Reintentar:</strong> El proceso es reenviado a la cola principal, igual o cambios si es requerido ',
                '<strong>- Guardar/Descartar:</strong> Si ya no son relevantes, se archivan o se descartan segun el caso ',
                '<strong>- Monitoreo:</strong> El mensaje y su manejo son monitoreados para asegurar que se cumplan requisitos de auditoria ',
                '',
                '<strong>Estrategias para su implementación:</strong>',
                '- Configurar las colas principales redirijan automaticamente estos mensajes fallidos a su destino ',
                '- Establecer un maximo de reintentos previos al envio, para evitar sobrecargas con reintentos infinitos ',
                '- Alertas automaticas, para cuando llegan los mensajes para acelerar el tiempo de respuesta a errores ',
                '- Politicas de caducidad, los mensajes en esta cola no pueden acumularse de manera indefinida ',
                '- Registro de errores, de manera que este la mayor cantidad de información posible que ayude a resolver el problema '
            ]),
        new Item(Keys.MICROSERVICES_DISTRIBUTED_TRANSACTIONS,
            [
                '- Debido a la naturaleza distribuida de los microservicios, una de las desventajas de esta aproximación es la gestión de una transacción ',
                '- Generalmente cada microservicio tiene su base de datos separada, pero cuando una transacción requiere abarcar multiples de estos ',
                ' - se debe garantizar la consistencia en todos los involucrados, las transacciones distribuidas representan desafios claves como: ',
                '&bull; Mantener <strong>ACID</strong> ',
                '&bull; Aislamiento de las transacciones ',
                '&bull; Comunicación entre microservicios ',
                '&bull; Resiliencia & Idempotencia para los procesos ',
                '',
                '<strong>2PC:</strong> El protocolo de confirmación de 2 fases, es una alternativa para la implementación de transacciones distribuidas ',
                '- Presenta multiples problemas, como la incapacidad para operar con BD NoSQL y la dependencia del nodo central, aunque garantize la mejor consistencia ',
                '',
                '<strong>Patron Saga:</strong> Ya sea por orquestación o por coreografia, cada microservicio esta integrado en un orden concreto ',
                '- Ya sea un evento de confirmación ó un evento de compensación, cada microservicio es responsable de cumplir su parte de la secuencia ',
                '- Esta comunicación debe ser eficiente igual que las operaciones realizadas, ya que es necesario sumarles la latencia del uso de la red ',
                '',
                '<strong>TCC Protocol:</strong> Try-Confirm-Cancel, cualquiera de las transacciones puede empezar en cualquier fase sin orden aparente ',
                '- Try: Se coloca el recurso con un estado pendiente, hasta que no se confirme la posibilidad del siguiente paso o se agote el tiempo ',
                '- Confirm: Se valida el exito de la transacción o se reintenta hasta que sea necesaria una intervención manual para solucionar el estado ',
                '- Cancel: Invalida o revierte una transacción para volver al estado inicial y compensar todas las acciones realizadas ',
                '- Este protocolo es lento y obliga a tener implementaciones que lo soporten, incrementado la complejidad particular pero no la general ',
            ]),
        new Item(Keys.MICROSERVICES_PROBLEMS,
            [
                '- Los microservicios son una arquitectura moderna que tiene grandes ventajas, pero eso no los libra de tener problemas ya sea de diseño o de construcción ',
                '',
                '<strong>Definiciones:</strong> Aunque existen multiples definiciones, no hay una unica definición y algunas suelen hasta contradecirse ',
                '&bull; Un servicio con un numero reducido de lineas de codigo, ¿ Cuanto es reducido ? 100 lineas funcionales podrian ser consideradas como uno ?',
                '&bull; El equipo de 2 pizzas, tecnicamente no es una definición, pero si es una convención muy usada del tamaño de los equipos ',
                '&bull; Requiere un solo programador para ser construido y mantenido, de lo contrario no lo es ',
                '&bull; Procesos autonomos, autocontenidos y unicos ',
                '&bull; Una aplicación por contenedor, asi se permite la orquestación y la automatización de la infraestructura ',
                '&bull; Cada servicio tiene su propia base de datos ',
                '- Varias de estas ideas se superponen, pero no se llegan a integrar del todo, por lo que se tiene un escenario similar de <em>los ciegos y el elefante</em>',
                '- Todos describen correctamente algo, por lo que nadie esta equivocado, pero ciertamente no se alinean ',
                '- Es mejor hablar sobre desafios concretos y las compensaciones especificas, estos <em>no son un fin en si, sino un subproducto de un objetivo</em>',
                '',
                '<strong>Disciplina en el manejo de terminos en el software:</strong> Este problema va más alla de los microservicios, afecta a toda la industria en general ',
                '- Los terminos usan palabras complejas e impresionantes, que pueden diferir en su significado para cada persona, como: ',
                '&bull; DevOps: Un rechazo a la separación de los equipos de Desarrollo y de Operación, ahora se habla de equipos que solo son operaciones ',
                '&bull; Agil: Era un rechazo a comportamientos del software estaticos y burocraticos, para ahora asociarse a metodologias llenas de rituales ',
                '&bull; SRE: Buscaba incluir practicas de la ingenieria en las operaciones y la automatización para la confiabilidad, ahora son operaciones renombradas ',
                '&bull; Observabilidad: Era la capacidad para entender el estado de la aplicación a partir de resultados externos, ahora solo son tableros llenos de métricas ',
                '',
                '<strong>Las conversaciones son abstractas y no siempre giran sobre el negocio:</strong> Ciertas ventajas suelen perder de vista el problema a resolver ',
                '- Los microservicios mejoran la escalabilidad, para empezar ¿ cual es el cuello de botella actual ?',
                '- Hacen que las implementaciones sean más agiles, ¿ Porque son lentas en primer lugar ?',
                '- Permiten implementaciones independientes, esto ¿ Es un requisito o simplemente es una ventaja ?',
                '- Los microservicios reducen la carga cognitiva, ¿ Realmente lo hacen o solamente la desplazan y dividen en más partes ?',
                '- Realmente es necesaria una migración ? o ¿ Un monolito bien mantenido y estructurado es más que suficiente ?',
                '',
                '<strong>Cambio organizacional:</strong> Los microservicios no funcionan de manera aislada del contexto empresarial, estos se apegan a la cultura organizacional presente ',
                '- Los microservicios no funcionan de forma aislada, requieren que los equipos se estructure para que los respalden: ',
                '&bull; Equipos multifuncionales y autonomos de principio a fin, si existen cuellos de botella, como un solo equipo de infraestructura, seran cuellos de botella ',
                '&bull; Toma de decisiones descentralizada, si se necesita una cadena de aprobaciones, la independencia de los servicios es una ilusión ',
                '&bull; Una cultura de DevOps, CD/CI, Monitoreo y gestión de incidentes madura y automatizada, para manejar sistemas distribuidos ',
                '- Sin estos cambios o la voluntad para implementarlos, los microservicios solo empeorarán la situación y agregaran complejidad tecnica innecesaria ',
                '- Cambiar una estructura organizacional, es más complejo que cambiar de arquitectura, en especial entre más grande sea la empresa ',
            ]),
        new Item(Keys.MICROSERVICES_PUSH_PULL_EVENTS,
            [
                '- Cuando se habla de una arquitectura basada en eventos, el foco se basa en los eventos, su escalabilidad, flexibilidad, broker a usar, etc.. ',
                '- Pero la forma en que los consumidores reciben los eventos tambien es importante, esto se reduce a 2 formar principales para hacerlo <strong>push</strong> & <strong>poll</strong> ',
                '',
                '<strong>Push:</strong> Ideal para publicación y suscripción ya que los eventos se entregan en cuanto suceden a todos los suscriptores ',
                '<strong>Ventajas</strong>',
                '&bull; Baja latencia de extremo a extremo los consumidores reciben los eventos tan rapido como se producen ',
                '&bull; Sin sobrecarga de procesamiento al buscar eventos cuando no hay ',
                '&bull; Ideal para notificaciones o activación de flujos de trabajo ',
                '',
                '<strong>Desventajas</strong>',
                '&bull; Es dificil controlar el rendimiento, la carga puede ser mayor a lo que estas preparado ',
                '&bull; La dificultad para lograr un <em>backpressure</em> efectivo aumenta ',
                '&bull; Si el consumidor falla el broker es el encargado de reintentar o de gestionar los mensajes de las <strong>DLQ</strong> ',
                '',
                '<strong>Poll:</strong> Los consumidores extraen mensajes a su propio ritmo, teniendo la potestad de cuando y cuanto procesar ',
                '<strong>Ventajas</strong>',
                '&bull; Ideal para flujos de datos donde es importante el orden, o procesar por lotes con puntos de control ',
                '&bull; Un mejor control sobre factores como: rendimiento, concurrencia y reitentos ',
                '&bull; La logica de procesamiento es más robusta y tolerante a fallos ',
                '',
                '<strong>Desventajas</strong>',
                '&bull; Mayor latencia, en especial si el sondeo por mensajes nuevos es largo ',
                '&bull; Más componentes de infraestructura que administrar (shards, offsets, consumer groups, etc)'
            ]),
        new Item(Keys.MICROSERVICES_ESENTIAL_COMPONENTS,
            [
                '- Los microservicios han transformado la forma en que creamos aplicaciones escalables, modulares e independientes ',
                '- Tambien necesitan la combinación de infraestructura además de otros componentes esenciales para generar configuraciones robustas ',
                '',
                '<strong>API Gateway:</strong> El punto de entrada unico que oculta la intrincada red de servicios que existen ',
                '- Al ser un punto de entrada unificado puede tener responsabilidades como enrutamiento, equilibrio de carga, rate limiting, autenticación ',
                '',
                '<strong>Service Registry and Discovery:</strong> Al ser un entorno dinamico donde se puede escalar vertical y horizontalmente ',
                '- Manejar la comunicación por IPs o URL no es sostenible, por eso cada servicio se registra para que puedan ser facilmente consultados ',
                '- Esto evita problemas con el autoescalado, los health checks, y permite una comunicación entre servicios resiliente ',
                '',
                '<strong>Service/Domain Layer:</strong> Cada microservicio es una unidad autonoma con una tarea especifica ',
                '- Generalmente estan construidas con frameworks y lenguajes establecidos que ayuden a su estabilidad ',
                '',
                '<strong>Autorización:</strong> La seguridad es esencial, en especial cuando los servicios se comunican entre si y/o exponen algunas APIs',
                '- Este garantiza que solo los usuarios o servicios autorizados puedan interactuar con puntos finales sensibles, reduciendo la superficie de ataque ',
                '&bull; Administrar la identidad(usuarios, roles, ambitos) ',
                '&bull; Emitir y validar tokens de acceso ',
                '&bull; Cumplimiento de politicas y control de acceso ',
                '',
                '<strong>Persistencia y manejo de datos:</strong> Cada microservicio deberia tener su base de datos, esto es una buena practica y evita el acoplamiento estrecho ',
                '- Esto permite escoger el mejor motor de acuerdo a las necesidades además de poder evolucionar esquemas de forma independiente sin perder los limites ',
                '',
                '<strong>Cache:</strong> Para evitar consultas redundantes y reducir la latencia mientras se disminuyen las cargas de los servicios y la red subyacente ',
                '- Los caches no solo ayudan a acceder datos con mucha frecuencia, tambien funcionan para el manejo de sesiones, rate limiting y manejo de tokens ',
                '',
                '<strong>Comunicación asincrona y uso de eventos:</strong> No todas las interacciones requiere de una respuesta inmediata ',
                '&bull; Envio de notificaciones                  &bull; Procesos pesados y/o demorados ',
                '&bull; Registro de eventos y analitica          &bull; Tareas programadas',
                '&bull; Transacciones por lotes y/o etapas ',
                '',
                '<strong>Metricas & Observabilidad:</strong> No se puede arreglar lo que no se puede observar y aun menos medir ',
                '- Se pueden recopilar metricas de:         - Para comprender el sistema y depurar problemas como:',
                '&bull; Cantidad de solicitudes                  &bull; Degradaciones en los tiempos de procesamiento ',
                '&bull; Tasa de error y tipos de error           &bull; Alertas de anomalias o aumento de errores ',
                '&bull; Latencia                                 &bull; Establecer y verificar el cumplimiento de SLA (Niveles de Servicio)',
                '',
                '<strong>Agregación & Visualización de logs:</strong> Son uno de los primeros insumos a revisar cuando suceden problemas ',
                '- Como los servicios suelen ejecutarse en multiples instancias, estos deben estar centralizados de manera que permitan buscar de forma eficiente ',
            ]),
        new Item(Keys.MICROSERVICES_EVENTS_VS_REQUEST_RESPONSE,
            [
                '<strong>Reactividad VS Control</strong>',
                '- Una Arquitectura basada en eventos no necesita un director, estos reaccionan ante los eventos con el comportamiento esperado ',
                '- Un sistema Request-Response toda interacción requiere una orquestación explicita y requieren de una conversación continua, incluso ruidosa ',
                '',
                '<strong>Acoplamiento, infierno de dependencias:</strong> Los servicios requieren saber mucho de otros VS Solo necesitar el formato de los eventos ',
                '&brvbar;      <strong>Request-Response</strong>      &brvbar        <strong>Arquitectura Basada en eventos</strong>       &brvbar; ',
                '&brvbar; Endpoints del API          &brvbar; Formato de los eventos                      &brvbar; ',
                '&brvbar; Formatos de solicitud      &brvbar; Versionamiento                              &brvbar; ',
                '&brvbar; Estructura de la respuesta &brvbar; Sin necesidad de conocer al productor       &brvbar; ',
                '&brvbar; Disponibilidad             &brvbar; Múltiples consumidores sin relación directa &brvbar; ',
                '',
                '<strong>Consistencia eventual VS Inmediatez</strong>',
                '- En un sistema Request-Response es más consistente, pero aun asi la copia datos entre sistemas puede inducir a errores ',
                '- Muchos procesos comerciales no son inmediatos, por lo que se considera un impedimento directo para el comportamiento del negocio ',
                '',
                '<strong>Gestión del estado e historico de datos</strong>',
                '- Kafka permite devolverse en el tiempo de acuerdo al historial que permanezca en el topic ',
                '- Bases de datos tradicionales sobreescriben los datos, borrando versiones anteriores si no se tiene una buena auditoria ',
                '',
                '<strong>Flexibilidad en la construcción</strong>',
                '- Agregar funcionalidades y suscribirse a eventos es más facil, cada flujo de eventos es un bloque de construcción reutilizable ',
                '- Cada integración mediante Request-Response requiere diseño, pruebas y un tiempo minimo de integración, siendo robusto pero más demorado ',
                '',
                '<strong>Acceso y reutilización de datos:</strong>',
                '- Los eventos son datos en estado puro, pueden alimentar una gran cantidad de procesos con un solo tipo de evento publicado ',
                '- Request-Response son ideales para proporcionar datos a los usuarios, pero no para tareas de analisis o que requiera acceso masivo a datos ',
                '',
                '',
                '&brvbar;            <strong>Eventos si...</strong>             &brvbar;                    <strong>Request-Response si...</strong>               &brvbar; ',
                '&brvbar; Necesita servicios desacoplados      &brvbar; Necesita respuestas inmediatas                          &brvbar; ',
                '&brvbar; La resiliencia es muy importante     &brvbar; El sistema es simple y con limites claros               &brvbar; ',
                '&brvbar; Los datos son reutilizables          &brvbar; El equipo sigue aprendiendo sobre sistemas distribuidos &brvbar; ',
                '&brvbar; Se permite la consistencia eventual  &brvbar; La consistencia y fiabilidad de los datos es esencial   &brvbar; ',
            ]),
        new Item(Keys.MICROSERVICES_ARQUITECTURE_BACK_MONOLITH,
            [
                '- El monolito es una de las formas más basicas y tradicionales de construir aplicaciónes, que suelen ser bases gigantescas de codigo ',
                '- Esto propicia que los componentes esten estrechamente entrelazados, ya que no necesitaban las complejidades de un sistema distribuido ',
                '- Eran sencillos de operar y de implementar a costa de carecer de flexibilidad y agilidad ante el cambio ',
                '',
                '- Esta arquitectura continua vigente en el mundo tecnologico actual, siguen existiendo situaciones donde puede brillar ',
                '&bull; Velocidad de entrega y simplicidad   &bull; Facilidad de depuración ',
                '&bull; Pruebas de concepto                  &bull; Rendimiento en operaciones sencillas',
                '',
                '<strong>Problemas de los monolitos</strong>',
                '&bull; Dificil de escalar, entre más grande más retos implica ',
                '&bull; La base de codigo es vulnerable a errores, en especial si existen multiples personas trabajando sobre el proyecto ',
                '&bull; Bloqueo tecnologico, una vez se escoge el conjunto de tecnologias a usar, migrarlas o cambiarlas se vuelve dificil ',
                '&bull; Entre más grande sea la aplicación cada vez se vuelve más real el miedo de realizar un cambio y romperlo todo ',
                '&bull; Una posible degeneración del proyecto en una gran bola de lodo(Big Ball of Mud) ',
                '',
                '<strong>Problemas de los microservicios</strong>',
                '&bull; Coordinación de sistemas distribuidos y una infraestructura solida que la respalde ',
                '&bull; Latencia y fallos de red que deben ser contemplados y/o reintentados ',
                '&bull; La consistencia eventual, transacciones distribuidas y la duplicación de datos son temas del dia a dia ',
                '&bull; Tolerancia y seguimiento de fallos, rastrear un problema puede involucrar a multiples servicios y bases de codigo ',
                '&bull; Se puede generar un <em>monolito distribuido</em> si no se generan limites adecuados o se comparte una misma BD ',
                '',
                '<strong>Caso de estudio:</strong> Amazon Prime Video empezo con una arquitectura de microservicios pero los costos de infraestructura ',
                ' - se sobredimensionaron por lo que se volvio a un monolito evitando transferencia de datos innecesarias, reduciendo los costos en un 90% ',
                '',
                '<strong>¿ Porque volver a un monolito ?</strong>',
                '- Resulta extraño que empresas que nacieron de esta forma o se migrarón, esten dando un paso atras, pero existen razones para hacerlo ',
                '<strong>Complejidad operativa:</strong> Su gestión individual, comunicación entre servicios, orquestación, monitarización, todo eso y más debe ser controlado ',
                '<strong>Costos generales:</strong> La infraestructura robusta y todo lo necesario para una alta disponibilidad no suele ser barato (Twitter)',
                '<strong>Coordinación del equipo:</strong> Si la comunicación no es eficaz o los servicios estan muy fragmentados un <em>monolito modular</em> suele ser mejor (Shopify)',
                '<strong>Latencia:</strong> Siempre esta presente, incluso cuando es minima puede resultar en una reducción del rendimiento considerable ',
                '<strong>Sobreingenieria:</strong> Hay soluciones que no necesitan ser altamente escalables ni ser distribuidas, solo estar disponibles (Dropbox)',
            ])
    ];
