import * as Keys from '../keys';
import { Item } from "../models";

export class Content2 {

    public temas: Item[] = [
        ...TESTING,
        ...TESTING_ADVANCED,
        ...ANALISIS,
        ...BUENAS_PRACTICAS,
        ...COMPILACION,
        ...HISTORIAS_USUARIO,
        ...METODOLOGIAS,
    ];

}

export const TESTING =
    [
        new Item('principios',
            [
                '- Las pruebas demuestran la presencia de defectos, por ende entre más pruebas halla mejor ',
                '- Es improductivo hacer pruebas exhaustivas, ademas de que es casi imposible de hacer ',
                '- Las pruebas tempranas ayudan a encontrar defectos con prontitud, y a su vez reducir tiempo y costos ',
                '- Agrupar defectos permite que las soluciones sean más especializadas, y las pruebas sean más efectivas ',
                '- La paradoja del pesticida, si nuestro software cambia, las pruebas tambien deben hacerlo, que sigan funcionando no siempre es buena señal ',
                '- Las pruebas dependen del contexto, entre más se parezca el entorno de pruebas al entorno de producción mejor ',
                '- Que no se presenten errores no significa que no existan errores, solo que no se han dado las condiciones ',
            ]
        ),
        new Item('manifiesto',
            [
                '- El testing no es una fase más, siempre debe estar presente en todo el desarrollo ',
                '- La calidad no depende solo de las pruebas, es un proceso constante durante todo el ciclo de vida ',
                '',
                '- Testing inicial <strong>SOBRE</strong> testing final ',
                '- Prevenir bugs <strong>SOBRE</strong> encontrar bugs ',
                '- Entender que se prueba <strong>SOBRE</strong> probar una funcionalidad ',
                '- Construir un mejor sistema <strong>SOBRE</strong> destruir el sistema ',
                '- Responsabilidad del equipo <strong>SOBRE</strong> la responsabilidad del tester ',
            ]),
        new Item('tiposPruebas',
            [
                '<strong>Funcionales:</strong> Prueban las funcionalidades del sistema y suelen ser de caja negra, al validar el <strong>QUE</strong> más que el <strong>COMO</strong> ',
                '',
                '<strong>No Funcionales:</strong> Estas validan cosas como carga, estres, rendimiento, confiabilidad, etc... ',
                '',
                '<strong>Estructurales:</strong> Indagan la estructura interna del programa y sus relaciones, aca se pueden incluir las pruebas unitarias y de integración ',
                '- Estan son de tipo caja blanca, ya que es necesario conocer todo el sistema y como funciona para que sean bien planificadas ',
                '',
                '<strong>Regresión:</strong> Se vuelven a correr todas la pruebas despues de que se cambien componentes ó se corrigen errores ',
                '- Dependiendo de la cantidad de pruebas que hayan y de su complejidad puede ser una operación demorada, por lo que suelen estar automatizadas ',
                '',
                '<strong>Pruebas de rendimiento:</strong> Se ponen a prueba factores como velocidad, desempeño, estres, confiabilidad ante grandes cargas de trabajo',
                '',
                '<strong>Pruebas de usabilidad:</strong> Se evaluan diferentes aspectos en terminos de aprendizaje y operatividad para el usuario final '
            ]
        ),
        new Item('beneficios',
            [
                '- La calidad mejora al encontrar errores en etapas previas y durante el desarrollo, en vez de hacerlo en etapas finales ',
                '- Los cambios son hechos de manera más agil al inducir una mayor comunicación con todo el equipo ',
                '- Reducen el tiempo y los costos asociados a la mantenibilidad del software ',
                '- Los tests pueden tener documentación la cual no debe ser muy extensa, y tambien pueden servir como documentación ',
            ]),
        new Item('nombramiento',
            [
                '- Representa el intercambio de mensajes entre los diferentes componentes del sistema para lograr una funcionalidad ',
                '- El tiempo es importante ya que un mensaje debe terminar para que otro empieze (generalmente) ',
                '- Los objetos que interactuan puede ser simple clases, hasta modulos y sistemas completos ',
                '- El diablo esta en los detalles, saber nombrar los elementos que intervienen ayudara al analisis ',
                '',
                '<strong>Clases:</strong> Deben tener un indicador que las agrupe, como: <em>nombreClase</em><strong>Test</strong> ',
                '<strong>Metodos:</strong> Hay varias convenciones, pero generalmente deben incluir:  ',
                ' - nombre del metodo, estado a probar, comportamiento esperado; tambien se pueden incluir las palabras de given, when, should, test  ',
                '<strong>Variables:</strong> Deben describir el proposito de cada variable, no deben ser resumidas ni genericas, algunos ejemplos pueden ser: ',
                ' - target, expected, actual, valid, invalid, Object(Mock)',
            ]),
        new Item('first',
            [
                '<strong>Fast:</strong>            Deben ser rapidos, ya que se suelen tener cientos de pruebas y ejecutarlas conlleva tiempo y recursos ',
                '<strong>Independent:</strong>     Cada test debe ser independiente de los demás, de lo contrario habra un acoplamiento no deseado ',
                '<strong>Repeatable:</strong>      Las pruebas deben funcionar en cualquier ambiente que se ejecuten, ya sea local o en un ambiente de integración ',
                '<strong>Self-Validating:</strong> Las pruebas deben mostrar resultados concluyentes, estos no deben tener intervención humana para que sean validos ',
                '<strong>Timely:</strong>          Toda prueba debe ser oportuna y debe tener una razon de ser, si no se pueden justificar, estas habran sido una perdida de tiempo ',
            ]),
        new Item(Keys.TESTING_DATA_SUT_DOC,
            [
                '- Es un competencia basica para empezar a realizar testing, de cualquier tipo, donde se define claramente que se esta probando y que necesita',
                '',
                '<strong>System Under Test:</strong> Es aquello que se esta probando ya sea una clase, un componente, una funcionalidad, etc..',
                ' - Cada prueba deberia tener solamente un <strong>SUT</strong> y asi limitar la complejidad y el mantenimiento de cada test ',
                '',
                '<strong>Depend On Component:</strong> Es lo que necesita cada SUT para poder funcionar, y generalmente suelen tener una relación de 1-1 o 1-n',
                ' - Un <strong>DOC</strong> idealmente es pequeño y limitado, ya que se puede considerar un reflejo directo del diseño de nuestro sistema ',
                ' - Si este cuenta con un gran numero de dependencias, el sistema tambien cuenta con muchas responsabilidades y se deberia desacoplar un poco más ',
                '',
                '<strong>- Organización:</strong> Generalmente se organizan mediante una tabla que contiene el tipo de prueba, los SUTs y los DOCs ',
            ]),
        new Item(Keys.TESTING_MOCKS,
            [
                '- Son objetos que se comportan de manera igual que el elemento que copian, pero son más simples de manejar ',
                '- Tambien incluyen mecanismos para verificar los comportamientos que se estan simulando',
                '',
                '<strong>Dummy:</strong> Es un objeto con valores concretos que solo sirve para que se cumplan ciertas precondiciones, sin un comportamiendo adyacente alguno ',
                '<strong>Fake:</strong>  Son funcionales y se comportan igual que en producción, solo que de una manera más simple y limitada ',
                '<strong>Stub:</strong>  Es un objeto que ya viene con una información predefinida, en vez de información real e impredecible ',
                '<strong>Mock:</strong>  Son objetos que actuan de acuerdo a una llamada en especifico, de lo contrario no funcionaran debidamente para las pruebas ',
                '<strong>Spies:</strong> Este objeto se encarga de visualizar sin interferir todos los procesos y llamados internos, para verificar que sean los deseados ',
            ]),
        new Item('aaa',
            [
                '<strong>Arrange:</strong> En esta parte se organiza todo lo necesario y se deben establecer las condiciones del test ',
                '<strong>Act:    </strong> Es la ejecución del fragmento a testear, invocando al metodo en cuestión ',
                '<strong>Assert: </strong> Ultimo paso de la prueba y es la comprobación de lo resultados o comportamientos esperados ',
            ]),
        new Item('gwt',
            [
                '- Funciona de la misma manera que AAA, con algunas ventajas <strong>Given, When, Then</strong>',
                '- Puede ser usado con frameworks de BDD, es más que solo una estructura',
                '- Es obicuo por lo que más personas pueden entenderlo sin necesidad de un conocimiento completo del sistema ',
                '- Añade valor extra al negocio, al interconectar el codigo y las pruebas a un nivel mayor ',

            ]),
        new Item(Keys.TESTING_PIRAMIDE,
            [
                '     <em>Exploratorias/Humo</em>      <strong>Piramide de tests:</strong>',
                '         GUI  Tests          La mayor parte de las pruebas deberian ser unitarias',
                '       API      Tests         y la menor deberian ser de la interfaz grafica',
                '     Integration  Tests       seguidas de integracion/componentes de alto nivel',
                '   Component       Tests   ',
                ' Unit               Tests  ',
                '',
                '     <em>Exploratorias/Humo</em>      <strong>Cono de helado:</strong>',
                ' GUI                Tests    Es un anti patron de pruebas donde la mayoria de pruebas',
                '   API             Tests      son de la interfaz grafica y NO pruebas unitarias',
                '     Integration  Tests       ',
                '       Component Tests        ',
                '         Unit   Tests      ',
                '',
                '     <em>Exploratorias/Humo</em>      <strong>Tipo Cigarrillo:</strong>',
                '         GUI Tests           Poco o nada de ningun tipo de test ',
                '         API Tests            centrando el grueso en pruebas manuales ',
                ' Integration Tests            dificiles de automatizar y de mantener ',
                '   Component Tests',
                '        Unit Tests',
            ]),
        new Item('triangulo',
            [
                '         Alcance              <strong>Alcance:</strong> Requisitos ó tareas a realizar              - personas  - alcance   + tiempo ',
                '                                                                   ',
                '         Calidad              <strong>Tiempo:</strong> Planificación de la duración del proyecto    - tiempo    - alcance   + costos ',
                '                                                                      ',
                '   Costo         Tiempo       <strong>Costos:</strong> Recursos a gastar el proyecto                + alcance   + tiempo    + costos ',
            ]),
        new Item('cobertura',
            [
                '- La cobertura del codigo es fundamental para garantizar un alcance optimo de las pruebas ',
                '- No hay un numero magico para todos los proyectos, cada uno tendra una cobertura ideal',
                '- El 100% de esta cobertura no es garantia de ausencia de errores, como el 50% no es garantia de la calidad de las pruebas ',
                '- Esto es importante ya que se puede usar para hacer despliegues e integración continua, y encontrar codigo muerto ',
                '- Existen varios tipos de cobertura, pero el más usado es la cobertura de las lineas de codigo ',
            ]),
        new Item('falsos',
            [
                '- Son problemas comunes en ambientes inestables, ó poco hermeticos ',
                '- Tambien estan directamente relacionados con probar detalles directos de la implementación y no los comportamientos importantes ',
                '',
                '<strong>Falso Positivo:</strong> Ocurre cuando se detectan defectos, que no son culpa del componente inmediato ',
                ' - Esto puede ser debido a fuentes externas de error, inestabilidad del ambiente, errores de los datos ',
                '',
                '<strong>Falso Negativo:</strong> Ocurre cuando no se detectan errores, que estan presentes en lo que se esta probando ',
                ' - Suelen suceder por pruebas mal desarrolladas, más que por el propio entorno ',
            ]),
        new Item('QAperson',
            [
                '- <strong>Quality Assurance</strong> Es un concepto donde todos los involucrados deben aportar, aunque haya personas especificas para verificar su cumplimiento ',
                '- Todo proyecto deberia contar con un plan de pruebas que asegure la calidad del proyecto entregado ',
                '- La integración continua y los tests son herramientas con las que el proyecto deberia contar desde su inicio ',
                '- El encargado de estos aspectos debe ser el intermediario entre los clientes y sus espectativas y lo que ha sido elaborado ',
                '- Tambien es el encargado de crear ambientes de prueba que sean similares al ambiente de producción ',
            ]),
        new Item(Keys.TESTING_DATA_CREATION,
            [
                '- Crear datos para los tests, es una parte importante, ya que un buen set de datos, son la base de pruebas exitosas y confiables ',
                '- Mejoran la legibilidad de los casos, al separar la creación de datos de la logica de la prueba ',
                '- Permiten la flexibilidad y la reutilización de codigo, además de mejorar la mantenibilidad de las pruebas ',
                '',
                '<strong>Patron Object Mother:</strong> Es una forma sencilla de crear datos, este implica crear un unico objeto que contenga todas, ',
                ' - las propiedades y metodos necesarios para crear los datos de prueba',
                '',
                '<strong>Patron Test Data Builder:</strong> Es una forma más organizada y flexible de crear los datos de prueba, implica crear un constructor ',
                ' - para cada objeto, y metodos personalizados para modificar sus propiedades o crear copias a su conveniencia ',
            ])
    ];

export const ANALISIS =
    [
        new Item('comportamiento',
            [
                '- Estos modelos se usan para describir a profundidad el comportamiento de un sistema ',
                '',
                '<strong>Flujos de datos:</strong> Modelan el procesamiento de los datos del sistema, no solo sirven para saber las entradas y salidad del sistema ',
                '- Tambien para validaciones con los usuarios y que estos validen los datos y los procesos a nivel interno',
                '',
                '<strong>Maquinas de estado:</strong> Modelan la reacción del evento en cuanto a los estimulos externos/internos ',
                '- Estos indican los posibles estados de un sistema, y que puede suceder cuando paso un estimulo en especifico ',
                '- Se usan para sistemas en tiempo real mas que todo, ya que estos son sumamente dependientes de su ambiente ',
                '- Para sistemas grandes se recomienda usar diferentes niveles de estados de mayor a menor complejidad ',
            ]),
        new Item(Keys.ANALISIS_ANALISIS_DOMAIN,
            [
                '- Estudio de los dominios de conocimientos de las sociedades ',
                '- De esta manera el enfoque socio-cognitivo no es el unico usado para la toma de información ',
                '- Tambien se ha de tener en cuenta el contexto presente y lo que motiva sus acciones ',
                '- Esto tambien da un conocimiento más profundo del entorno, y una mayor calidad de la información recolectada ',
            ]),
        new Item('case',
            [
                '- Ingeniería Asistida por Computador, que es el desarrollo y mantenimiento de proyectos de software por medio de herramientas de software ',
                '',
                '<strong>- Documentación: </strong> Crea documentos de cualquiera de las etapas del proyecto y para diferentes tipos de personas; como DrExplain',
                '<strong>- Configuración: </strong> Son utiles para el control de versiones y la evolución del software; como Git',
                '<strong>- Diseño:        </strong> Ayudan a la creación de la estructura del programa y de su desglose para detallarlos y refinarlos; como Star UML ',
                '<strong>- Analisis:      </strong> Ayuda a cumplir con los requisitos al analizar los diagramas por posibles falencias, omisiones ó redundancias; como casecomplete ',
                '<strong>- Implementación:</strong> En esta categoria se encuentran los IDEs como Eclipe y herramientas para hacer prototipos; como Mockup Builder',
                '<strong>- Pruebas:       </strong> Son herramientas para realizar pruebas de software como y aumentar la calidad; como Jmeter',
                '<strong>- Mantenimiento: </strong> Sirven para documentar errores y seguimiento de defectos; como HP Quality Center ',
            ]),
        new Item('divide',
            [
                '- Generalmente es una tecnica aplicada a algoritmos, pero puede usarse en ambientes de mayor embergadura ',
                '- Suelen se problemas capaces de descomponerse en subproblemas y ser resueltos de manera recursiva ',
                '',
                '<strong>Divide: </strong> Dividir el problema en subproblemas más pequeños ',
                '<strong>Vence:  </strong> Resolver los problemas de manera individual y de manera acotada ',
                '<strong>Combina:</strong> Las soluciones de los subproblemas en la solución del problema original ',
            ]),
        new Item('diseño',
            [
                '- Un buen analisis desemboca en un buen Diseño (generalmente) ',
                '- Esta etapa es fundamental para llegar a una solución optima que cumpla los requisitos Funcionales y NO Funcionales ',
                '- Tambien se basa en la creatividad y experiencia de los profesionales a cargo, por lo que siempre existiran diseños mejores ó peores ',
                '',
                '<strong>Entendimiento de los requisitos:</strong> Sean funcionales o NO funcionales estos deben ser claros y sin ambiguedades ',
                '<strong>Usar patrones de diseño:</strong> No reinventes la rueda, sabiendo que hay soluciones a tus mismos problemas, documentadas y confiables ',
                '<strong>Calidad:</strong> Esta debe ser un objetivo a alcanzar en tu proyecto, no una fase más ',
                '<strong>Modularidad:</strong> Al ser modular esto facilitara la reutilización y que las futuras modificaciones afectan el menos codigo posible ',
                '<strong>A la medida:</strong> El diseño puede crecer y cambiar de acuerdo a las especificaciones de cliente, no necesariamente debe nacer completo ',
                '<strong>Documentación:</strong> La documentación debe existir en cualquier proyecto, para ayudar a la compresión del sistema, sea a nivel general ó especifico ',
            ]),
        new Item('crc',
            [
                '- Ayuda a los equipos a entender los procesos de una manera más facil y concisa ',
                '- Al tener todos las posibles parte del sistema a la disposición se reduce la redundancia y se asignan mejor las responsabilidades ',
                '- Es ideal hacer esto mediante una lluvia de ideas, donde todos participen ',
                '- Cuando hay demasiadas tarjetas, estas empiezan a añadir complejidad al entendimiento del modelado, ',
                '- En caso de que se empiecen a acumular, se desarrollaron los casos de uso, y explorar diferentes flujos y especializaciones ',
                '',
                '<strong>Clase:</strong> Nombre de la clase en si, el cual debe ser diciente y que ayude a entender el porque de su creación ',
                '<strong>Responsabilidad:</strong> Cual es la función ó funciones de la clase, entre más especifica mejor ',
                '<strong>Colaborador:</strong> Son otras clases ó entidades que son necesarias para el correcto funcionamiento de la clase ',
            ]),
        new Item(Keys.ANALISIS_AVESTRUZ,
            [
                '- Es una estrategia donde se ignora un problema, en vez de buscar una solución para este ',
                '- Esto es debido a la premisa de suponer de que son problemas increiblemente raros ',
                '- Al ser problemas raros, es más costoso y complejo evitar que sucedan a controlarlos cuando suceden ',
                '- Además de que se agregaria complejidad extra por un esceneario poco probable y que no necesariamente es critico ',
                '- Generalmente esto sucede con la asignación de recursos por parte del Sistema Operativo ',
            ]),
        new Item(Keys.ANALISIS_MODEL_DOMAIN,
            [
                '<strong>Dominio:</strong> Es el problema que quieres resolver, reglas de negocio, procesos, subtareas, etc...',
                '- Para dominios complejos y altamente conectados, probablemente se deba dividir en subdominios acotados y claramente definidos ',
                '',
                '<strong>Modelo:</strong> Es la abstracción de la realidad, en el contexto determinado, para darle solución al problema en cuestión ',
                '- Tambien suele estar acompañado de alguna descripción o imagenes que especifiquen alguna función, estructura o comportamiento ',
                '',
                '<strong>Modelo de Dominio:</strong> Organización y estructura de todo el conocimiento acerca del problema, sus partes, actores, relaciones, alcance, etc...',
                '- Se debe colocar en el foco la logica de negocio, que sera el nucleo(core)',
                '- Es de construcción grupal y colaborativa, teniendo en cuenta partes tecnicas y expertas del negocio'
            ]),
        new Item('timeComplexityBigO',
            [
                '- Un algoritmo es una secuencia logica de pasos, para resolver un problema especifico ',
                '- Debido a esto, suelen haber diferentes formas de hacerlo para un mismo problema, diferiendo en la forma pero no el resultado ',
                '- Tambien debe exisitir una manera de medir, su consumo de recursos, eficiencia y tiempo ',
                '- Aca es donde se introduce la notación <strong>Big O</strong>, que funciona para realizar estimaciones segun los datos introducidos ',
                '- Esta mide la eficiencia del algoritmo en función de la complejidad en el tiempo-espacio, representandose de manera algebraica ',
                '- Al estar directamente ligada al tamaño de la entrada, se suele hablar de tiempo, y sus implicaciones en los recursos del sistema ',
                '',
                '  - Constante: O(1)         -> Mejor     - Cuadrático: O(n^2)  -> Horrible',
                '  - Logarítmico: O(log n)   -> Bueno     - Exponencial: O(2^n) -> Horrible',
                '  - Lineal: O(n)            -> Justo     - Factorial: O(n!)    -> Peor    ',
                '  - Logarítmico: O(n log n) -> Malo                                       ',
                '',
                '- Estas mediciones estan relacionados con el numero de instrucciones y sentencias de control del algoritmo ',
                ' - <strong>Constante:  </strong> Solo se tiene una instrucción, por lo que no importa el tamaño de los datos ',
                ' - <strong>Lineal:     </strong> Suelen darse cuando existen ciclos, a mayor tamaño, mayor tiempo ',
                ' - <strong>Logarítmico:</strong> Tambien depende del tamaño de la entrada, pero en este con cada iteración el tamaño crece o decrece ',
                ' - <strong>Cuadratico: </strong> Un buen ejemplo son 2 ciclos anidados, donde cada ciclo se ejecutara n veces ',
                ' - <strong>Exponencial:</strong> Cada iteración hace crecer el conjunto de datos, como puede ser la secuencia Fibonacci recursiva ',
            ]),
        new Item(Keys.ANALISIS_KPI_OKR,
            [
                '<strong>Indicadores claves de desempeño - KPI:</strong> Son una evolución de las metricas para alinearse con objetivos estrategicos ',
                '- En cualquier proyecto es esencial definir las metricas y alinearlas con los objetivos comerciales y las metas de IT',
                '- No son lo mismo que los <strong>OKR</strong> donde la meta es el objetivo y solo se mide el progreso ',
                '- Su uso puede ayudar a medir aspectos no calificables, utiles para aspectos esenciales, como la nube',
                '- Establecer un KPI puede ser dificil, ya que es necesario comprender que datos se pueden medir, cuando se capturan, donde y como usarlos ',
                '- Una vez se hayan escogido las metricas y los KPIs de utilidad, tambien se pueden combinar en un tablero para su analisis ',
                '',
                '<strong>Objetivos y Resultados claves - OKR:</strong> Combinan los objetivos de negocio con un conjunto de metodos medibles a corto o largo plazo ',
                '- A diferencia de los <strong>KPI</strong> los resultados se pueden medir de diversas formas y no necesariamente de forma cuantitativa ',
                '- Funcionan como un marco para la definición de objetivos, ya sean metas ambiciosas o facilmente alcanzables ',
                '- Aunque pueden funcionar individualmente, tambien se pueden combinar con otros OKR de diferentes areas ',
                '',
                '&brvbar;            &brvbar;             <strong>OKR</strong>              &brvbar;               <strong>KPI</strong>                &brvbar;   <strong>Objetivo:</strong> Introducir la capacidad de respuesta de IT',
                '&brvbar; Definición &brvbar; Objetivos concretos con      &brvbar; Metricas que indican el progreso &brvbar;   <strong>KPI:</strong> Disminución del tiempo de comercialización',
                '&brvbar;            &brvbar;  componentes medibles        &brvbar;  de los objetivos de negocio     &brvbar;   <strong>Metrica:</strong> Tiempo para provisionar una VM o una nueva Instancia',
                '&brvbar;------------------------------------------------------------------------------&brvbar;              ',
                '&brvbar;    Base    &brvbar; Basado en misiones y         &brvbar; Basado en resultados anteriores  &brvbar;   <strong>Objetivo</strong> Mejorar nuestra tasa de retención de clientes',
                '&brvbar;            &brvbar;  aspiraciones                &brvbar;  y proyectos actuales            &brvbar;   <strong>Resultado</strong> Implementar un programa de recompensas por fidelidad',
                '&brvbar;------------------------------------------------------------------------------&brvbar;              ',
                '&brvbar; Criterios  &brvbar; Mide objetivos más audaces   &brvbar; Mide la estabilidad y            &brvbar;',
                '&brvbar;            &brvbar;  y agresivos                 &brvbar;  los puntos de referencia        &brvbar;',
                '&brvbar;------------------------------------------------------------------------------&brvbar;              ',
                '&brvbar; Proposito  &brvbar; Herramienta motivacional     &brvbar; Evaluación de rendimiento        &brvbar;',
                '&brvbar;------------------------------------------------------------------------------&brvbar;              ',
                '&brvbar;  Duración  &brvbar; Trimestual o anual           &brvbar; Variable                         &brvbar;',
                '&brvbar;------------------------------------------------------------------------------&brvbar;              ',
                '&brvbar; Variación  &brvbar; Los objetivos cambian        &brvbar; Metricas sin alteración por      &brvbar;',
                '&brvbar;            &brvbar;  cada ciclo                  &brvbar;  meses o años                    &brvbar;',
            ]),
        new Item(Keys.ANALISIS_MANIFEST_REACTIVE,
            [
                '- En la ultima decada, los requerimientos de las aplicaciones, cambian de manera constante y acelerada ',
                '- Los tiempos de espera son cada vez menores, las largas pausas por inactividad ya no son tolerables ',
                '- Los datos ya se miden en Peta y no en Gigas y su procesamiento no se puede detener ',
                '- Todas estas necesidades se deben satifacer, de manera que el software sea <em>Reactivo</em>',
                '- Siendo más flexible, con bajo acoplamiento, escalables y faciles de desarollar/mantener además de que sus fallos no sean catastroficos ',
                '',
                '<strong> Los sistemas Reactivos son:</strong>',
                '<strong>- Responsivos:</strong> El sistema responde en la menor cantidad de tiempo posible, y de manera consistente ',
                '<strong>- Resilientes:</strong> El sistema sigue respondiendo, aun frente a diversos fallos, ya que estos se deben manejar sin comprometer al todo ',
                '<strong>- Elasticos:  </strong> El sistema debe continuar respondiendo con diferentes niveles de carga, evitando cuellos de botella Y sabiendo como crecer ',
                '<strong>- Orientado a mensajes:</strong> Los sistemas reactivos confian en el intercambio de mensajes asyncronos, ya sea para funcionar y/o delegar fallos, ',
                ' - esta comunicación debe tener estrategias para ser No-bloqueante e implementar back-pressure para no desperdiciar recursos ',
            ]),
        new Item(Keys.ANALISIS_DECLINE_DESIGN,
            [
                '- El diseño es una actividad intrinseca para crear cualquier producto, por eso es que esta presente en todo y en todas partes ',
                '- Tambien el espacio que nos rodea, moldea nuestros habitos para consumir, nuestros paisajes urbanos, y nuestra forma de movernos ',
                '- <i>Don Norman</i> autor de <strong>The design of Everyday Things</strong> define el diseño como: ',
                '- <em>La practica que se preocupa por como funcionan las cosas, como se controlan y la naturaleza de la interacción entre las personas y la tecnologia</em>',
                '- El diseño no es exclusivo de las cosas cotidianas, existe el diseño industrial, el diseño de las interfaces de usuario (UI) o el diseño grafico ',
                '- Un mal diseño es como una <strong>"Puerta Normanda"</strong> que tiene el cartel de empujar, pero una manija que por instinto se tomara para jalarla ',
                '- Esto no es culpa del usuario, es culpa de un diseño ambiguo y poco pulido ',
                '- Este libro es una gran ayuda para trabajadores y diseñadores involucrados con la tecnologia ',
                '- El diseño se debe centrar en el ser humano y se deben tener en cuenta 5 pasos: <strong>Empatizar</strong>, <strong>Definir</strong>, <strong>Idear</strong>, <strong>Prototipos</strong>, <strong>Iterar</strong>',
                '',
                '<strong>Cuando el diseño funciona naturalmente</strong>',
                '- El senderismo es una actividad ideal para los habitantes de las ciudades, para que estos se vuelvan a conectar con la naturaleza ',
                '- Una buena ruta de senderismo se siente natural, aunque haya sido construida artificialmente, y tiene varios puntos en comun: ',
                ' - Se puede sostener por un largo periodo de tiempo, con una afectación minima al ecosistema ',
                ' - Es directa y en caso de no serlo cuenta con pocos desvios ',
                ' - Genera sensaciones de riesgo, de manera controlada ',
                '',
                '<strong>¿ Para quien se diseña ?</strong>',
                '- Las innovaciones tambien pueden traer problemas raciales, ya sea por fallas de diseño, o falta de grupos más grandes de prueba ',
                ' - Dispensadores de jabon racistas, debido a que tenian problemas al detectar la luz infrarroja reflejada, por personas con la piel oscura',
                ' - Face ID, que no era capaz de diferenciar a los usuarios chinos entre si',
                ' - Google photos, y su reconocimiento de imagenes, llego a etiquetar fotos de personas negras como primates, un nivel peor que los anteriores ',
                '- Es increible pensar que empresas tan grandes y con tantos recursos hallan cometido errores tan graves, por mas innovador que sea el producto, ',
                ' - no se deben dejar de lado los pasos 4 y 5, además de probar con muestras grandes y variadas, para compensar los posibles sesgos ',
                '- El punto ciego del diseño, siempre sera los diseñadores, ya tambien son personas, con sesgos e ideas que afectan sus decisiones ',
                '',
                '<strong>La sordida religion de arreglar el mundo</strong>',
                '- El diseño se ha convertido en algo que se puede "enseñar" y han surgido decenas de negocios alrededor de esto ',
                '- <strong>Rebbeca Ackermann</strong> Describe como democratizar el diseño pudo haber sido un error, estos nuevos innovadores y disruptores ',
                ' - a menudo no estan con contacto con la realidad, y carecen de experiencia conceptual para inspirar un cambio verdadero ',
                '',
                '<strong>Cuando el diseño falla</strong>',
                '- La arquitectura hostil, como bancos contra personas sin hogar, o la segregación de comunidades ',
                '- El diseño falla cuando los diseñadores estan cegados por sus propios prejuicios, politicas o interese corporativos ',
                '- El mundo del diseño, deberia ser mas diverso y tener en cuenta posibles efectos no intencionados e intencionados con las comunidades marginadas ',
            ]),
        new Item(Keys.ANALISIS_OPINIONATED_NO,
            [
                '- En era recientes y desde la existencia de Software como Servicio<strong>(SaaS)</strong> el desarrollo de software se enfrenta a 2 decisiones importantes ',
                ' - crear algo generico que permita al usuario decidir que utilizar y como, o desarrollar algo que guie al usuario hacia una determinada manera ',
                '- Antes de la nube las soluciones de software se negociaban y creaban como demandaba del usuario, para lo que necesitara el usuario ',
                '- Con la llegada de la nube y del SaaS posteriormente, se reflexiono si la mejor idea erar crear flujos de trabajo especializados y eficientes o ',
                ' - crear soluciones más generales y por consiguiente flexibles; en si mismo, vender servicios generios o especializados ',
                '',
                '<strong>Sin opiniones:</strong>',
                '- El usuario tiene toda la capacidad de tomar sus decisiones, proporcionando diferentes maneras de realizar una misma tarea ',
                '- Aca se decidira la mejor opción dado el problema y su contexto, por eso es importante tener una gran flexibilidad ',
                '- Un ejemplo serian las hojas de calculo, que permiten crear diversas formas de almacenar y manipular los datos, si se hace de manera correcta ',
                '',
                '<strong>Con opiniones:</strong>',
                '- Se puede apreciar como la forma correcta de realizar los procesos, por lo que el camino y sus elementos se muestran como se deben usar ',
                '- Aun asi, no solo ofrecen una unica manera, tambien existen otras formas, que por lo general suelen ser más dificiles y conllevar a problemas ',
                '- Un ejemplo seria un framework de programación, que facilita el trabajo, siempre y cuando se opere bajo sus reglas ',
            ]),
        new Item(Keys.ANALISIS_CODING_EASY_PART,
            [
                '- Los tutoriales hacen parecer que todo proyecto es facil, que de principio a fin no encontraras problemas, algo que es poco realista ',
                '',
                '- Jamas se trata de solo codificar, hay que analizar lo que existe, y como esto puede verse afectado, si se descarta totalmente, si es modificado, ',
                ' - como pueden verse afectados partes de terceros, e incluso los mismos clientes que usan/requieren del proyecto',
                '',
                '- Hacer un plan es fundamental, dependiendo de lo que se requiera, un nuevo desarrollo, una migracion, una nueva funcionalidad, ',
                ' - un refactor, una actualización, además de que realizar estimaciones y presentar plazos de entrega, etc... ',
                '',
                '- Comunicarse con otros equipos y/o personas, es comun necesitar realizar acciones que afectan a otras areas o que son compentencia de otras areas ',
                ' - donde solo es necesario brindarles apoyo, en cualquiera de los casos, la comunicación empresarial e interpersonal es fundamental ',
                '',
                '- Hay que dañar para arreglar, por más control o separación que se tenga, siempre habra algo que dejara de funcionar o cambiara su comportamiento, ',
                ' - por lo que tener un contro total es improbable y una estimación poco realista, un ejemplo practico de la <em>Ley de Hyrum</em>',
                '',
                '- Los requisitos no son claros, y si son claros estan incompletos, nunca faltara el requisito que es intrinseco y por lo tanto nunca se menciona, ',
                ' - o el requisito que solo existe a nivel de codigo, pero que es fundamental y nadie documento, entre otros casos, que suceden despues de iniciar ',
            ]),
        new Item(Keys.ANALISIS_ALGORITHMS,
            [
                '- Es un conjunto de instrucciones para llevar a cabo una tarea, estas deben ser lo suficientemente claras para obtener el objetivo requerido ',
                '- Son especialmente utiles para resolver problemas e innovar en multiples ambitos, pero es necesario que sean expresados de una manera comprensible ',
                '',
                '<strong>Formas de expresión </strong>',
                '<strong>- Lenguaje natural:</strong> Puede describirse mediante cualquier lenguaje que usen las personas para comunicarse de manera cotidiana ',
                ' - Este metodo es accesible para todo el publico, pero generalmente carece de precisión y claridad para algoritmos complejos ',
                '<strong>- Pseudocodigo:</strong> Combina elementos del lenguaje natural, con una descripción de alto nivel similar o igual a las convenciones ',
                ' - del lenguaje especificado, ayudando a reducir la brechas a nivel tecnico sin perder comprensibilidad ',
                '<strong>- Diagrama de Flujo:</strong> Una forma dominante presente desde los primeros dias de la informatica, basicamente son una colección de figuras geometricas',
                ' - con significados intrinsecos previamente acordados, que contienen descripciones de los pasos del algoritmo ',
                '<strong>- Codigo fuente:</strong> El enfoque directo y practico, donde se precisa tener conocimiento del lenguaje usado y del objetivo del algoritmo ',
                '',
                '<strong>Fundamentos</strong>',
                '- Un algoritmo despues de que sea <strong>eficaz</strong>, debe ser <strong>eficiente</strong>, y si las condiciones lo permiten, tambien deberia ser <strong>simple</strong>',
                '- Tambien existe una caracteristica deseable, que es la <strong>generalidad</strong>, si el algoritmo no cumple ninguna de estas condiciones, ',
                ' - significa que debe ser <strong>corregido</strong>, hasta que se encuentre un equilibrio justo entre las caracteristicas que más se deseen ',
                '- La solución debe ser alcanzable y no se considere un problema <strong>irresoluble</strong>, como el problema del <em>Puente de Königsberg</em>',
                '',
                '<strong>Rendimiento:</strong> Se tienen en cuenta 2 metricas importantes, Tiempo de ejecución y Memoria utilizada, para eso existe la notacion <em>Big-O</em>',
                '',
                '<strong>Tecnicas de diseño</strong>',
                '<strong>- Divide y venceras:</strong> Constan de 3 pasos principales',
                ' - Dividir el problema en subproblemas, idealmente del mismo tipo y en tamaños aproximados ',
                ' - Resolución de los subproblemas, puede ser de manera recursiva',
                ' - Se combinan las soluciones de los subproblemas, para resolver el problema original',
                '',
                '<strong>- Transformar y conquistar:</strong> Funcionan en 2 etapas',
                ' - En primer lugar la transformación, se modifica la instancia del problema a otro que sea más suceptible a tener solución',
                ' - En la segunda etapa, o la conquista, se resuelve ',
                '',
                '<strong>- Programación dinamica:</strong> Tecnica de programación, generalmente usada para encontrar maximos y minimos ',
                ' - Dividir el problema en subproblemas',
                ' - Guardar los resultados y optimizar los subproblemas',
                ' - Encontrar la solución general ',
                '',
                '<strong>- Algoritmos codiciosos:</strong> Cada paso debe generar la mejor opción disponible, con la esperanza de al final se obtenga la mejor solución global ',
                '',
                '<strong>- Fuerza Bruta:</strong> Son metodos sencillos que se basan directamente en la capacidad computacional y en la prueba y error de cada posibilidad ',
                '',
                '<strong>- Programación lineal:</strong> Se basa en la matematicas para optimizar el rendimiento ó la eficiencia de un problema con multiples variables ',
                '',
                '<strong>- Branch & Bounds(Ramificación y Poda):</strong> Usado para problemas de optimización, de manera progresiva se van creando y solucionando subproblemas, ',
                ' - si las solución es optima se mantiene la rama, si no se poda, y asi se continua hasta encontrar la mejor solución ó agotar los recursos ',
                '',
                '<strong>- Backtracking:</strong> Ayudan a explorar multiples opciones hasta encontrar la mejor solución, probando diferentes caminos, si estos no funcionan ',
                ' - se devuelve hasta un punto de guardado previo e intenta otra opción, sucesivamente, hasta que se encuentre la solución ó se agoten los recursos ',
            ]),
        new Item(Keys.ANALISIS_QUEUES_SYSTEM_DESIGN,
            [
                '<strong>Arquitectura Basica:</strong> Una cola de mensajes es un componente duradero y que soporta una comunicación asyncronica ',
                '- El funcionamiento basico es simple, un servicio de entrada(productor ó publicador) generan mensajes en la cola ',
                ' - y un servicio de salida(consumidor ó suscriptor) se conecta, procesa y borra los mensajes de manera pertinente ',
                '- En un diseño más real, suelen haber <strong>n-m</strong> productores y consumidores conectados a una o varias colas ',
                '',
                '<strong>Beneficios:</strong>',
                '- Los eventos ó mensajes recibidos, pueden ser procesados de manera asyncronica ',
                '- El productor o el consumidor pueden fallar temporalmente, sin generar errores importantes en el procesamiento de los mensajes ',
                '- La escalabilidad es relativamente facil, basta con agregar/reducir publicadores ó suscriptores de acuerdo a la oferta y la demanda ',
                '',
                '<strong>Tipos de colas:</strong>',
                '<strong>- FIFO(First In, First Out):</strong> Los mensajes se procesan en el orden de llegada, esto es relevante en sistemas donde el orden es importante ',
                '<strong>- Con Prioridad:</strong> Los mensajes pueden contener prioridades, para ser procesados antes que otros ',
                '<strong>- Push:</strong> La cola envian los mensajes directamente a los consumidores ',
                '<strong>- Pull:</strong> La cola espera a que los mensajes sean consumidos ',
                '',
                '<strong>Ejemplos:</strong>',
                '<strong>- RabbitMQ:</strong> Una cola versatil para muchos casos de uso general; Consumidores inteligentes, cola estupida ',
                '<strong>- Kafka:</strong> Diseñado para un alto rendimiento y transmisión de datos en tiempo real; Consumidores estupidos, cola inteligente ',
                '<strong>- Amazon SQS:</strong> Servicio administrado y ofrecido por AWS, confiable y con diversos tipos de colas',
            ]),
        new Item(Keys.ANALISIS_HIGH_LEVEL_VS_LOW_LEVEL,
            [
                '- Un Diseño de Alto Nivel <strong>HLD</strong> es como la vista area de un software, donde se puede ver un bosquejo general como: ',
                ' - Componentes o modulos principales, Arquitectura de la aplicación a grandes rasgos ',
                ' - Interacciones entre los componentes',
                ' - Se puede visualizar como un plano que proviene de la fase inicial del proyecto ',
                ' - Funciones generales, sin ahondar en detalles',
                '',
                '- Un Diseño de Bajo Nivel <strong>LLD</strong> son detalles más especificos como la implementación, patrones, clases, algoritmos, etc... ',
                ' - Es la traducción de la solución, teniendo en cuenta la necesidad, los aspectos y las limitaciones tecnicas encontradas ',
                ' - Implica logica real y detalles importantes para ser usados en la implementación ',
                ' - Es la guia para seguir durante la codificación, con el objetivo de que las funcionalidades sean precisas y eficientes ',
                '',
                ' ----------------------------------------------------------------------------------------------------------------                            ',
                ' &brvbar;  <strong>Aspecto</strong>   &brvbar;  <strong>Diseño de Bajo Nivel</strong>                     &brvbar;  <strong>Diseño de Alto Nivel</strong>                               &brvbar;',
                ' ----------------------------------------------------------------------------------------------------------------                            ',
                ' &brvbar; Enfoque    &brvbar; Detalles especificos de la implementacion &brvbar; Arquitectura y Diseño general                       &brvbar;',
                ' &brvbar; Cobertura  &brvbar; Componentes / Modulos                     &brvbar; Componentes Principales                             &brvbar;',
                ' &brvbar; Artefactos &brvbar; Diagramas de clase, Esquemas de BD(ERD)   &brvbar; Diagramas de arquitectura, Diagramas de componentes &brvbar;',
                ' &brvbar;            &brvbar;  Modelos, Algoritmos                      &brvbar;  FLujo de datos, definiciones e interfaces          &brvbar;',
                ' &brvbar; Entradas   &brvbar; Diseño de Alto Nivel                      &brvbar; Requisitos, Limitaciones, Objetivos de negocio      &brvbar;',
                ' &brvbar; Salidas    &brvbar; Codigo base                               &brvbar; Plan de diseño, plan de pruebas                     &brvbar;',
                ' &brvbar; Etapas     &brvbar; Durante la codificación                   &brvbar; Al principio del ciclo de vida del software         &brvbar;',
                ' &brvbar; Ejemplos   &brvbar; Normalización de BD, Domain Driven Design &brvbar; Estilos arquitectonicos, stack de tecnologias       &brvbar;',
            ]),
        new Item(Keys.ANALISIS_SYSTEM_DESIGN_CONCEPTS,
            [
                '- La complejidad de los sistemas ha crecido, cada vez se elaboran sistemas más elaborados, complejos, funcionales e interconectados ',
                '',
                '<strong>Colas de mensajes distribuidas:</strong> Habilita la comunicacion asincrona entre componentes ',
                '- Mejora la la resiliencia y la escalabilidad de los sistemas ',
                '',
                '<strong>DNS y trafico en Internet:</strong> Traduce direcciones IP de manera que sean amigables para las personas',
                '- Critico para el enrutamiento y el trafico de red',
                '',
                '<strong>Load Balancer:</strong> Distribuye el trafico entrante a traves de los servidores disponibles ',
                '- Asegura una alta disponibilidad y confianza',
                '',
                '<strong>Cache:</strong> Almacena información en memoria que es accesada con mucha frecuencia ',
                '- Reduce la carga de las bases de datos y mejora los tiempos de respuesta ',
                '- Puede ser implementado de manera distribuida o de manera local',
                '',
                '<strong>Observabilidad:</strong> Proporciona información del comportamiento y del rendimiento del sistema ',
                '- Incluye, logging, monitoreo y tracing(seguimiento)',
                '- Esencial para solución de problemas y optimización ',
                '',
                '<strong>Publish-Subscribe model:</strong> Permite una arquitectura orientada a eventos ',
                '- Desacoplamiento entre sistemas ',
                '- Facilita el flujo de datos en tiempo real ',
                '',
                '<strong>Bases de Datos:</strong> Almacenan y permiten consultar datos, con o sin estructura ',
                '- Ofrecen diversas soluciones para multiples necesidades ',
                '- Permiten manejar datos de forma ordenada y consistente ',
                '',
                '<strong>Almacenamiento de información sin estructura(BLOB):</strong> Manejo de grandes datos binarios, como imagenes y videos ',
                '- Optmizada para almancenar y buscar en grandes volumenes de estos datos ',
                '',
                '<strong>Unique ID Generator:</strong> Creación de IDs globales unicos para sistemas distribuidos ',
                '- Esencial en sistemas donde la consistencia e integridad de los datos es critica ',
                '',
                '<strong>Task Scheduler:</strong> Maneja y ejecuta tareas entre multiples nodos ó sistemas distribuidos ',
                '- Asegura la confiabilidad y la escalabilidad para sistemas en segundo plano ',
                '',
                '<strong>Escalado:</strong> Tecnicas para manejar altas cargas de trabajo ',
                '- Incluye el escalado vertical(hardware) o horizontal(software) ',
                '- Esencial para mantener el rendimiento aun con altos volumenes de carga ',
                '',
                '<strong>Rate-Limiting:</strong> Controla la tasa de peticiones para resguardar los servicios ',
            ]),
        new Item(Keys.ANALISIS_SINGLE_POINT_OF_FAILURE,
            [
                '- Un Punto Unico de Falla <strong>SPOF</strong> es la parte de un sistema que cuando falla, es capaz de tumbar al sistema entero ',
                '- Esto significa que el sistema entero dejara de funcionar, ya que este componente es tan critico que sin el, el sistema no es capaz de funcionar ',
                '- Para un sistema complejo es especialmente problematico ya que generan vulnerabilidades y reducen la confiabilidad y la resiliencia ',
                '- Es importante al menos identificarlos, para tener estrategias de como eliminarlos o al menos mitigarlo si lo anterior no es posible ',
                '',
                '<strong>SPOF Comunes:</strong>',
                '- Bases de Datos, en especial si solo esta en un servidor sin replicación ',
                '- Balanceadores de carga, al ser un unico punto de entrada ',
                '- Servidores de aplicaciones, y más si solo es un unico servidor ',
                '- Conexiones de red, los enlaces entre aplicaciones si no hay suficientes formas de conectarse a internet ',
                '',
                '<strong>Estrategias de eliminación:</strong>',
                '- Redundancia, se duplican componentes criticos, como bases de datos, balanceadores de carga, servicios ',
                '- Conmutación por error, si un componente critico deja de funcionar, una copia de seguridad se hace cargo de inmediato ',
                '- Balanceador de carga, puede considerarse tanto un problema como una solución, por lo que nunca deberia estar solo ',
                '- Distribución geografica, para sistemas de alcance global, se pueden ubicar y sincronizar multiples servidores ',
                '- Monitoreo y alertas, al detectar fallas de manera temprana, esto ayuda a abordar problemas antes de que generen afectaciones reales ',
            ]),
        new Item(Keys.ANALISIS_DOMAIN_EVENTS,
            [
                '- Que un proyecto use <strong>DDD</strong> no es sinonimo de que carezca de acoplamiento ',
                '- Los eventos son consumidos por cualquiera y no respetan los contextos para los cuales fueron creados ',
                '- Un evento de dominio es una representación de un hecho innegable que ha ocurrido en nuestro negocio ',
                '- Tambien suelen tener información basica como: ',
                ' &bull; Identificador       &bull; Fechas del suceso',
                ' &bull; ID relacionados     &bull; Carga util(payload)',
                '',
                '- El problema surge cuando el evento es consumido por cualquiera que necesite ser avisado de la acción, sin validar el contexo al que pertenece ',
                '- Cuando se expone un evento y este es consumido, se genera un contrato <strong>implicito</strong> el cual deriva en 2 posibles escenarios ',
                ' &bull; En el <em>Mejor escenario</em> se sabe quienes son los consumidores y cualquier cambio se retrasa mientras todos se adaptan ',
                ' &bull; En el <em>Peor escenario</em> hay consumidores ocultos y cualquier cambio puede desestabilizar componentes insospechados ',
                '',
                '- El mejor enfoque es crear eventos publicos y que los contratos sean <strong>explicitos</strong>, asi todo cambio debe ser avisado y acordado con anterioridad ',
                '- Es inevitable que el negocio cambie, por lo que tambien su comunicación debe hacerlo, aca entra en juego la necesidad de versionar los eventos ',
                '- Agregar nuevos atributos usualmente no genera problemas, modificar/eliminar si, se suele publicar simultaneamente ambos eventos ',
                '- Tambien se suele separar el evento en 2 partes, la información del evento(data) y la información tecnica del evento(metadata)',
            ]),
        new Item(Keys.ANALISIS_LIGHT_EVENTS_VS_RICH_EVENTS,
            [
                '- Un aspecto importante y poco valorado de las Arquitecturas Basadas en Eventos (EDA) es la cantidad de información a incluir en los eventos ',
                '',
                '<strong>Eventos Ligeros</strong>',
                '- Contiene solo información directamente relacionada con el evento, como los ID relacionados a otras entidades ',
                '- Suelen ser tan compactos que parecen una fila de una tabla relacional normalizada en 2F o 3F',
                '----------------------------------------------------------------------------------------                                                       ',
                '&brvbar;                    <strong>Pros</strong>                     &brvbar;                <strong>Contras</strong>                 &brvbar;',
                '----------------------------------------------------------------------------------------                                                       ',
                '&brvbar; Son simples y utilizan poco ancho de banda  &brvbar; Necesidad de hidratar los datos        &brvbar;                                  ',
                '&brvbar; Consumen poco almacenamiento                &brvbar; Sobrecostos en el procesamiento        &brvbar;                                  ',
                '&brvbar; Simplicidad para la generación              &brvbar; Complejidad para los suscriptores      &brvbar;                                  ',
                '&brvbar; Simplicidad para su publicación             &brvbar; Condiciones de carrera para consultas  &brvbar;                                  ',
                '',
                '',
                '<strong>Eventos Enriquecidos</strong>',
                '- Contiene toda la información necesaria para que el evento pueda ser procesado por los suscriptores sin consultas extras ',
                '- Esto suele implicar estructuras más complejas como listas y estructuras anidadas',
                '----------------------------------------------------------------------------------------                                                       ',
                '&brvbar;                    <strong>Pros</strong>                     &brvbar;                <strong>Contras</strong>                 &brvbar;',
                '----------------------------------------------------------------------------------------                                                       ',
                '&brvbar; Sin necesidad de consultas extras           &brvbar; Mayor consumo de ancho de banda        &brvbar;                                  ',
                '&brvbar; Sistemas menos acoplados entre si           &brvbar; Mayor cantidad de datos que publicar   &brvbar;                                  ',
                '&brvbar; Permiten manejar logica empresarial         &brvbar; Mayores costos de infraestructura      &brvbar;                                  ',
                '&brvbar; Simplicidad para los suscriptores           &brvbar; Complejidad para los productores       &brvbar;                                  ',
                '',
                '- En el contexto de <strong>DDD</strong> Existen diferencias entre eventos de dominio y eventos de integración ',
                '- Un Evento de Dominio son importantes dentro del dominio empresarial e impulsan logica de negocio ',
                '- Un Evento de Integración se utiliza para comunicar cambios en diferentes contextos y mantener la coherencia de los datos ',
                '- Existe una afinidad natural entre los eventos de dominio y los eventos ligeros, igual que los eventos de integración y los eventos enriquecidos',
            ]),
        new Item(Keys.ANALISIS_SYSTEM_DESIGN_I,
            [
                '- Diseñar un sistema pone a prueba la capacidad de analizar problemas complejos y crear sistemas que satisfagan requisitos especificos ',
                '- Tambien deben comunicar la intención y todas las partes de pensamiento de manera eficaz ',
                '',
                '<strong>Aclarar los requisitos:</strong> Es la base sobre la cual se pueden empezar todo el analisis ',
                '- Asi se entiende por completo el problema a resolver y ayuda a evitar errores de comunicación al inicio y durante en el proceso ',
                '- No omita ningun de los 2, juntos dan la vista general de lo que se espera ',
                '<strong>Funcionales:</strong>                             <strong>No Funcionales',
                '- Caracteristicas principales            - Rendimiento & escalabilidad',
                '- Reglas de negocio                      - Latencia y tiempos de respuesta ',
                '- Procesos y operaciones existente       - Confiabilidad & disponibilidad ',
                '',
                '<strong>Estimación de capacidad:</strong> Con los requisitos claros es necesario comprender la escala en que operara el sistema ',
                '<strong>Metricas:</strong>',
                ' - Cantidad de usuarios, usuarios totales, usuarios simultaneos, usuarios activos, picos de uso, etc.. ',
                ' - Trafico, Solicitudes por segundo, cargas de trabajo, ancho de bando necesario ',
                ' - Almacenamiento, Cuantos datos se almacenaran, información producida en algun intervalo de tiempo ',
                '',
                '<strong>Diseño de alto nivel:</strong>',
                '- Componentes principales y sus tipos, como microservicios, bases de datos, aplicaciones web, balanceadores de carga, etc.. ',
                '- Cree un diagrama que una las partes y sus interacciones ',
                '- Centrarse en el flujo de datos, como viajan por el sistema, desde una acción inicial hasta su fin y viceversa ',
                '- Comienze con un diagrama simple el cual sirva como base a la que ir agregando detalles mientras se va refinando ',
                '',
                '<strong>Diseño de Base de Datos:</strong>',
                '- Es un componente principal en muchos sistemas, por lo que se debe ser consciente de que su impacto es general para la aplicación ',
                '<strong>Elija el tipo más adecuado</strong>',
                ' - SQL para datos estructurados y fuertemente relacionados, que permiten transacciones y necesitan ser consistentes ',
                ' - NoSQL para datos sin estructura y que cambian constatemente, que necesitan escalar y ser consultados eficientemente ',
                '<strong>Diseñe el esquema</strong>',
                ' - Tablas normalizadas para evitar la redundancia de datos ó desnormalizadas segun los patrones de busqueda ',
                ' - Defina indices, constraints, claves primarias, claves foraneas, etc.. ',
            ]),
        new Item(Keys.ANALISIS_SYSTEM_DESIGN_II,
            [
                '- El diseño de un sistema tambien radica en juntar las piezas adecuadas y unirlas de la mejor forma posible ',
                '- Cosas como conceptos basicos, patrones, arquitecturas, tecnologias y si es necesario organizar el conocimiento ó profundizarlo ',
                '',
                '<strong>Diseño de interfaz:</strong>',
                '- Defina como interactuan los componentes y si lo haran a travez de APIs y sus protocolos ',
                '- Use convenciones de nombres estandar e identifique posibles apis que se deben exponer ',
                '- Con contratos claros la comunicación entre las APIs es fluida y reducen la ambiguedad a la hora de desarrollar ',
                '<strong>Protocolos</strong>',
                '  - REST: Interacciones simples y sin estado ',
                '  - GraphQL: Consultas complejas y la posibilidad de que sea el cliente quien las defina ',
                '  - gRPC: Acciones de alto rendimiento y baja latencia ',
                '- Contratos de los datos, como Json, Protobuf, Xml para ñas solicitudes y respuestas ',
                '',
                '<strong>Escalabilidad & Rendimiento:</strong>',
                '- Estan ligado directamente a los requisitos No funcionales y se cumplen teniendo en cuenta la infraestructura ',
                '- Escalamiento vertical agregando más recursos como Cpu, Ram, Almacenamiento a los servicios existentes ',
                '- Escalamiento horizontal se agregan más servicios para manejar el aumento de trafico ',
                '- Almacenamiento en cache para reducir los tiempo de respuesta y la carga de la base de datos ',
                '- CDN y balanceadores de carga para contenido estatico y repartir las cargas entre la infraestructura disponible ',
                '',
                '<strong>Fiabilidad & Resiliencia:</strong>',
                '- Igual de importante que garantizar el funcionamiento normal del sistema, tambien se debe manejar las fallas que se puedan presentar ',
                '- Replicación de datos en regiones diferentes y backups periodicos que garantizen la disponibilidad de los datos ',
                '- Se deben identificar los puntos unicos de falla <strong>SPOF</strong>, como bases de datos o balanceadores de carga y tener lista su redundancia ',
                '- Implemente el patron circuit breaker o mecanismos para evitar fallas en cascada ',
                '- Utilize reintentos de manera que el tiempo sea exponencial y mecanismos para que no se pierdan datos importantes como las <strong>DLQ & DLT</strong>',
                '- Si el sistema esta replicado, la coherencia entre los nodos debe estar garantizada para evitar problemas de confiabilidad ',
                '',
                '<strong>Bonus - Tipos de entrevistas:</strong>',
                '- Diseño de producto, son las más comunes en las cuales se solicita diseñar un sistema alrededor de un producto ',
                '- Diseño de infraestructura, suelen ser más tecnicas y hacen enfasis en casos especificos que demuestren un gran dominio del tema ',
                '- Diseño backend(<strong>POO</strong>), se basan en detalles de implementación con lenguajes como Java y C# y evaluan cosas como principios y patrones ',
                '- Diseño frontened, apuntan a aplicaciones que son visuales y de mucha interacción con los usuarios ',
            ])
    ];

export const BUENAS_PRACTICAS =
    [
        new Item('practicas1',
            [
                '- Definir el alcance y los requisitos, estableciendo limites acerca del trabajo a realizar con las partes involucradas',
                '- Dividir el desarrollo en fases o entregables que sean factibles, asi se pueden tener avances tangibles con su retroalimentación',
                '- Elegir el mejor <em>IDE</em> de acuerdo a los conocimientos y las necesidades, ya que esta herramienta nos ayuda a ser productivos',
                '- Reutiliza código(<em>DRY</em>) y comentalo cuando sea necesario, pero no hay mejor codigo que aquel que esta autocomentado',
                '- Documenta lo que haz hecho, asi es más facil integrar personal y sera util para futuros desarrollos ',
                '- Parte esencial de la codificación es realizar testing, principalmente para tener una red de seguridad, frente a los cambios',
                '- Estandariza reglas de desarrollo, asi se define la forma de trabajar para el grupo y se genera un codigo más mantenible y homogeneo',
                '- Optimiza recursos, no todo programa requiere grandes capacidades de procesamiento; No reinventes la rueda, pocas veces es necesario'
            ]),
        new Item('practicas2',
            [
                '- Presencia activa de los clientes en el desarollo, ya que eso son la fuente de conocimiento primordial, del negocio y sus necesidades',
                '- Definir los requerimientos de mano con el cliente, asi se pueden manejar estimaciones y priorizarlos, mediante metodologias agiles ',
                '- Adaptar el lenguaje de acuerdo a los tipos de clientes, para evitar no comunicar informacion importante, o hacerla inentendible ',
                '- Nunca dejar funciones al azar, que las pruebas demuestren su funcionamiento, y asi reducir problemas de retrocompatibilidad'
            ]),
        new Item('practicas3',
            [
                '- Escoger un ciclo de vida adecuado segun cada desarrollo, además del personal humano con las destrezas y experiencia relevantes',
                '- Estimar y presupuestar razonablemente, pero esto es más facil decirlo que hacerlo, pero se puede intentar con tecnicas agiles ',
                '- Control de calidad y revisiones de código periodicas, además de manejar del control de versiones, en caso de necesitar una reversión',
                '- Planificar como se realizara el matenimiento, los despliegues y el soporte tecnico, para que estos procesos sean conocidos y seguidos',
            ]),
        // new Item('practicas4',
        //     [
        //         '- Usar tecnologias y frameworks consolidados',
        //         '- Promover que el uso de la aplicación sea intuitivo y accesible ',
        //         '- Distribución de tareas, no hay equipos de un solo hombre',
        //     ]),
        new Item('demeter',
            [
                '- Es una buena practica en <strong>POO</strong> enfocada en reducir el acoplamiento entre clases ',
                '- El encadenamiento de muchos metodos puede significar un alto acoplamiento, conllevando a un problema de mantenimiento',
                '- Entre más grande sea una pila de llamadas, sera más propensa a futuras refactorizaciones ',
                '- Algunas desventajas de esta ley, son que se debe abstraer una solución y su implementación puede conllevar perdidas de rendimiento',
                '- No aceptar caramelos de extraños, ó no hables con extraños, son 2 formas de resumir este concepto ',
            ]),
        new Item(Keys.BUENAS_PRACTICAS_COMPLEJIDAD,
            [
                '- Es una metrica del software que proporciona una medida cuantitativa de la complejidad logica del programa ',
                '- Son los diferentes caminos que puede seguir una aplicación desde la entrada hasta la salida, ',
                ' - teniendo en cuenta condiciones, sentencias de control, parametros, funciones y atributos ',
                '',
                '- Lo ideal es tener la menor complejidad ciclomatica posible ya que: ',
                ' - Facilita el la modificación y mantenimiento del codigo ',
                ' - Simplifica el entendimiento y posibles refactorizaciones ',
                ' - La escabilidad del proyecto se facilita, al tener elementos más simples y menos propensos a errores ',
                ' - Se reducen los tests necesarios para obtener la mayor cobertura posible ',
                '',
                '- Para reducirla se pueden aplicar los siguientes concejos: ',
                ' - No abusar de la identación ',
                ' - Aplicar el Principio de Responsabilidad Unica(<strong>SRP</strong>), además de los otros principios de <strong>SOLID</strong>',
                ' - Evitar las sentencias switch-case, este tipo de sentencia atentan contra <strong>SRP</strong> y el princio de abierto-cerrado',
                ' - Metodos pequeños para funcionalidades más desacopladas ',
                ' - Evitar sentencias y parametros innecesarios, ya que esto es un indicativo de que hay multiples opciones, violando <strong>SRP</strong>',
            ]),
        new Item(Keys.BUENAS_PRACTICAS_LOGGING,
            [
                '<em>“Depurar es como ser el detective de una película policial en la que también eres el asesino.”</em> <strong>Filipe Fortes</strong>',
                '',
                '- Depurar es recomendable cuando la pila de llamadas es demasiado extensa y compleja',
                '- Registrar es util cuando la aplicación ó funcionalidad es pequeña y de baja complejidad ',
                '- Con el auge de la nube y los sistemas distribuidos, esto ha hecho que la observavilidad sea aun más importante hoy en dia ',
                '- Esta elección tambien depende de la comodidad de cada programador y de su eficiencia con cada herramienta ',
            ]),
        new Item(Keys.BUENAS_PRACTICAS_DEBUGGING,
            [
                '- En 1940 la almirante Grace Hopper, que tambien escribio el primer compilador que existio, descubrio una polilla un <strong>(bug)</strong> ',
                ' - atrapada dentro de un rele de una computadora que se estaba desarrollando, como la causante de la falla del sistema ',
                '- Desde entonces se suele decir que se esta <em>depurando</em> (debugging) para indicar una busqueda de errores y/o fallos ',
                '- Los errores en la programación son comunes al ser una actividad tan conceptual y abstracta, en la cual se puede perder el foco ',
                '',
                '<strong>Preste atención a los mensajes de error:</strong> Si el codigo falla, casi todos los lenguajes son capaces de mostrar el error y su causa, ',
                ' - algunos con más exactitud que otros, entender el error es la base para encontrar una solución ',
                '',
                '<strong>Buscar en Internet:</strong> Si no conoce el error, o no sabe el porque de este, es probable que en internet ya exista una explicación, ',
                ' - del porque sucede, acompañado de posibles soluciones, y posiblemente en contextos similares ',
                '- En las comunidades existentes probablemente existan personas a la cuales ya les ha sucedido el mismo problema y hayan encontrado alguna solución ',
                '',
                '<strong>Usar fuentes confiables:</strong> Siempre es buena idea leer la documentación oficial para entender la raiz del problema, ',
                ' - tambien saber que todas las soluciones no son optimas, ya que pueden estar desactualizadas ó no funcionarian en todos los escenarios ',
                '',
                '<strong>Explica tu logica:</strong> Existe la posibilidad de que se haya malinterpretado la información ó se esten haciendo suposiciones erroneas, ',
                ' - por lo que revisar tu codigo con un pato de goma ó con un compañero explicandoselo, se pueden comprender cosas que antes no ',
                '',
                '<strong>Reduzca las posiblidades:</strong> Si un codigo funciona de cierta manera, deberiamos procurar que siga funcionando asi, por ejemplo ',
                ' - si una función recibe 3 parametros, deberiamos pasarle 3 parametros, y no 2, estas "pequeñeces" pueden ahorrar un gran tiempo despues ',
                '',
                '<strong>Tomar un descanso:</strong> Cuando los bugs son más grandes y complejos es posible que su resolución conlleve mucho tiempo, por lo que ',
                ' - en algun momento de frustación optemos por soluciones de fuerza bruta, en este caso lo mejor es tomarnos un descanso y hacer otra cosa ',
                '',
                '<strong>Buscar ayuda:</strong> Cuando los problemas son demasiado grandes o complicados, preguntarle a alguien con más experiencia es de los más normal, ',
                ' - generalmente las personas de la comunidad estan dispuestas a ayudar a sus congeneres ',
                '',
                '<strong>Verificación:</strong> Una vez resuelto el bug, verifique que la solución si haya funcionado y que no ha introducido nuevos problemas, ',
                '- Tambien no esta de más aumentar la cobertura del codigo existente, agregando pruebas automatizadas y/o unitarias ',
                '',
                '<strong>Codigo limpio:</strong> Tenga en cuenta que los principios como SOLID, KISS, DRY y muchos más estan ahi para mejorar nuestro codigo, ',
                ' - tenerlos en cuenta a la hora de codificar nos ayuda a crear implementaciones más limpias y mantenibles ',
                '',
                '<strong>Herramientas:</strong> Estas ayudan a construir un mejor codigo, como analizadores de codigo estatico, los IDE, navegadores, etc.. ',
            ]),
        new Item(Keys.BUENAS_PRACTICAS_COMPLEJIDAD_COGNITIVA,
            [
                '- Es una metrica de software complementaria a la complejidad ciclomatica ',
                '- Esta metrica trata sobre que tan dificil es de entender un fragmento de codigo ',
                '- La complejidad ciclomatica esta enfocada a su eficacia en la ejecución, Mientras que esta se enfoca en la mantenibilidad',
                '',
                '- Esta metrica aumenta de acuerdo a ciertas condiciones ',
                ' - Anidamiento',
                ' - Condicionales',
                ' - try/catch y retrasmision de excepciones',
                ' - Estructuras switch-case ',
                ' - sequencias largas de operadores logicos ',
                ' - recursividad ',
                ' - ciclos',
                '',
                '- Existen casos donde la complejidad ciclomatica sea igual en 2 algoritmos, pero la cognitiva no, por eso es importante analizar ambas ',
                '- Un codigo con una alta complejidad cognitiva es dificil de mantener y de entender, por lo que siempre se busca simplificarla, ',
                ' - sin cambiar su comportamiento, para que sea más facil de comprender y de modificar ',
            ]),
        new Item(Keys.BUENAS_PRACTICAS_COMPLEJIDAD_ALGORITMICA,
            [
                '- Un algoritmo es una manera de hallar un dato desconocido, o una secuencia de pasos para obtener un resultado ',
                '- Los problemas pueden ser resueltos de diversas maneras, sin embargo no todas son optimas o viables ',
                '- Esto nos permite medir un algoritmo de manera teorica de 2 maneras: ',
                '- <strong>Complejidad temporal</strong>(tiempo de ejecución) y <strong>Complejidad espacial</strong>(recursos/memoria)',
                '- Tambien se suelen describir mediante el tamaño del conjunto de datos <em>n</em> y el crecimiento de las instrucciones para cumplir el objetivo ',
                '- Para medir la complejidad cada instrucción suele tener un peso determinado, ',
                ' - despues de sumarlas y tener el mayor termino, este es el indicativo de la complejidad ',
                '',
                '- Grados de complejidad comunes: ',
                '- O(1)       -> constante         - O(n<sup>2</sup>) -> cuadratico  ',
                '- O(log n)   -> logaritmico       - O(n<sup>3</sup>) -> cubico      ',
                '- O(n)       -> lineal            - O(n<sup>a</sup>) -> polinomico  ',
                '- O(n log n) -> cuasi-lineal      - O(2<sup>n</sup>) -> exponencial ',
                '- O(n!)      -> factorial                                           ',
                '',
                '- Sabiendo analizar estas caracteristicas, se puede suponer el costo de los algoritmos, e intentar optimizarlos ',
                '- Si la optimización no es prioridad algunos de estos conceptos pierden relevancia, sin embargo',
                ' - conocerlos permite generar mejores soluciones, al tener más perspectivas a la hora de resolver un problema ',
            ]),
        new Item('estandaresNombramiento',
            [
                '- Cada lenguaje de programación tiene sus convenciones para nombrar metodos, clases, variables, constantes, etc... ',
                '- Se recomienda seguir estas convenciones para aumentar la legibilidad de nuestro codigo y facilitar el mantenimiento ',
                '',
                '<strong>camelCase:</strong> Se usan mayusculas para diferenciar una palabra de otra ',
                '<strong> - UpperCamelCase:</strong>  La primera letra de las palabras es mayuscula: MiPaginaDeConceptos ',
                '<strong> - lowerCammelCase:</strong> Igual, pero con la diferencia de que la primera letra es minuscula: miPaginaDeConceptos ',
                '- Generalmente usada para nombres de variables en diversos lenguajes ',
                '',
                '<strong>snake_case:</strong> Las palabras estan separadas por guion bajo: mi_pagina_de_conceptos ',
                '<strong> - SCREAMING_SNAKE_CASE:</strong> Igual, pero todo es en mayusculas: MI_PAGINA_DE_CONCEPTOS ',
                '- Utilizado para nombre de constantes y de variables en lenguajes más antiguos ',
                '',
                '<strong>kebab-case:</strong> Como snake case pero con guion medio: mi-pagina-de-conceptos ',
                '<strong> - Train-Case:</strong> Variedad de kebab case pero mayuscula inicial: Mi-Pagina-De-Conceptos ',
                '- Se encuentra generalmente en nombres de paquetes o de urls ',
                '',
                '<Strong>leetspeak ó 1337:</strong> Consiste en remplazar caracteres por otros similares o su reflexion: M1P4G1N4D3C0NC3P70$ ',
                '- Usada ampliamente en internet, además de diversas comunidades con intereses especificos, tambien en internet',
                '',
                '<strong>Notacion hungara:</strong> Se usa para crear nombres de variables que indiquen su tipo: nContador ó bActivo ',
                '- Tambien usada en la programación, más que todo en lenguajes no tipados '
            ]),
        new Item('estatico',
            [
                '- El analisis de codigo estatico permite corregir vulnerabilidades, errores y bugs, que no se ven y pueden conllevar problemas',
                '',
                '<strong>Pros</strong>',
                '- Ayuda a la reducción de la deuda tecnica y detectar code smells ',
                '- Fomenta el uso de buenas practicas y la mejora continua ',
                '',
                '<strong>Contras</strong>',
                '- Se debe hacer con herramientas especializadas, y consume tiempo de desarrollo ',
                '- No hay estandares concretos, cada lenguaje tiene especificaciones diferentes entre si ',
                '',
                '<strong>Algunas tecnicas de analisis</strong>',
                '<strong>- Analisis grep:</strong> Analiza el codigo con expresiones regulares para encontrar: ',
                ' - Contraseñas expuestas, metodos mal nombrados, variables incompresibles, etc... ',
                ' - Errores de identación cerrar y abrir llaves correctamente, para evitar problemas al ejecutar ',
                '<strong>- DataFlow:</strong> Se analiza desde un punto de partida hasta un punto final ',
                '<strong>- AliasAnalisis:</strong> Analiza los punteros, para los lenguajes que funcionan con estos ',
                '',
                '<strong>Posibles defectos</strong>',
                '<strong>- Bugs:</strong> Es cuando un programa difiere de lo que debe hacer, esto es más subjetivo que objetivo, ',
                ' - por lo que son errores que son más faciles de encontrar por humanos, mediante depuracion, testing, etc... ',
                '<strong>- Violación:</strong> Son errores de codificación entre lo que se pueda considerar "ideal", ',
                ' - en el marco del lenguaje y lo realizado por el programador ',
                '<strong>- Vulnerabilidad:</strong> Son comportamientos errores que a la larga pueden llevar a posibles problemas, ',
                ' - de rendimiento ó de seguridad, más no son considerados problemas graves ',
            ]),
        new Item(Keys.BUENAS_PRACTICAS_GUARD_CLAUSES,
            [
                '- La identación puede ser una aliada a la hora de leer el codigo, pero demasiada puede convertirse en un obstaculo ',
                '- Esto no solo complica el entendimiento, si no que puede indicar un alto grado de anidación y complejidad ',
                '- Esta practica lo que nos recomienda es comprobar sistematicamente cada una de las condiciones que se deben cumplir, ',
                ' - para continuar con el proceso, y si alguna es invalida, se retorna un valor o una excepción dado el caso ',
                '- Esto facilita seguir la pila de llamados y mejora el entendimiento al reducir el anidamiento y la identación ',
            ]),
        new Item('semanticConstructors',
            [
                '- Tambien conocidos como <em>named constructors</em> es un refactor para eliminar la complejidad de los constructores ',
                '- Evita que tengan responsabilidades extra, al requerir que conozcan los detalles de la implementación ',
                '- Encapsula la creación de objetos de modo que haya menos posibilidades de construir objetos invalidos y pueda ser bajo demanda',
                '- Evita tener constructores telescopicos, que basicamente son <em>n</em> combinaciones de constructores de acuerdo a las propiedades ',
                '- Son una manera de implementar sobrecarga de metodos(constructores) en lenguajes que no lo permiten ',
            ]),
        new Item(Keys.BUENAS_PRACTICAS_EXCEPTIONS,
            [
                '- No use solo excepciones genericas, especializar trae ventajas como un mejor manejo de los errores ',
                '- No abuse de las excepciones, lo ideal es solo crearlas para requisitos de negocios realmente importantes ',
                '- Registrar los errores es importante, pero no toda excepcion, debe estar acompañada de un log ',
                '- Diferenciar entre excepciones comprobadas y no comprobadas, ya que esto obliga a manejarlas en tiempo de compilacion o de ejecución ',
                '- Capturar las expresiones de manera que se silencien, asi no habra errores a la vista, e incrementara la dificultad al buscarlos ',
                '- Definir una jerarquia clara de las excepciones, quien debe capturarlas y quien puede lanzarlas ',
                '- Usar mensajes claros, que proporcionen información relevante del error, ayudando a encontrar potenciales problemas ',
                '- Cierre recursos y evite posible fugas de memoria, al tener acciones que hagan esto despues de manejar los errores ',
                '- Es importante saber retransmitir la información, de manera que no se pierda información de pila de errores ',
            ]),
        new Item('goodHabits',
            [
                '- Un desarrollador no solo codifica, un buen desarrollador tiene una gran cantidad de habilidades que van más alla de la codificación ',
                '- Los items acontinuación son una recopilación subjetiva y no son una guia en que confiar ciegamente',
                '',
                '<strong>Centrarse más alla del codigo:</strong> La codificación es para un desarrollador lo que un pincel para un pintor, ',
                ' - esta es la herramienta principal, pero un pincel no sabe lo que hace, toda linea de codigo y todo trazo de pintura ',
                ' - deben tener un significado, cuando se escribe codigo se busca resolver algun problema en un contexto dado, además ',
                ' - de que se debe tener un pensamiento critico y sistemico, de como afectara al sistema en general , como se mantendra, entre otras ',
                '',
                '<strong>Eficiencia:</strong> No es necesario que siempre se corra y se entregue antes de tiempo, tampoco de susbestimar las tareas, ',
                ' - se relaciona más a tener un progreso constante, y aunque encontremos errores que nos atasquen, los avances por pequeños que sean, ',
                ' - se pueden tomar como progreso, ya que de todos modos resolver problemas dificiles requiere tiempo ',
                '',
                '<strong>Curiosidad:</strong> Un buen desarrollador no solo es habil o inteligente, tambien es apasionado y busca mejores maneras, ',
                ' - experimenta con nuevas tecnologias, y se mantiene actualizado, en una profesión tan cambiante ',
                '',
                '<strong>Saber el porque:</strong> Las herramientas modernas y la necesidad de abstracciones de alto nivel, ha descentivado la curiosidad ',
                ' - de saber como funcionan las herramientas y sus bases sobre las cuales se erige la programación, ',
                ' - aunque tambien esta el punto de vista de que no es necesario ni obligatorio saberlo, para saber como usarlo, ',
                ' - pero este conocimiento extra puede ser util en el analisis del problema, su resolución',
                ' - y en la toma de decisiones, ya que se conoce mejor el panorama y hay más información para analizar ',
                '',
                '<strong>Pensamiento de sistemas:</strong> No solo se debe ver el panorama particular, tambien se debe comprender el rompecabezas completo, ',
                ' - todas las piezas estan unidas y pueden afectar a otras aunque no lo parezca, o sea de manera imperceptible ',
                '',
                '<strong>Desconectarse del mundo digital:</strong> Una larga exposición/uso de las pantallas puede conllevar a problemas fisicos y mentales, ',
                ' - por lo que tambien es parte importante del trabajo, saber cuando se debe tomar un descanso ',
                '',
                '<strong>El arte de Estimar:</strong> No es necesario saber valores exactos ni de tener todo estrictamente medido, pero si es importante ',
                ' - tener herramientas y conocimentos para hacernos una idea y generar aproximaciones concordantes, aunque este proceso parezca un arte ',
                '',
                '<strong>Conocimiento flexible:</strong> No solo basta con entender y aprender una gran multitud de temas, se trata de interiorizarlos de manera que',
                ' - el concepto base se pueda aplicar y/o adaptar en otros ambitos y situaciones, asi sabemos que se ha dominado el conocimiento',
                '',
                '<strong>Hacer faciles las cosas dificiles:</strong> Una gran forma de mostrar dominio del conocimiento es de manera que conocimientos complejos, ',
                ' - puedan ser comprendidos por cualquiera',
                '',
                '<strong>Pensar a largo plazo:</strong> Cada vez que se hace algo, se debe hacer para que sea funcional en el corto plazo e ideal a largo plazo, ',
                ' - engendrar soluciones faciles y descuidadas puede ser un exito en el corto plazo, pero sera una bola de nieve más adelante ',
                ' - por lo que se trata de mantener un equilibrio, y realizar las cosas bien sin perder el horizonte',
            ]),
        new Item(Keys.BUENAS_PRACTICAS_FUNCTIONS,
            [
                '- <strong>Clean Code</strong> de <em>Robert C Martin</em> se enfoca en como escribir codigo limpio y con buenas practicas, ',
                ' - por eso existe todo un apartado dedicado a las funciones, a continuación es un compendio de los puntos principales ',
                '',
                '<strong>- Funciones pequeñas:</strong> Asi son faciles de entender y de mantener, cumpliendo casi siempre el principio de Single Responsability <strong>(SOLID)</strong> ',
                '<strong>- Solo una cosa:</strong> Realizar una sola accion permite que las funciones cumplan el principio <strong>KISS</strong> y reduzcan su complejidad ',
                '<strong>- Nombres descriptivos:</strong> Debe reflejar el proposito, pero si es demasido extenso, probablemente la función tiene demasiada responsabilidad ',
                '<strong>- Argumentos:</strong> Se deben minimizar la cantidad en lo posible',
                ' 0 - Ideal           (niladic) ',
                ' 1 - Aceptable       (monadic) ',
                ' 2 - Aceptable       (dyadic)  ',
                ' 3 - Evitarlas       (triadic) ',
                '+4 - No recomendable (polyadic)',
                '',
                '<strong>- Comand-Query Separatión:</strong> Como en <strong>CQRS</strong>, una función debe consultar información ó cambiar estados, mezclar ambas puede llevar a confusiones',
                '<strong>- Preferir Excepciones, sobre codigos de error:</strong> Comprobar estos codigos suele ocultar las causas de los errores, además de que no ayudan ',
                ' - a una clara separación entre la logica de negocio y el manejo de errores, además de ser una solución proveida por el lenguaje ',
                '<strong>- Principio DRY:</strong> No te repitas, la duplicación suele ser malvada, genera inconsistencias y aumenta el riesgo de errores ',
            ])
    ];

export const COMPILACION =
    [
        new Item('compilacion',
            [
                ' - Es el proceso de pasar un lenguaje de programación a otro formato de manera equivalente ',
                ' - Generalmente es un proceso de lenguajes de alto nivel a bajo nivel ',
                ' - Durante el proceso el codigo se puede optimizar o añadir más procesos ',
            ]),
        new Item('nivel',
            [
                '<strong>Bajo nivel:</strong>',
                '- Son lenguajes de alto rendimiento dependientes de la maquina donde se ejecute ',
                '- Es un lenguaje que esta más cercano al lenguaje maquina, por lo que son dificiles de manejar ',
                '',
                '<strong>Medio nivel:</strong>',
                '- Pocos lenguajes caen en esta categoria, ya que solo suelen considerarse las catergorias de alto y bajo nivel',
                '- Pueden acceder al sistema pero tambien comparten las caracteristicas de un lenguaje de alto nivel ',
                '',
                '<strong>Alto nivel:</strong>',
                '- Son lenguajes más cercanos al entendimiento humano, además de ser más dinamicos y contar con una gran cantidad de abstracciones ',
                '- Son independientes de las maquinas donde se ejecuten, a traves de un traductor que funciona como intermediario ',
            ]),
        new Item('interprete',
            [
                '<strong>Compilados</strong>',
                '- Suelen ser lenguajes de niveles alto y medio',
                '- Son traducidos y ejecutados en la maquina que esten ',
                '- Esto hace que la optimización sea mayor, a costa de una menor compatibilidad y posibles problemas inesperados ',
                '- Los archivos ejecutables se realizan previamente, por lo que la ejecución es inmediata ',
                '- Al estar enlazados con el SO y el Host, estos se pueden afectar mutuamente ',
                '',
                '<strong>Interpretados</strong>',
                '- Mayormente lenguajes de alto nivel',
                '- Estos deben deben ser traducidos, a traves de un intermediario ',
                '- Este intermediario se encarga de ejecutar el programa y realizar los cambios necesarios, para que el SO lo entienda ',
                '- Debido a esto son multiplataforma, y se hace a pedido, (just in Time) ',
                '- La ejecución de estos programas estan aisladas del SO, por lo que requieren más recursos, para tener una mayor independencia ',
            ]),
        new Item(Keys.COMPILACION_TRANSPILACION,
            [
                '- Es el proceso de traducción de un lenguaje a otro, pero de igual nivel y generalmente sucede con lenguajes de alto nivel ',
                '- De los ejemplos más relevantes es el paso de Typescript a Javascript ó sass a css',
                '- Todo transpilador puede ser considerado un compilador, pero no al contrario ',
                '- Generalmente toda la sintaxis del lenguaje destino es compatible con la de origen, pero no al contrario ',
                '- Tambien pueden ser usados para modernizar el codigo con nuevas caracteristicas manteniendolo compatible con versiones anteriores ',
            ]),
        new Item('azucarSintactico',
            [
                '- Termino acuñado para hacer referencia a las adiciones sintacticas de un lenguaje de programación ',
                '- Estas adiciones se dan con el proposito de hacer que las construcciones sean más faciles de leer y expresar ',
                '- Esto no cambia el sentido semantico de las expresiones, pero si lo hace más entendible para el ser humano ',
                '- Son aquellas expresiones que pueden ser borradas sin afectar el funcionamiento del programa, o su rendimiento ',
                '- Parte del trabajo de los compiladores es desglosar estas expresiones a sus reducciones más basicas ',
            ]),
        new Item('coercion',
            [
                '- Es la conversion automatica o implicita de un tipo de dato a otro; Ejemplo: de string a number ',
                '- La coerción es implicita, mientras que la conversion puede ser implicita o explicita ',
                '- Esto puede dar a errores o conversiones erroneas si no se especifica que es lo que se necesita ',
                ' - Ejemplo -> "5" + 9 = 59         ',
                ' - Ejemplo -> Number("5") + 9 = 14 ',
            ]),
        new Item('ofuscacion',
            [
                '- Es comun el dicho que suele recordar que progames como si tu codigo fuera a ser mantenido por un psicopata que sabe donde vives ',
                '- Esto es para evitar que te termine odiando quien quiera que sea que tenga que mantener el codigo, ',
                '- Generalmente esto nos pasa con nuestro codigo, al cual nosotros mismos mantenemos ',
                '- Pero en ocasiones es interesante ocultar el funcionamiento de nuestro codigo cuando es inevitablemente visible, ',
                ' - como lo es en el caso de Javascript, para para evitar modificaciones, desentrañar su funcionamiento, o su plagio ',
                '- Esto en si, es opuesto a un codigo mantenible y entendible',
                '',
                '- Existen diferentes maneras "manuales" de hacer esto <strong>(malas practicas):</strong> ',
                ' - Nombre de variables sin sentido ',
                ' - Duplicar codigo ',
                ' - Añadir/eliminar comentarios innecesarios/necesarios ',
                ' - Agregar pasos innecesarios y codigo muerto ',
                '',
                '- La ofuscación es particularmente problematica cuando existen sistemas legacy sin buena documentación y con malas practicas ',
                '- Tambien puede ser usada con propositos malintencionados al introducir codigo malicioso dificil de revisar y por ende de encontrar ',
                '',
                '- Esto se puede dar de manera involuntaria pero necesaria en procesos como: ',
                ' - La transpilación de un lenguaje a otro, Typescript a Javascript',
                ' - La minificación de archivos para reducir su peso ',
                ' - La compilación de lenguajes de alto nivel (compilados) a codigo binario ',
                ' - Optimizaciones realizadas por los propios compiladores ',
            ]),
        new Item('treeShaking',
            [
                '- Es un termino comunmente usado en Javascript para la remoción de codigo muerto ',
                '- Esto se basa en la declaración de importaciones y exportaciones de ES2015',
                '- Los empaquetadores modernos como webpack y rollup realizan esto para tener archivos más livianos ',
            ]),
        new Item(Keys.COMPILACION_GRAFOS,
            [
                '- Son una composición interesante de un conjunto de objetos denominados nodos (vertices) ',
                '- Estos estan conectados con otros por medio de aristas (arcos) ',
                '- Algunos de sus usos son las bases de datos, donde la información esta interelacionada entre multiples nodos ',
                '- Para estudiarlos nacio la teoria de grafos, con la finalidad de representar estas abstracciónes graficamente ',
                '- El analisis de los nodos y sus aristas nos permite entender a profundidad las relaciones de los datos ',
                '- Existen diferentes tipos de grafos, dependiendo de los caminos que estos tengan ',
                '- Un camino, es el recorrido que se da al pasar por cierta cantidad de nodos, para llegar de A a B ',
                '- Tambien son utiles para la optimización y/o simplificación de redes de cualquier tipo ',
            ]),
        new Item(Keys.COMPILACION_AOT,
            [
                '- La compilacion anticipada, es el acto de compilar un lenguaje de alto nivel a bajo nivel (generalmente), más no necesariamente a nivel maquina ',
                '- Comunmente asociado al paso intermedio como al bytecode de Java ó CIL de .NET, ',
                ' - cuando se usa en este contexto especifico suele ser el contrario de la compilación Just in Time (JIT)',
                '',
                '- Una de las principales diferencias entre AOT y JIT es que esta reduce la necesidad de un intermediario para ',
                ' - convertir el codigo a lenguaje maquina, haciendo el paso intermedio antes de la ejecución y no durante ',
                '',
                '- Este tipo de compilación no es posible para todos los lenguajes, especialmente los tipados dinamicamente ',
                '- Un aspecto en contra de AOT es la carencia de realizar optimizaciones especificas para el entorno donde se va a ejecutar, ',
                ' - ya que al contrario de JIT, esta no conoce toda la información necesaria, y tampoco puede especular para lograr esto ',
                '',
                '- Un aspecto positivo de AOT es que al ya estar listos, se reducen los tiempos necesarios para el arranque y su ejecución ',
            ]),
        new Item(Keys.COMPILACION_DUCK_TYPING,
            [
                '- Es un termino comunmente asociado con los lenguajes de programación tipados dinamicamente y el concepto de polimorfismo ',
                '- Al codigo no le importa el tipo del objeto, si no lo que puede hacer <em>"Si camina como pato y grazna como pato, entonces debe ser un pato"</em> ',
                '- Parte de esto es posible ya que estos lenguajes usan la sobrecarga automatica de operadores de modo que se adaptan al tipo de dato procesado ',
                '- El polimorfismo permite que el comportarmiento sea el esperado, sin tener que aferrarse a algun tipo en concreto ',
                '- Aunque es flexible, puede traer problemas la ejecución si se quiere usar comportamientos especificos de un tipo en otro que no lo soporte ',
                '- Tambien se pueden comprobar los tipos de los objetos antes de, pero esto generalmente denota un problema de diseño más que de codificación ',
            ]),
        new Item(Keys.COMPILACION_SDK_VS_API,
            [
                '- Actualmente las comunidades de desarrollo usan ambos, de manera intensa y es importante entender sus diferencias ',
                '',
                '<strong>SDK (Software Development Kit)</strong> Definido mediante un conjunto de herramientas de creación de software especificos de cada plataforma, incluye: ',
                '- <strong>Depurador:</strong> Permite al desarrollador identificar y corregir errores en el codigo del programa ',
                '- <strong>Compilador:</strong> Procesa el lenguaje de programación traduciendo todas las declaraciones a un lenguaje entendible para la maquina ',
                '- <strong>Ejemplos:</strong> Para dar una idea más clara a la hora de programar ',
                '- <strong>Rutinas y subrutinas:</strong> Metodo, funcion o subprograma que se puede llamar desde cualquier parte del codigo, con una función especifica ',
                '- <strong>Bibliotecas:</strong> Permite reusar codigo ya existente para evitar reiventar la rueda ',
                '- <strong>Herramientas de analisis:</strong> Para evaluar el rendimiento y realizar pruebas en entornos productivos ',
                '- <strong>Documentación:</strong> Durante el desarrollo con cierta frecuencia es necesario conocer las intrucciones o especificaciones ',
                '',
                ' Download and install   &rarr; &rarr;      Coding space           &rarr; &rarr;        Test and build ',
                '      the <em>Kit</em>               Compiler, Docs, Ejemplos             software aplications        ',
                '',
                '<strong>Tipos</strong>',
                '<strong>- Plataforma:</strong> Son claves para el desarrollo de cada plataforma, por ejemplo el SDK de windows, para aplicaciones en su tienda ',
                '<strong>- Especificos del lenguaje:</strong> Son usados para desarrollar en un lenguaje en especifico, como el JDK, para desarollar en Java o lenguajes asociados ',
                '<strong>- Especificos de analisis:</strong> Recopilan datos para obtener información sobre usuarios o acciones, como el SDK de Google Analytics ',
                '',
                '<strong>Beneficios:</strong>',
                '- Acceso a piezas prefabicadas debidamente testeadas y que acortan tiempo de desarrollo ',
                '- Integraciones mas fluidas debido al soporte y la documentación presentes de manera nativa ',
                '- Menor tiempo de desarrollo construyendo componentes bases, que se puede aprovechar para otros más importantes ',
                '',
                '<strong>API (Interfaz de Programación de Aplicaciones) </strong> Elabora un conjunto de reglas mediante las cuales aplicaciones/dispositivos se comunican entre si',
                '- Una buena API tiene identificadas y documentadas sus especificaciones tecnicas e interfaces por las cuales es posible acceder ',
                '',
                ' Web app in   &rarr;    Internet    &rarr;    API     &harr;   Web        &ndash; &ndash;    Data ',
                '  browser     &larr;                &larr;               Server      &ndash; &ndash;    base      ',
                '',
                '<strong>Tipos:</strong>',
                '- <strong>REST:</strong> Se componen de una arquitectura cliente-servidor y generalmente son usadas para operaciones CRUD a traves de JSON ',
                ' - Tambien suelen ser stateless por lo que no almacenan datos del cliente en el servidor entre solicitudes ',
                '- <strong>RPC:</strong> Se utiliza para ejecutar codigo de otro sistema y diferente a REST esta no solicita datos, si no que espera una respuesta de la ejecución ',
                '- <strong>SOAP:</strong> Se comunica a traves de protocolos web como HTTP, SMTP, TCP/IP y requieren mayor privacidad y seguridad ',
                '- SOAP es un conjunto de protocolos, mientras que REST es un modelo arquitectonico, por lo que es posible tener API RESTful con protocolos SOAP  ',
                '',
                '<strong>Beneficios:</strong>',
                '- Integraciones con diferentes sistemas como complementos sin tener que desarrollar funcionalidades extras ',
                '- Permiten acortar los ciclos de desarrollo y ser más eficientes ',
                '- Son personalizables hasta cierto punto, segun la necesidad ',
            ]),
        new Item('casting',
            [
                '- Es una cambio de un valor de un tipo a otro, ya sea primitivo o de clase ',
                '<strong>Widening Casting:</strong> Cuando se convierte de un dato pequeño a uno más grande; float -> double ',
                '<strong>Narrowing Casting:</strong> Caso contrario donde se convierte de un dato más grande a un pequeño; long -> int ',
                '',
                '- Estos casteos tambien se pueden hacer con clases que guarden similitudes o que se relacionen jerarquicamente mediante la herencia ',
                '- Algunos casteos de tipo Narrowing pueden ocasionar errores, como la perdida de precisión o excepciones en tiempo de ejecución ',
            ]),
        new Item(Keys.COMPILACION_VERBOSITY,
            [
                '- Un lenguaje puede ser considerado como Verboso, cuando se usan demasiadas palabras para realizar acciones simples, ',
                ' - o cada accion debe ser demasiado especificada, todo este codigo extra(ruido), desperdicia tiempo y energia del desarrollador ',
                '',
                '- Tambien se puede dar el caso contrario, de tener comandos muy especificos para acciones muy especificas, esto peca de ser demasiado conciso, ',
                ' - obligando que el desarrollador sepa cada significado de cada expresion, esto tambien cuesta tiempo ya que no es entendible a primera vista ',
                '',
                '- Ambos extremos son malos, ya que en una industria agil y de rapida evolución, como la programación, el codigo debe ser mantenible y entendible, ',
                ' - y para que esto se cumpla, los desarrolladores han de ser capaces de entender que se debe hacer y como hacerlo de manera eficiente ',
            ]),
        new Item('tipoLenguajeProposito',
            [
                '<strong>Proposito General:</strong> Se pueden resolver multiples problemas, y a su vez no tienen que estar atados a un solo paradigma de programación ',
                ' - Aca se presentan multiples lenguajes comunes como <strong>Java</strong>, <strong>PHP</strong>, <strong>Javascript</strong>, <strong>C</strong>, <strong>Pyhton</strong>, etc...',
                '',
                '<strong>Proposito Especifico (DSL):</strong> Estan creados para un uso en particular, dentro de un ambito particular, fuera de su ambito no funcionan',
                ' - Como <strong>SQL</strong> usado para manipular y consultar información, e incluso se podrian considerar <strong>HTML</strong> y <strong>CSS</strong> ',
            ]),
        new Item(Keys.COMPILACION_AUTOMATAS,
            [
                '- Es un modelo matematico para una maquina de estado finito, mediante una serie de acuerdos y condiciones puede <em>"saltar"</em> entre <em>estados</em>',
                '',
                '<strong>Automata Finito Determinista:</strong> Es un automata finito y al mismo tiempo un sistema determinista; es decir, para cada estado en que este el automata, ',
                ' - y con cualquier simbolo del <em>alfabeto</em> existe siempre no más de una transición posible, desde ese estado y con el simbolo leido ',
                '<strong>Automata Finito No Determinista:</strong> A diferencia del anterior, posee al menos un estado, en el que para un simbolo del alfabeto, ',
                ' - existe más de una transición posible ',
                '',
                '<strong>Aplicaciones:</strong>',
                '- Software para diseñar y probar comportamientos de circuitos digitales',
                '- El <strong>Analizador Lexico</strong> de un compilador tipico, que es el componente que separa las entradas de texto en unidades logicas, ',
                ' - como identificadores, palabras clave y signos de puntuacion, etc... ',
                '- Software para explorar cuerpos de textos largos, ya sea para buscar palabras, coincidencias, contar apariciones, u otros patrones, ',
                ' - generalmente esto es conocido como <strong>Expresiones regulares</strong> y es soportado por multiples lenguajes de programación y aplicaciones ',
                '- <strong>Gramaticas:</strong> Son utiles para procesar datos con estructuras recursivas, y es usado en el <strong>Analizador Sintactico</strong>, ',
                ' - de un compilador tipico, para entender estructuras como expresiones aritmeticas, condicionales, etc... ',
                '',
                '<strong>Alfabeto:</strong> Se modela con clases de caracteres en lugar de simbolos como tal, generalmente son los caracteres que puede representar un computador ',
                '- Alfanuméricos: { a ... z, A ... Z, 0 ... 9}',
                '- Signos de puntuacion y simbolos: { ! " # $ % &  ( ) * + , \ -. / : ; < = > ? @ [ ] ^ _ ` }',
                '- Otros: { Todos los demás }',
                '',
                '<strong>Estados:</strong> Es una situación en la que se permanece cierto lapso de tiempo ',
                ' <strong>Estado Inicial:</strong> Es el primer estado',
                ' <strong>Estados de aceptación/final:</strong> Son los estados donde se puede dar por aceptado ó terminado el automata',
                ' <strong>Estados de transición:</strong> Tomando un estado y un simbolo del alfabeto como entrada, regresa el estado siguiente (tabla de transiciones)',
                ' <strong>Estados de rechazo:</strong> Estados de error, donde se recibe una entrada inesperada/invalida ',
            ]),
        new Item(Keys.COMPILACION_STRUCTURE_COMPILATOR,
            [
                '- La compilación es un proceso secuencial, donde cada fase debe ser exitosamente concluida, para poder pasar a la siguiente ',
                '- Compilar tiene diferentes significados, a continuación una definicion tomada de <i>mdn web docs</i>',
                ' - Es un programa informatico que traduce un programa escrito en un lenguaje en un programa equivalente en otro formato, ',
                ' - Esta tarea tambien puede se le llama <em>ensamblar</em> ó <em>construir</em>, que suele incluir procesos adicionales ',
                '',
                '- Un compilador es un programa informatico que traduce un programa que ha sido escrito en un lenguaje de alto nivel, a un lenguaje diferente ',
                ' - usualmente un lenguaje de bajo nivel, o lenguaje maquina(binario), aunque tambien puede ser a un codigo intermedio',
                '',
                '               <strong>Ventajas</strong>                                                             <strong>Desventajas</strong>',
                '- La ejecución del codigo traducido suele ser más rapida        - Puede ser un proceso demorado',
                '',
                '- Solo se necesita para desarrollo                              - Se debe tener un compilador, como plataformas de hardware se deseen',
                '',
                '- El codigo compilado es modificado de manera que su            - Cada cambio significa volver a realizar todo el proceso',
                ' - funcionamiento y caracteristicas quedan ocultos',
                '',
                '<strong>Fase de Analisis</strong> Tambien se le conoce como frontened, porque es donde se analiza la parte donde el codigo fuente es leido y suelen ',
                '  salir 2 elementos necesarios para la siguiente fase, como la representación intermedia del programa, y la creación de la tabla de simbolos',
                '',
                ' <strong>Análisis Lexico:</strong> Todas las palabras del lenguaje deben ser estructuras apegadas al alfabeto, y que sean palabras tambien definidas en el lenguaje',
                ' <strong>Análisis Sintáctico:</strong> Cada estructura debe respetar las reglas gramaticales, esto significa tener un sentido estructuralmente correcto ',
                ' <strong>Análisis Semántico:</strong> Se encarga del sentido con respecto a lo que significa ',
                '',
                '',
                '<strong>Fase de Sintesis:</strong> Conocido como el backend, esta genera el programa destino, en base al codigo fuente y los elementos generados previamente ',
                ' <strong>Pase:</strong> Se refiere a la travesia del compilador a traves de todo el programa ',
                ' <strong>Fase:</strong> Es una etapa distinguible que toma la entrada de la etapa anterior, procesos y salidas, que pueden ser utilizados ',
                '  - como entradas para la siguiente etapa, un pase puede tener más de una fase',
                '',
                ' <strong>Generación de codigo intermedio:</strong> Recibe la entrada del analizador semantico, en la forma de un arbol de sintaxis, ',
                '  que se puede convertir en una representación lineal, este codigo generado tiende a ser independiente de la maquina ',
                ' <strong>Optimización de codigo:</strong> Se refiere a transformar un fragmento de codigo, en otro, con un comportamiento equivalente, pero más eficiente ',
                ' <strong>Generación de codigo objeto:</strong> Convierte codigo intermedio, ya optimizado, a codigo maquina o ensamblador, que es lo que la maquina entiende',
                '',
                '                                          <strong>Tabla de simbolos</strong>                                                                                 ',
                '               &#8597            &#8597              &#8597              &#8597                &#8597            &#8597                                      ',
                '<em>Codigo</em>  &rarr;  Analisis  &rarr;   Analisis   &rarr;   Analisis   &rarr;   Codigo    &rarr;   Optimizacion  &rarr;  Codigo  &rarr;   <em>Codigo</em>',
                '<em>Fuente</em>      Lexico      Sintactico      Semantico    Intermedio        de Codigo      Objeto      <em>Ejecutable</em>                               ',
                '               &#8597            &#8597              &#8597              &#8597                &#8597            &#8597                                      ',
                '                                          <strong>Manejador de errores</strong>                                                                              ',
                '',
            ]),
        new Item(Keys.COMPILACION_ELEMENTS_COMPILATOR,
            [
                '<strong>Codigo fuente:</strong> Conjunto de lineas de texto con los pasos a seguir por la computadora, normalmente hecho con lenguajes de alto nivel ',
                '<strong>Tabla de simbolos:</strong> Creada en la fase de Analisis Lexico, tambien crece y se utiliza durante todo el proceso, aca se ',
                ' - almacenan todos los identificadores utilizados en el codigo fuente, variables, funciones, constantes, etc... ',
                '<strong>Manejador de errores:</strong> Elemento encargado de identificar, clasificar, notificar, o incluso corregir los errores, a lo largo del proceso ',
                '',
                '<strong>Alfabeto:</strong> Conjunto de simbolos utilizado para formar palabras en un determinado idioma ',
                '<strong>Lexico:</strong> ó Diccionario, simplemente es el conjunto de palabras que el idioma ofrece a sus usuarios ',
                '',
                '<strong>Análisis Lexico:</strong>',
                ' - Verficación de la pertenencia de cada simbolo presente en el codigo fuente, respecto la lenguaje en el que se fue hecho',
                ' - Clasificación de cada componente, cada palabra presente en el codigo fuente, pertenezca al lenguaje, y concuerde con los patrones permitidos ',
                ' - Creación de tabla de simbolos, registrando en ella, todos los identificadores presentes en el codigo',
                '',
                '<strong>Análisis Sintactico:</strong>',
                ' <strong>Sintaxis:</strong> Conjunto de reglas (formales ó informales, escritas ó intuitivas) usadas para precisar si una determinada cadena ',
                '  - de palabras forma parte de una oración valida',
                ' - Se verifica que las instrucciones correspondan con gramatica del lenguaje con el que fue escrito, por medio de <em>arboles de derivación</em>',
                '',
                '<strong>Análisis Semantico:</strong>',
                ' - El codigo debe tener coherencia, en la aplicación de sus estructuras en 3 aspectos ',
                '  - Tipos de datos           - Instrucciones de control            - Uso de ciclos ',
                '',
                '<strong>Generación de codigo intermedio:</strong>',
                ' - Genera una primera traducción del codigo el cual elimina aspectos caracteristicos del lenguaje de alto nivel, pero sin entrar en detalles ',
                '  - de lenguajes de bajo nivel, aca el codigo sigue teniendo independencia de la arquitectura del hardware ',
                '<strong>Optimizaciones:</strong>',
                ' - Se obtiene una versión mejorada, que sigue siendo equivalente del codigo, logrando mejorar el desempeño en la medida de lo posible ',
                '<strong>Generación de codigo objeto:</strong>',
                ' - Ultima tranformación, el resultado es un programa ejecutable, totalmente dependiente de la arquitectura del harware donde se ejecutara ',
                '<strong>Codigo Máquina:</strong>',
                ' - Sistema de codigos directamente interpretados por un circuito programable, como un microprocesador, este puede estar formado por <em>1</em> y <em>0</em>',
                '  - o bien ser <em>Ensamblador</em>, que es la representación más directa del codigo maquina, que conserva cierta legibilidad para el programador',
            ]),
        new Item(Keys.COMPILACION_STREAMS,
            [
                '- En Java, como en otros lenguajes existe la capacidad para crear estructuras propias, usar contenedores y realizar operaciones sobre estos ',
                '- Son una agregación de operaciones secuenciales o paralelas sobre un conjunto de elementos, utilizando una sintaxis más concisa y legible ',
                '- Este procesamiento es un acercamiento al paradigma funcional y facilita una gran cantidad de acciones sobre las colecciones ',
                '',
                '- Este flujo de datos(pipeline) siempre es inmutable mientras fluye por la cadena de operaciones intermedias, todo esto es lazy, ',
                ' - haciendo que las operaciones solo inicien cuando la operacional terminal, que produce el resultado deseado es iniciada, ',
                ' - y los elementos de origen solo son consumidos cuando es necesario ',
                '',
                '- El uso y la generación de los streams no es exclusivo de las colecciones, tambien se pueden producir de otros tipos de datos o acciones ',
                '- Los streams tambien permite realizar operaciones de agrupamiento y reducción, a uno solo elemento o elementos',
                '- Para evitar procesar flujos completos, existen operaciones de <em>short-circuiting</em> que interrumpen el flujo y evitan procesar/incluir resultados ',
                '',
                '<strong>Operaciones Intermedias</strong>    <strong>short-circuiting</strong>     <strong>Operaciones Finales</strong>    <strong>Agrupacion</strong>             <strong>Generacion</strong>',
                '- filter                   - anyMatch           - toArray              - groupingBy           - of       ',
                '- map                      - allMatch           - reduce               - partitioningBy       - iterating',
                '- flatMap                  - noneMatch          - collect              - joining              - concat   ',
                '- distinct                 - findFirst          - count                                       - generate ',
                '- sorted                   - findAny            - min                                                    ',
                '- peek                     - limit              - max                                                    ',
                '- skip                                          - sum                                                    ',
                '- dropWhile                                     - takeWhile                                              ',
                '',
                '<strong>Buenas practicas:</strong>',
                '- Cuando se encadenan varios metodos, siempre es buena idea colocar cada función en una linea diferente ',
                '- No olvide la comprobacion de valores nulos, en especial durante operaciones de filtrado y transformaciones(map, flatMap)',
                '- Evite el uso de las operaciones en paralelo, generalmente solo dan una mejora en altos volumenes de datos ',
                '- Nombre las variables y los parametros de manera significativa, evite variables de una sola letra',
                '- Adaptar los metodos a la necesidades, ya que los comportamientos por defecto no funcionaran, como con el <em>sorted</em>',
                '- Priorice operaciones de filtrado, antes que las de transformacion, al funcionar de manera perezosa se reducira el procesamiento de datos ',
                '',
                '- Para visualizar más operaciones y ejemplos, puedes consultar el articulo original y/o la documentación de Oracle',
            ]),
        new Item(Keys.COMPILACION_DECOMPILE,
            [
                '- Descompilar es el proceso de convertir el codigo de un programa ejecutable, a algun tipo de lenguaje de programación ',
                '- Es el proceso inverso de la compilación, donde el resultado es una serie de bits o digitos binarios listos para ser ejecutados ',
                '- Rara vez puede reconstruirse el codigo fuente original de manera exacta, por lo que tambien suele tener un componente subjetivo ',
                '- Las variables y funciones con nombres significativos suelen perderse en el proceso, por lo el codigo descompilado suele estar <strong>ofuscado</strong> ',
                '',
                '<strong>Razones para descompilar:</strong>',
                '- Recuperar el codigo fuente para modificarlo y/o comprender su funcionamiento',
                '- Depurar el programa y corregir errores ',
                '- Modificaciones en el codigo fuente, por motivos de interoperabilidad con otros sistemas',
                '- Tambien existen motivos poco eticos y/o legales como romper la protección de derechos de autor ',
            ]),
        new Item(Keys.COMPILACION_INSTRUMENTS,
            [
                '- Las bibliotecas y los frameworks son capaces de modificar el codigo en tiempo de ejecución, como forma de implementar sus funciones avanzadas ',
                '- Spring Boot y Mockito son 2 de estos instrumentos que lo hacen para desarrollo y testing respectivamente ',
                '- Para que estas puedan lograr su cometido, deben modificar las clases a nivel del bytecode antes de su ejecución ',
                '- Tambien existen manera de visualizar estos cambios y ver como han modificado las clases antes y despues, usando meta-agentes ',
                '',
                '<strong>Spring</strong> instrumentaliza estas clases mediante la generación de proxies de manera dinamica, generalmente para agregar comportamientos arbitrarios ',
                ' - a un objeto existente, el JDK solo permite esto con Interfaces, mediante el uso de <em>java.lang.reflect.Proxy</em> ',
                '- Para superar esta limitación Spring usa un <em>fork</em> de <strong>CGLIB</strong> una biblioteca que emula el comportamiento de <em>Proxy</em>',
                ' - y que puede ser usada con clases, es un fork debido a que esta libreria ha sido <strong>deprecada</strong> en favor de otras opciones ',
                '',
                '<strong>Mockito</strong> como framework de simulación para el testing, primero verifica si se estan usando mocks para retornar el comportamiento simulado, ',
                ' - de lo contrario se retornara el comportamiento normal del objeto ',
                '- Mientras que Proxy y CGLIB genera nuevas clases que extienden de la original, mockito verifica si la clase esta mockeada y asi determina cual usar ',
            ]),
        new Item(Keys.COMPILACION_OBJECT_CREATION,
            [
                '- En las aplicaciones el manejo de recursos es fundamental para crear aplicaciones con un gran rendimiento ',
                '- Cada Objeto que se crea, requiere de un espacio en memoria y de procesamiento, la cual crece entre mayor sea su complejidad ',
                '',
                'En Java la creación de un objeto, comprende de varias fases: ',
                '<strong>- Instanciación:</strong> Utilizando la palabra clave <em>new</em> Java asigna memoria para un objeto en el <strong>Heap</strong> ',
                '<strong>- Uso & Referencia:</strong> Los metodos son ejecutados y las propiedades son accesadas y modificadas ',
                '<strong>- Garbage Collector:</strong> La <em>JVM</em> automaticamente reclama memoria de los objetos que no son referenciados ',
                '<strong>- Destrución</strong> La <em>JVM</em> borra de manera completa el objeto, liberando recursos para nuevos datos ',
                '',
                '<strong>Stack Memory:</strong> Almacena llamadas a metodos, variables locales y objetos de corta duración, mediante una estructura <strong>LIFO</strong> ',
                '- Esta memoria es suceptible a <em>StackOverflowError</em> si sobrecarga con recursividad o muchas variables ',
                '',
                '<strong>Heap Memory:</strong> Utiliza una asignación dinamica de memoria para almacenar objetos y propiedades con un scope mayor ',
                '- Un uso excesivo de esta memoria puede resultar en un error de tipo <em>OutOfMemoryError</em> por falta de memoria libre ',
                '',
                '<strong>Reducir la creación de objetos:</strong>',
                '- Evite crear objetos dentro de bucles, si no es necesario, en su lugar inicialize objetos reutilizables ',
                '- Cree objetos de manera condicional, solamente en el momento previo a su uso, considerandose objetos perezosos (Lazy Initializatión) ',
                '- Use el patron <em>Builder</em> si requiere de la construcción de objetos complejos de forma incremental ',
                '- Un Pool de objetos, es una tecnica eficiente de creación de objetos y de su respectiva reutilización, ',
                ' - en lugar de crear y desperdiciar objetos costosos muy usados, como lo puede ser una conexión a Base de Datos ',
                '- Serializar y Deserializar implica conversiones hacia y desde formatos binarios, por ejemplo el almacenaje de objetos en cache, de manera externa ',
            ]),
        new Item(Keys.COMPILACION_ERRORS_AND_EXCEPTIONS,
            [
                '- En Java, como en multiples lenguajes compilados la etapa ideal para descubrir errores es durante la compilación, antes de su ejecución ',
                '- Sin embargo problemas como NullPointerException, ClassNotFoundException y otros más que no pueden ser encontrados durante la escritura ',
                '- Debido a que son excepciones que se dan en tiempo de ejecución, de aca se desprenden las excepciones controladas y no controladas(Java)',
                '',
                '<strong>Excepción No Controlada:</strong> Son excepciones y errores que se dan en tiempo de ejecución ',
                '<strong>Excepción Controlada:</strong> Son todas las excepciones y errores, exceptuando los que se dan en tiempo de ejecución',
                '',
                '<strong>- Throwable:</strong> es la clase padre de todo error y excepción en Java                                               &brvbar; Throwable &brvbar;                     ',
                '<strong>- Error:</strong> No pueden ser capturados y son fatales para el sistema                                                   &#8599    &#8598                             ',
                '<strong>- RuntimeException(Unchecked):</strong> Errores que pueden ser capturados y tienen forma de recuperación             &brvbar; Error &brvbar; &brvbar; Exception &brvbar;',
                '<strong>- CheckedException:</strong> Errores que deben ser declarados, capturados y/o relanzados y son recuperables                       &#8599     &#8598                     ',
                '                                                                                                        &brvbar; RuntimeException &brvbar;  &brvbar; Checked Exception &brvbar; ',
                '',
                '<strong>Captura y Manejo:</strong>',
                '<strong>- try... catch:</strong> Indica la captura de posibles excepciones, además de darle algun posible manejo ',
                '<strong>- try... finally:</strong> Independientemente de como se ejecute el bloque encapsulado por el try, siempre se hara la acción dentro de finally ',
                '<strong>- try... catch... finally:</strong> El mismo comportamiento anterior, agregando la posibilidad de hacer algo ante el error capturado ',
                '<strong>- try... with... resources:</strong> Usado cuando es necesario cerrar recursos despues de su uso, como Streams de I/O o Conexiones con la BD',
                '',
                '<strong>Lanzamiento y Retransmision:</strong>',
                '<strong>- throws:</strong> Declara que el metodo lanzara una excepción y quien lo use deba capturarla o continuar lanzandola en cadena ',
                '<strong>- throw:</strong> Acción especifica de lanzar una excepción para interrumpir el flujo hasta que sea capturada o manejada ',
                '',
                '<strong>Principios:</strong>',
                '- No capture excepciones con <em>Exception</em> en la medida de lo posible, capture excepciones especificas para facilitar la investigación del problema ',
                '- No oculte/ignore las excepciones, esto puede resultar de manera incontrolable y generar problemas inesperados ',
                '- Intente no combinar excepciones controladas con la programación funcional ',
                '',
                '<strong>Errores:</strong>',
                '- Representan problemas más graves durante la ejecución ya que generalmente son problemas con la <strong>JVM</strong>',
                '- Estos no se pueden controlar ya que estan fuera del alcance de la aplicación como <em>OutOfMemoryError</em> y <em>StackOverflowError</em>',
                '- Para este tipo de errores se deben solventar con soluciones más complejas, como parametrizar la JVM o un mejor manejo de los objetos ',
            ])
    ];

export const HISTORIAS_USUARIO =
    [
        new Item('historias',
            [
                '- Es uno de los elementos más usados en las metodologias agiles ',
                '- Su nivel de exhaustividad es menor a cambio de proporcionar más valor al negocio ',
                '- Las HU no son inmutables, estan pueden ser cambiadas durante su realización, no sin antes pasar por la debida negociación ',
                '- Se concentran en especificar las funciones requeridas, el porque de estas, y el contexto en el que se desarrollan ',
                '- Más que una imposición o un contrato por realizar, suele ser el resultado de una conversación entre las partes interesadas '
            ]),
        new Item('objetivos',
            [
                '- Deben esclarecer el porque, el actor de la acción, un motivo y como validarla ',
                '- Se basan en una negociación entre las partes, lo que las hace mutables a traves del tiempo ',
                '- El foco de toda función se basa en el usuario final, más que en los clientes o los desarrolladores ',
                '- Se conforman de varios aspectos, ademas de seguir el modelo INVEST ',
            ]),
        new Item('partes',
            [
                '<strong>Titulo:</strong>',
                '- Debe ser una forma concisa y clara de lo que se busca ',
                '- Tambien puede servir como identificador para cada HU ',
                '- <strong>COMO</strong> Rol <strong>QUIERO</strong> Objetivo <strong>PARA</strong> motivación ',
                '',
                '<strong>Descripción:</strong>',
                '- Puede contener una descripción más detallada de lo que se espera, sin caer en un exceso de estos ',
                '- Da el contexto donde se desarrollara la HU, mejorando la compresión del titulo ',
                '- Pueden incluir imagenes, diseños, prototipos, etc; además de las limitaciones tecnicas o de negocio',
                '',
                '<strong>Criterios de aceptación:</strong>',
                '- Son los elementos que se deben cumplir para dar a la HU como terminada ',
                '- No hay punto medio, esta o no esta completa ',
                '- Se debe evitar la ambiguedad lo más que se pueda, asi se evitan errores de interpretación ',
                '- Deben ser verificables con relativa facilidad, y cumplir con los requisitos funcionales ',
                '',
                '<strong>Discusion/Negociación:</strong>',
                '- Toda HU deberia nacer de una conversación, entre el equipo de desarrolladores y el cliente ',
                '- En el peor de los casos, se deberia al menos hacer modificaciones y evitar que se convierta en un contrato ',
            ]),
        new Item('invest',
            [
                '<strong><em>I</em> Independiente</strong> Las HU deben ser independientes entre si, aunque puden compartir criterios de aceptación ',
                '<strong><em>N</em> Negociable</strong>    La negociación debe ser la base de toda HU, no son contratos ',
                '<strong><em>V</em> Valiosa</strong>       Toda HU debe aportar valor al negocio, de lo contrario son irrelevantes o postergables',
                '<strong><em>E</em> Estimable</strong>     Toda HU debe ser medible en tiempo o esfuerzo, de manera objetiva (ideal) ',
                '<strong><em>S</em> Pequeña</strong>       Las HU deben poder realizarse en un solo sprint, por lo que puede ser subdividida de lo contrario ',
                '<strong><em>T</em> Testeable</strong>     Toda HU debe ser probada y validada de manera clara, permitiendo que se considere finalizada ',
            ]),
        new Item(Keys.USER_HISTORIES_SMART,
            [
                '<strong><em>S</em> Especifica</strong> Debe ser lo suficientemente especifica como para ser entendida ',
                '<strong><em>M</em> Medible</strong>    Ya que debe hacer lo que se pretende, segun el criterio del equipo ',
                '<strong><em>A</em> Alcanzable</strong> Toda meta debe ser ambiciosa, más no demasido como para no alcanzarla ',
                '<strong><em>R</em> Relevant</strong>   Toda tarea debe ser relevante para que contribuya a la historia y al proyecto ',
                '<strong><em>T</em> Acotada</strong>    Cuenta con un tiempo limite para ser alcanzada, y asi saber los dias en que estara lista aproximadamente ',
            ]),
        new Item(Keys.USER_HISTORIES_3C,
            [
                '- Las HU nacen como un entedimiento comun de lo que se debe hacer, independientemente de quien lo lea, o quien lo haga, de ahi nacen las 3C ',
                '',
                '<strong>Tarjeta(card):</strong> Es un breve parrafo que resume la necesidad, el porque, y para quien es util ',
                ' - Estas tarjetas tienen su propia estructura, la cual generalmente tiene 3 partes + los criterios de aceptación ',
                '',
                '<strong>Conversación(conversation):</strong> Es la comunicación cara a cara de todos lo involucrados necesarios ',
                ' - Para crear las tarjetas, Developers, Product Owner, Scrum Master, etc... y por medio de un conceso redactar la HU ',
                '',
                '<strong>Confirmación(confirmation):</strong> Suelen ser los escenarios, precondiciones y postcondiciones para que la HU se de como terminada ',
                ' - Tambien se les conoce como los criterios de aceptación y no tienen punto medio, se aceptan o se trabajan hasta que se pueda finalizar la HU',
            ]),
        new Item('gherkin',
            [
                '- El proposito del Gherkin es describir las HU y las pruebas de aceptación, en un lenguaje que todos los involucrados puedan entender ',
                '- Estan de la mano con el uso de BDD y TDD, donde todos son importantes, testers, developers, scrum master, product owner, y/o otros involucrados ',
                '',
                '- Ya con las HU realizadas y con todos correctamente empapados se suelen crear los escenearios de uso ',
                '- La estructura general de cada prueba de aceptacion suele ser: ',
                '- Dado que <em>"contexto inicial"</em> Cuando <em>"un acontecimiento o suceso"</em> Entonces <em>"resultado determinado"</em> ',
            ]),
        new Item('descomposicionHU',
            [
                '- Toda HU debe ser subdividida en tareas especificas que aporten valor y que ayuden al cumplimento de la meta planteada ',
                '- Una forma util puede ser tener una serie de tareas genericas que puedan ser modificadas segun cada proyecto como: ',
                '',
                '- Especificar cuantas pruebas unitarias estan asignadas a la HU ',
                '- Pruebas de aceptación bien definidas de la HU ',
                '- Tener claro los requisitos no funcionales que se deben cumplir ',
                '- La necesidad de revisiones y cuantas se han de hacer ',
                '- Refactorizaciones de codigo y cuanto tiempo se gastara para esto ',
                '- Correcion y/o verificación de errores, que puedan suceder despues de las pruebas ',
                '- Documentación, ya sea crearla o modificarla ',
            ]),
        new Item('storyPoints',
            [
                '- Es un concepto original de XP, que poco a poco fue adaptado por aquellos que usan SCRUM y metodologias agiles',
                '- Originalmente se hacian en base al <em>tiempo</em> que se llevaria implementar la historia, siendo relativo ',
                '- Esto se referia a tiempo realmente productivo y no solo al transcurrir del tiempo, entre otros factores',
                '- Tambien es erroneo creer que los puntos son equivalentes entre equipos y por lo tanto son comparables ',
                '',
                '- Centrarse en las estimaciones y que estas sean correctas, tambien es otro error, ',
                ' - ya que nos enfoca en mejorar las estimaciones y no en realizar acciones que den valor al producto ',
                '- Intentar cumplir con las estimaciones genera una presión que puede apresurar los resultados y afectar la calidad ',
                '- La división de tareas realmente pequeñas, tambien ayuda a completarlas eficazmente, definiendo lo realmente importante ',
            ]),
        new Item('casosVsRequisitosVsHu',
            [
                '<strong>Requisitos del sistema:</strong> Estan escritos de manera tecnica y no dependen del usuario, representan caracteristicas puras ',
                '',
                '<strong>Casos de Uso:</strong> Estan de manera que representa la interacción del usuario con el sistema, ',
                ' - estos son especificos para cada tipo de usuario identificado, son la toma de requisitos vista desde un usuario ',
                '',
                '<strong>Historias de Usuario:</strong> Describen lo que un rol, y no un usuario, desea ser capaz de hacer; además se diferencia ya que es importante ',
                ' - el valor que pueden aportar para el negocio, son hechas para que sean colaborativas, por lo que en ambientes rigidos no son ideales ',
                '',
                '- Las HU no siempre son lo más ideal a la hora de realizar, en los casos donde el cliente y los afectados no estan abiertos a la colaboración, ',
                ' - ya que son ambiguas y se necesitan comunicación constante entre las partes, para ser refinadas, algo que no siempre se va a dar ',
            ]),
        new Item(Keys.USER_HISTORIES_FORMATS,
            [
                '- Generalmente las HU se escriben con el tipico formato de <em>Como usuario quiero que...</em>, pero existen otras alternativas ',
                '',
                '<strong>Behavior Driven Development (BDD)</strong> Este enfoque ayuda a centrarse más en el comportamiento y el resultado esperado, este formato usa GHERKIN ',
                ' - In order to (Con el fin de): Identificar el objetivo o el beneficio esperado.',
                ' - As a (Como un):              Definir el rol del usuario o del sistema.',
                ' - I want (Quiero):             Describir la acción o la característica deseada.',
                '',
                '<strong>Hypothesis Driven Development (HDD)</strong> Nos empuja a pensar experimentos, validar nuestras ideas e innovar, antes de comprometernos con el desarrollo',
                ' - Creemos que [hipótesis]:                                 Establecer una suposición basada en nuestra comprensión del usuario o del mercado.',
                ' - Obtendrá como resultado [lo que esperamos]:              Predecir el efecto de nuestra hipótesis.',
                ' - Tendremos confirmación cuando [métrica de confirmación]: Definir cómo vamos a medir si nuestra hipótesis era correcta o no.',
                '',
                '<strong>Job stories</strong>:',
                ' - CUANDO un cliente necesita comprar medicamentos y productos de salud de manera conveniente',
                ' - QUIERO poder buscar, seleccionar y adquirir los artículos que necesito en línea',
                ' - PARA recibir los productos de manera rápida y eficiente',
            ]),
        new Item(Keys.USER_HISTORIES_ESTIMATIONS,
            [
                '- La estimación deberia evitar desperdiciar tiempo, por lo que es preciso elegir cual es la forma que mejor se adapta a tu equipo ',
                '',
                '<strong>Familia basada en una unidad de tamaño:</strong> Son las más tradicionales ',
                '- Se basan en estimar el tamaño de los Items de entrada al sprint o iteración, con unidades como <em>Puntos de historia</em>, <em>Tiempo real</em>, <em>Complejidad</em> ',
                '- Su uso se esta reduciendo ya que alargan mucho el tiempo para estimar y más aun si no se han mejorado los rangos de unidades ',
                '',
                '<strong>Familia NoEstimates:</strong> Se centran en evitar las estimaciones usando unidades de tamaño para cada Item, sigue siendo estimación ',
                ' - pero mas ligera, donde se cuentan los items completados y no los puntos de historia de cada item, por cada interacción o sprint ',
                '- Asi se reduce el tiempo de estimación, pero requiere que los items de entrada esten cuidados de manera que sean de tamaño similares(pequeño)',
                '',
                '<strong>Metodos derivados de Kanban:</strong> Esta familia se desvia de tomar como pieza clave el sprint o iteracción, utiliza metricas como: ',
                '<strong>- Lead Time:</strong> Tiempo total desde la solicitud hasta la entrega',
                '<strong>- Cycle Time:</strong> Tiempo de trabajo real en una tarea',
                '<strong>- Graficos de acumulación:</strong> Visualización del flujo de trabajo acumulado',
                '',
                '- Además no olvides que estos metodos se deben adaptar a las necesidades, hasta se pueden combinar ',
            ]),
        new Item(Keys.USER_HISTORIES_DOR_DOD,
            [
                '- Uno de los principios agiles es la entrega frecuente y continua de valor, y para que un equipo realize incrementos potenciales las HU ',
                '<strong>Estas Deben incluir:</strong>',
                '- En la descripción el tipico <em>Como-Quiero-para</em>',
                '- Criterios de aceptación, que funcionan como guia de lo que se debe probar ',
                '- DoR y DoD para su inclusión dentro del Sprint Backlog',
                '',
                '<strong>Definition Of Ready:</strong> Establece cuando una historia esta lista para ser desarrollada y puede incluirse en el sprint',
                '- Esta refinada y estimada',
                '- Incluye la descripción entendible para cualquier miembro del equipo ',
                '- Los detalles funcionales y especificaciones tecnicas estan claras ',
                '- No tienen bloqueos que impidan su ejecución ',
                '- Las dependencias estan identificadas y resueltas ',
                '- Puede ser probada dentro del sprint ',
                '',
                '<strong>Definition Of Done:</strong> Es cuando cumple todos los requisitos para ser aceptada por el usuario y puede ser parte de un release ',
                '- Pruebas unitarias aprobadas ',
                '- Pruebas de calidad y funcionales satisfactorias ',
                '- Criterios de aceptación cumplidos ',
                '- Requisitos funcionales y no funcionales aceptados ',
                '- Documentación realizada ',
                '',
                '- DoR & DoD se debe ir adaptando desde los primeros sprints y revisarse siempre que haya algun cambio en los entornos y los procesos ',
                '- Esto se puede hacer en las retrospectivas ya que se requiere transparencia y de llegar a acuerdos para hacerlo ',
            ])
    ];

export const METODOLOGIAS =
    [
        new Item(Keys.METODOLOGIAS_AGILES,
            [
                '- Las metodologias agiles buscan hacer que cualquier desarrollo sea de alta calidad, con tiempos y costos reducidos ',
                '- Estas permiten la rapida adaptación a cualquier caracteristica del proyecto',
                '- La participación de los clientes es fundamental en todo el transcurso del desarrollo',
                '- El progreso se mide de una manera más relevante y metodica generando metricas más precisas',
                '- Estas formas de trabajar no son marcos irrompibles pueden ser modificadas y combinadas de acuerdo a las necesidades ',
                '- Algunas de estas son: Extreme Programing, SCRUM, Kanban, Agile Inception, Desing Sprint',
            ]),
        new Item('scrum',
            [
                '- Se basa en entregas pequeñas e incrementales que van sumando al producto final',
                '',
                '<strong>Roles:</strong>',
                '<strong>- Product Owner:</strong> Es el encargado de defender los intereses del cliente y maximizar el valor del producto ',
                '<strong>- Scrum Master:</strong> Es el encargado de que el equipo de trabajo no tenga incovenientes atascantes, y vigilar la correcta implementacion de SCRUM',
                '<strong>- The Team:</strong> son los encargados del desarrollo directamente, debido a su conocimiento tecnico y de hacer las entregas a tiempo ',
                '',
                '<strong>Artefactos:</strong>',
                '<strong>- Product Backlog:</strong> Recoge el conjunto de tareas, requerimientos y funcionalidades del proyecto',
                '<strong>- Sprint Backlog:</strong> Definición de las tareas a realizar y del tiempo aproximado que deberian conllevar durante el sprint ',
                '<strong>- Incremento:</strong> Resultados del sprint, que fueron terminados satisfactoriamente, listos para añadir al proyecto ',
                '',
                '<strong>Eventos:</strong>',
                '<strong>- Planning Meeting:</strong> Planeación general donde el Product Owner prioriza las tareas a realizar para el sprint ',
                '<strong>- Daily Scrum:</strong> Seguimiento diario del proyecto, analizando posibles problemas, avances y que tareas se estan realizando ',
                '<strong>- Review:</strong> Se inspecciona el incremento realizado',
                '<strong>- Retrospective:</strong> Se da a conocer las dificultades del sprint y que cosas se pueden mejorar',
            ]),
        new Item('scrumPrinciples',
            [
                '- Scrum es uno de los marcos mas usados a la hora de desarrollar software, que funciona como un marco para la gestion de proyectos, ',
                ' - que se enfoca en el trabajo en equipo y el progreso iterativo, dirigido hacia metas/objetivos bien definidos ',
                '- Su adopción puede ser inconveniente al principio, trayendo inconsistencias o un choque cultural en la forma de realizar los trabajos ',
                '',
                '<strong>Esencia</strong>',
                ' - Comentarios rapidos     - Innovación a una mayor tasa',
                ' - Mejora continua         - Mejor adaptación ante los cambios',
                ' - Clientes más felices    - Ritmo constante y rapido para la entrega de valor ',
                '',
                '<strong>Pilares fundamentales:</strong>',
                '<strong>- Transparencia:</strong> Mostrar los hechos tal como son, todos confian entre si, por lo que pueden decir tanto malas como buenas noticias ',
                ' - esto permite que no se oculte información relevante y todo el equipo tiene una vista clara de como va el trabajo ',
                '<strong>- Inspección:</strong> Todo integrante puede hacer una inspeccion al producto, los procesos, las practicas; en busqueda de mejoras, ',
                ' - y en caso de que se haya desviado el rumbo, se corrige o se negocia los cambios a realizar, de manera que siempre haya una conversación ',
                '<strong>- Adaptación:</strong> Un lazo inherente a la mejora continua es la capacidad de adaptarse, a nuevas circunstancias o necesidades, ',
                ' - esto se traduce en una mejora de la comercialización y de un retorno a la inversión más temprano',
                '',
                '- Scrum no solo funciona por estos valores, tambien porque se adhiere a los principios agiles subyacentes de entregar valor y escuchar al cliente ',
                '',
                '<strong>Valores</strong>',
                '<strong>- Compromiso:</strong> Todo el equipo trabaja sincronizado, como una unidad ',
                '<strong>- Coraje:</strong> Cada integrante debe poder decir Si, No, Pedir ayuda y trabajar en nuevos enfoques ',
                '<strong>- Enfocados:</strong> El enfoque siempre seran los resultados, todo lo que se empieza, se debe terminar ',
                '<strong>- Apertura:</strong> El aprendizaje continua y la mejora subyacente estan al orden del dia ',
                '<strong>- Respeto:</strong> Toda relación entre el equipo, se basan en el respeto, reconociendo debilidades y fortalezas de cada uno ',
            ]),
        new Item('kanban',
            [
                '- Nacido de metodologias usadas por Toyota donde se identificaban las necesidades de manera precisa',
                '- Esta metodologia tiene ciertos aspectos superiores que SCRUM, pero su implementación depende de las necesidades ',
                '- Se basa en una metodologia de tarjetas visuales para mostrar el completado de las tareas',
                '- Facil de usar y de asumir por parte del equipo, al ser sumamente visual',
                '',
                '<strong>Principios:</strong>',
                '<strong>- Calidad:</strong> Todo debe hacerse bien a la primera, los errores son más costosos cuando se arregla algo ',
                '<strong>- Sin desperdicio:</strong> No hacer más de lo necesario (YAGNI)',
                '<strong>- Mejora continua:</strong> Siempre hay espacio para mejorar',
                '<strong>- Flexible:</strong> Las prioridades pueden cambiar',
                '',
                '<strong>Aspectos a implementar:</strong>',
                '- Definir un flujo de trabajo accesible por todos, el tablero puede contener varios proyectos simultaneamente ',
                '- Se deben tener tantas columnas como estados hallan, y las tarjetas se iran desplazando entre estas',
                '- Visualizar las fases del desarrollo, al igual que SCRUM se basa en un desarrollo incremental',
                '- La prioridad son las actividades que se estan haciendo en vez de empezar nuevas',
                '- Las fases deben estar terminadas para poder iniciar la siguiente, además de tener un maximo de tareas',
                '- Los trabajadores nunca esta inactivos, ya que pueden solapar tareas de diferentes proyectos sin problemas',
            ]),
        new Item('elevator',
            [
                '- Es una sintexis sobre ti y tu proyecto en menos de lo que sube un ascensor (1-5 minutos) ',
                '- Debe ser claro, conciso y atrayente para atraer a potenciales inversores',
                '- Debes tener una preparación previa, conocer todo lo necesario y siempre ser directo',
                '- Mide los tiempos, repasa una y otra vez lo que vayas a decir, sin dejar de lado la naturalidad ',
                '- Tu presentación debe ser sorprendente, mostrar el problema y su solución innovadora',
            ]),
        new Item('canvas',
            [
                '- Sirve para crear y definir modelos de negocios, con la prioridad de crear valor para los clientes ',
                '- Debes de llenar 9 bloques que tu empresa ha de cumplir',
                '<strong>- Segmento de mercado:</strong> ¿ Quienes son tus clientes ?, ¿ Para quien creamos valor ?, Son la base de todo tu negocio',
                '<strong>- Propuesta de valor:</strong> ¿ Que problema y como ayudamos a solucionarlo ?, Tu diferencia frente a la competencia como ventaja competitiva ',
                '<strong>- Canales:</strong> ¿ Que canales usan y cuales prefieren nuestros clientes ?, Como vas a distribuir tu producto',
                '<strong>- Comunicación:</strong> ¿ Que relaciones haz creado con tus clientes, es la indicada ?, Como te comunicaras con tus clientes ',
                '<strong>- Ingresos:</strong> ¿ Porque se paga actualmente y hasta que punto estarian dispuestos ?, Como ganaras dinero y de que fuentes ',
                '<strong>- Recursos:</strong> ¿ Necesidades claves para nuestra propuesta de valor ?, Cosas como derechos de autor, personal, fondos, patentes, etc..',
                '<strong>- Actividades:</strong> ¿ Actividades claves requeridas para nuestra propuesta ? , Producción, soluciónes, plataformas, etc... para que tu modelo funcione ',
                '<strong>- Socios:</strong> ¿ Socios y Proveedores claves ?, Quienes te ayudaran a conseguir los recursos necesarios ',
                '<strong>- Costos:</strong> ¿ Principales costos de mayor a menor ?, Definiendo cuanto gastar y como gastarlo ',
            ]),
        new Item(Keys.METODOLOGIAS_MODEL_BING_BANG,
            [
                '- Es el modelo más simple, requiere de poca planificación a costa de absorber muchos recursos(tiempo, esfuerzo, personal) ',
                '- Se basa conceptualmente en la teoria del <em>Bing Bang</em>, donde el universo nacio despues un gran estallido inicial ',
                '- Asi es posible que el producto sea la mejor versión posible en base a los argumentos y necesidades iniciales',
                '- No se recomienda para proyectos grandes ni que tengan proyecciones a largo plazo ',
                '- Se puede usar en proyectos de expirementación, o donde el aprendizaje y la sabiduria es más valioso que el proyecto en si',
                '- Este modelo tambien es muy flexible ante los requerimientos, por lo que el riesgo y la incertidumbre son muy altos ',
                '- Es facil de gestionar ya que todas las etapas se hacen antes de entregar cualquier producto ',
            ]),
        new Item('cascada',
            [
                '- Es un metodo secuencial donde cada etapa se desarrolla una sola vez',
                '- Las fases del desarrollo no estan bien definidas y se pueden solapar entre si',
                '- Errores en etapas previas pueden ser fatales si no se corrigen con premura',
                '- Bastante inflexible en cuestion de cambios sin previo aviso',
                '- Los usuarios solo son consultados en etapas finales e iniciales, poca comunicación en etapas intermedias ',
            ]),
        new Item('espiral',
            [
                '- Es la evolución del modelo en cascada',
                '- Se basa en la repetición de las mismas tareas, haciendo controles con más periocidad ',
                '- Se reduce el riesgo del fracaso al dividir el proceso en partes más pequeñas ',
                '- Cada ciclo se planifica justo depues de terminar el objetivo del presente ',
                '- Los errores pueden evolucionar con cada ciclo, no necesarimente resolverse ',
            ]),
        new Item('iterativo',
            [
                '- Cada entrega es un proyecto más completo',
                '- En cada oportunidad se pueden añadir nuevas funciones o actualizar las existentes ',
                '- Resiliencia frente a cambios inesperados, mayor comunicación con el cliente',
                '- Permite desconocer detalles iniciales que se iran solucionando con las iteracciones ',
                '- Es funcional desde el primer ciclo, permite mejorar las estimaciones del proyecto ',
            ]),
        new Item('extrema',
            [
                '- Muy utilizada en la gestión de proyectos ',
                '- Se centra en potenciar las relaciones intepersonales de los equipos ',
                '- Mejorando el ambiente laboral y manteniendo un aprendizaje continuo ',
                '- La retroalimentación es un aspecto fundamental para la mejora continua ',
                '- Debe ser planificada, pero flexible al cambio ',
                '- Los Sprints son cambiados por iteracciones ',
                '- Maneja los siguentes roles: ',
                ' - Equipo, Tester, Tracker, Coach, Big Boss ',
            ]),
        new Item(Keys.METODOLOGIAS_MODEL_V,
            [
                '- Desciende del modelo en cascada e igual que este consta de las siguentes fases: ',
                '- Es un modelo facil de seguir y el emparejamiento entre las etapas logra una mejor localizazion de fallos ',
                '- El producto final solo es obtenido al final de todas las fases por lo que es demorado y puede ser diferente de lo que se pidio ',
                '',
                '       <strong>Ciclo de desarrollo</strong>                               <strong>Ciclo de testing</strong>',
                ' &darr;  Definición de requerimientos          &rarr; &rarr;         Pruebas de aceptación   &uarr; ',
                ' &darr;    Diseño funcional del sistema        &rarr; &rarr;       Pruebas de sistema        &uarr; ',
                ' &darr;      Diseño tecnico del sistema        &rarr; &rarr;     Pruebas de componentes      &uarr; ',
                ' &darr;        Especificación de componentes   &rarr; &rarr;   Pruebas unitarias             &uarr; ',
                ' &darr;                                    Codificación                            &uarr;           ',
            ]),
        new Item('rup',
            [
                '- Diseñado y documentado para usar UML ',
                '- Es considerado bastante pesado, pero muy versatil y adaptable ',
                '- Cada miembro del equipo puede acceder a la misma base de conocimientos, mejorando la productividad ya que todos tienen en mente la misma meta ',
                '',
                '            Requerimiento                ',
                '                  &rarr;                   ',
                '  Evaluación &uarr;        &darr; Implementación ',
                '                  &larr;                   ',
                '               Prueba                    ',
                '',
                '<strong>Roles:</strong>',
                '<strong>- Analistas:</strong> Acciones que van desde la toma de requisitos, hasta la refinación ',
                '<strong>- Desarrolladores:</strong> Profesionales como arquitectos, diseñadores, Administradores de bases de datos, Integrador ',
                '<strong>- Gestores:</strong> Jefes de proyecto, Jefes de pruebas, Encargado de despliegues ',
                '<strong>- Apoyo:</strong> Documentador, Artistas graficos, Desarrollador de cursos ',
                '<strong>- Pruebas:</strong> Analista de pruebas, Diseñador de pruebas, Encargado de las pruebas ',
                '',
                '<strong>Directrices:</strong>',
                '<strong>- Requisitos de gestión:</strong> Documentar las funcionalidades del sistema, sus limitaciones, requisitos del negocio, etc.. ',
                '<strong>- Arquitectura basada en componentes:</strong> Crea un sistema facilmente extensible, haciendo referencia al uso de POO a la hora programar ',
                '<strong>- Uso de elementos visuales:</strong> Es una forma de comprender mejor el sistema de manera general, normalmente mediante diagramas UML ',
                '<strong>- Comprobar la calidad:</strong> La calidad debe estar siempre presente en todas las fases del proceso ',
                '',
                '<strong>Fases:</strong>',
                '<strong>- Diseño:</strong> Fase inicial de la cual se generan los elementos necesarios para fases proximas',
                '<strong>- Elaboración:</strong> Descripción del producto y de los costos/beneficios de las fases proximas ',
                '<strong>- Construcción:</strong> Desarrollo del software como tal, e incluyen las pruebas del mismo ',
                '<strong>- Transición:</strong> Se lleva a cabo el plan de despliegue y seguimiento del software ',
            ]),
        new Item('kaizen',
            [
                '- <em>Kai</em> y <em>Zen</em> Terminos japoneses que significan respectivamente acción de cambio y mejora continua ',
                '- Consiste en eliminar las ineficiencias de tu sistema productivo, todos los dias se debe mejorar algo ',
                '1 <strong>Planificar:</strong> Debes ser consciente de tu situación, analizar los problemas y definir un plan de acción con lo que quieres mejorar ',
                '2 <strong>Hacer:</strong>      Desarrollar el plan para cada uno de los aspectos que has identificado ',
                '3 <strong>Comprobar:</strong>  Debes analizar que tu plan si este dando resultados, de lo contrario deberas volver a empezar ',
                '4 <strong>Actuar:</strong>     Si has logrado cumplir los objetivos marcados, entonces es hora de estandarizar y continuar con las mejoras ',
                '',
                '<strong>La importancia de los empleados</strong>',
                '- Una gran ventaja de esta metodologia es que no siempre son necesarias cuantiosas inversiones para obtener resultados',
                '- Debido a que todos los empleados son tomados en cuenta a la hora de tomar decisiones, aportando ideas y soluciones desde diferentes niveles ',
                '- Esto tambien aumentara la productividad y su motivación, lo que a la larga se convierte en un beneficio añadido ',
            ]),
        new Item(Keys.METODOLOGIAS_SCRUMBAN,
            [
                '<strong>Combina las mejores caracteristicas de ambos permitiendo:</strong> ',
                '- Tener la naturaleza preceptiva de scrum ',
                '- El enfoque de calidad y de evitar el desperdicio de Kanban ',
                '- Migrar o mantener metodologias agiles de desarrollo ',
                '- Mejora continua de procesos ',
                '- El mantenimiento y el desarrollo van juntos, y deben ser complementarios ',
                '',
                '<strong>Tener en cuenta:</strong>',
                '- Seguir usando los tableros y labores vigentes ',
                '- No dejar de perseguir la mejora continua ',
                '- Respetar las labores y responsabilidades actuales, mientras se intentan mejorar ',
                '- Al tomar elementos de 2 metodologias diferentes, puede causar ambiguedades o confusiones en el equipo ',
                '',
                '<strong>Cuando usarlo:</strong>',
                '- Mantenimiento de proyectos dirigidos por eventos ',
                '- Gestion de proyectos problematicos ',
                '- Desarrollo de nuevos productos, posteriores al sprint ',
                '- Mejora continua de la gestión '
            ]),
        new Item(Keys.METODOLOGIAS_LEAN,
            [
                '- La idea principal es maximizar el valor de cara al cliente, y minimizar el desperdicio ',
                '- Los procesos claves deben estar enfocados hacia el aumento de valor de manera continua, mientras se optimizan el flujo ',
                ' - de los productos y servicios de manera horizontal, desde departamentos, tecnologias, y personas, hasta llegar a los clientes ',
                '',
                '<strong>Ideas base</strong>',
                '- Entregar valor, entendido desde la perspectiva del cliente ',
                '- Eliminar residuos, donde esto abarca todo aquello que no aporte al producto final ',
                '- Avanzar hacia la excelencia, mediante la mejora continua ',
                '',
                '<strong>Origen</strong>',
                '- Este proceso data desde los años 1940, derivado del sistema de producción de Toyota, y como su fabricación que se ajustaba continuamente, ',
                ' - lograron mejorar significativas en productividad, eficiencia, costos, y cantidad de ciclos ',
                '',
                '<strong>Principios</strong>',
                '<strong> - Identifique el valor:</strong> Esto radica en el problema que se esta intentado solucionar, y que el cliente no esta dispuesto a pagar ',
                '  - cualquier actividad o proceso que no aporte valor, por lo se puede remover, para enfocarse en el valor que se desea entregar ',
                '<strong> - Asignar flujos de valor:</strong> Se identifican todas las acciones y personas involucradas, en la entrega del producto final ',
                '  - asi se puede identificar que no aportan valor para el cliente, y por consiguiente puedan ser eliminadas ',
                '<strong> - Creación de flujos:</strong> Una vez idenficado lo valioso, hay que velar por el mantenimiento del flujo de trabajo de cada equipo ',
                '  - evitando cuellos de botella e interrupciones que retrasan o desvian el avance ',
                '<strong> - Sistema de trabajo:</strong> Asi se asegura un flujo de trabajo estable, donde las tareas solo se inician si existe una demanda y/o necesidad real ',
                '<strong> - Mejora continua:</strong> Habiendo cumplido los pasos anteriores, se debe vigilar que se sigan cumpliendo, y en caso de problemas ',
                '  - el sistema no podra mantenerse ni aislado ni estatico, aca es fundamental la participación de las personas para una mejora continua ',
                '',
                '- De la misma manera que otras metodologias, no hay una receta, ni una practica estandarizada, por lo que se debe tomar como una filosofia, ',
                ' - de la gestión que busca mejora los procesos y productos a largo plazo, de manera sistematica y gradual, que se visualiza ',
                ' - segun la interpretación del lider, que es además el encargado de ejecutarla '
            ])
    ];

export const TESTING_ADVANCED =
    [
        new Item('cajaNegraBlanca',
            [
                '<strong>Caja blanca:</strong> Este tipo de testing se realiza sabiendo la estructura y funcionamiento interno del codigo ',
                '<strong>Caja negra:</strong> En este metodo solo se conoce las entradas y salidas del proceso, teniendo todo su funcionamiento interno oculto ',
                '',
                '- Generalmente los tests de caja blanca son hechos por los desarrolladores, y los de caja negra por las personas que conocen del negocio ',
                '',
                '- Tambien se suelen mencionar los test de Caja gris, que se considerarian un punto medio, ',
                ' - donde la persona encargada conoce del negocio y de su implementación, más no con una gran profundidad para probar detalles particulares ',
            ]),
        new Item(Keys.TESTING_ADVANCED_VALOR_LIMITE,
            [
                '- Esta tecnica se basa en la heuristica de que los errores son más probables en los valores extremos de las entradas ',
                '- Los valores escogidos son aquellos que se encuentran por encima o debajo de las clases de equivalencia ',
                '- Los casos de prueba con esta tecnica son especialmente utiles para detectar errores de manera temprana en sistemas criticos ',
                '- Se pueden considerar una frontera entre el comportamiento normal del sistema y un punto de error conocido/desconocido para el sistema ',
                '- Dependiendo del tipo de dato de la entrada, se suele escoger las pruebas para que cumplan los siguientes escenarios: ',
                '',
                ' <strong>n</strong>   Valor en el rango normal                 <em>Ejemplo:</em>                      <strong>Dias de la semana</strong>     ',
                ' <strong>n-1</strong> Valor cercano al limite minimo           | Otro  | Domingo  | Lunes Martes Miercoles Jueves Viernes | Sabado   | Otro  |',
                ' <strong>n+1</strong> Valor cercano al limite maximo           | Error | Limite   |             Rango Normal              | Limite   | Error |',
                '                                              |       | Inferior |                                       | Superior |       |                 ',
            ]),
        new Item('clasesEquivalencia',
            [
                '- Esta tecnica considera que todas las entradas del programa se pueden clasificar en 2 tipos, y solo pueden pertecer a uno respectivamente ',
                '<strong>Valores Validos:</strong> Entradas que No deberian provocar ningun error ó mal funcionamiento del sistema ',
                '<strong>Valores No Validos:</strong> Entradas que inducen al error ó casos no cobijados durante el desarrollo ',
                '',
                '- Todos los elementos de una partición teoricamente se deben comportar igual, por lo que solo basta escoger uno del grupo para probar ',
                '- Las clases de equivalencia puende ser de distintos tipos: ',
                ' - Rangos',
                ' - Valores especificos',
                ' - Conjuntos de valores',
                ' - Condiciones binarias, etc.. ',
                '',
                '- De acuerdo a cada tipo se deberia sacar las clases de equivalencias validas e invalidas ',
                '- Si se da el caso, tambien se deberian probar los valores limite del sistema ',
            ]),
        new Item('grafosCausaEfecto',
            [
                '- Estos grafos representan una relación logica entre distinas causas y sus posibles efectos ',
                '- Donde una causa (entradas) pueden generar en diversos efectos (salidas) ',
                '- Estas entradas y salidas tambien se pueden combinar para elaborar complejas reglas de negocio ',
            ]),
        new Item('tiposDePruebas',
            [
                '<strong>Pruebas Funcionales</strong>',
                '',
                '<strong>- Unitarias:</strong> Son pruebas de funciones especificas del sistema que se pueden tomar como una parte individual de la generalidad ',
                '<strong>- Integración:</strong> Se juntan partes especificas y se prueban como un grupo en especifico ',
                '<strong>- Extremo a extremo:</strong> Se prueba todo el sistema como un todo, su funcionamiento general y no particular ',
                '<strong>- Humo:</strong> Se concentran en verificar que con cada cambio que se haga el sistema siga funcionando bien de manera general ',
                '<strong>- Camino feliz:</strong> Aca solo se crean casos que se conocen y que no deberian fallar ',
                '<strong>- Aceptación:</strong> Realizadas por el cliente con el proposito de aceptar, o no el producto ',
                '<strong>- Alfa:</strong> Estan enfocadas a identificar posibles problemas antes de un release (lanzamiento) ',
                '<strong>- Beta:</strong> Se realizan en un ambiente real, desde la perspectiva de un usuario para satisfacer a los clientes ',
                '',
                '<strong>Pruebas NO Funcionales</strong>',
                '',
                '<strong>- Penetración:</strong> Son pruebas de seguridad, con el objetivo de penetrar los puntos debiles del sistema   ',
                '<strong>- Carga:</strong> Tienen el objetivo de averiguar cuanta carga de trabajo puede manejar un sistema sin degradaciones importantes ',
                '<strong>- Estres:</strong> La intención es saber en que punto un sistema deja de funcionar y porque ',
                '<strong>- GUI:</strong> Se prueba la interfaz grafica del usuario y que esta se adapte al publico enfocado, además de que funcione ',
                '<strong>- Ad-hoc:</strong> No tienen ninguna base o referencia por lo que su impredecibilidad puede romper las cosas ',
                '<strong>- Recuperación:</strong> Valida la capacidad del sistema para recuperarse de posibles fallos ',
                '<strong>- Regresión:</strong> Cualquier cambio de una funcionalidad no debe afectar lo que ya estaba funcionando ',
                '<strong>- Compatibilidad(software):</strong> Se prueba que el software actual soporte las versiones previas ',
                '<strong>- Compatibilidad(Hardware):</strong> Se prueban diferentes entornos de hardware para saber donde y como puede correr ',
                '<strong>- Internalización:</strong> Que tambien se adapta un sistema para su uso en diferentes contextos geograficos ',
            ]),
        new Item('outsideInside',
            [
                '- En el TDD se suelen encontrar 2 enfoques diferentes ',
                '',
                '<strong>Escuela clasica (Inside-out)</strong> Tiene en cuenta conceptos originales de Kent Beck, Stephen Freeman y Nat Pryce como: ',
                '- Triangulación: Que se basa en obtener varios casos especificos, con los cuales se pueda implementar una solución generica ',
                '- Verificación: Que se centra en usar los objetos reales previamente configurados, con interacciones reales ',
                '',
                '<strong>Escuela de Londres (Outside-in):</strong> Su proposito sigue siendo el mismo pero la manera de alcanzarlo es diferente ',
                '- Verificar el comportamiento y las interacciones de los objetos más que sus estados ',
                '- Asi se puede ahorrar todo el trabajo de la creación de los objetos y solo usar dobles(mocks)',
            ]),
        new Item('casosDePruebas',
            [
                '- Entre más complejo sea un software, mayor sera la posibilidad de sufrir defectos ',
                '- Un caso de prueba es un conjunto de condiciones y variables, bajo un mismo ambiente que determinara si, ',
                ' - alguna caracteristica esta completa o parcial, y si lo cumple de manera satisfactoria ',
                '',
                '- Para lograr esto, deberia crearse al menos un caso de prueba por cada requisito definido: ',
                ' - Los ciclos de pruebas deben ser fluidos y eficientes ',
                ' - Los casos deben estar escritos de manera clara y comprensible ',
                ' - La ejecución debe ser facil o estar guiada de no poder serlo ',
                ' - Tener las entradas y salidas debidamente especificadas ',
                ' - Definir los comportamientos esperados y como invocarlos ',
                '',
                '- Tambien pueden tener estados despues de su finalización: ',
                '<strong> - Exito:</strong> Todos los pasos y el comportamiento ha sido el esperado ',
                '<strong> - Fallido:</strong> Si alguno de los pasos es erroneo ',
                '<strong> - Bloqueado:</strong> Si este no se puede realizar debido a una secuencia especifica no posible, o fallos previos ',
                '<strong> - N/A:</strong> Ya no aplica debido a cambios en la funcionalidad o los requisitos asociados ',
                '',
                '- Pasos a tener en cuenta: ',
                ' - Identificar los requirimientos a probar y enumerar los casos de cada requisito ',
                ' - Realizar una matriz de trazabilidad para vincular los requerimientos y sus casos de prueba',
                ' - Escribir una descripción general del caso, que permita a personas con o sin conocimientos previos entender la prueba ',
                ' - Conocer los prerrequisitos a tener en cuenta para la prueba ',
                ' - Definir la prioridad de cada caso (alta, media, baja) ',
                ' - Secuencia de pasos y su descripción para realizar la prueba ',
                ' - Descripción de los resultados, sea exitosa o no lo sea ',
            ]),
        new Item('casosDeUso',
            [
                '- Descripción del conjunto de interacciones del sistema con uno o varios actores para alcanzar un objetivo ',
                '- Este debe incluir las multiples rutas posibles (escenarios) que el usuario puede tomar ',
                '- Aca se ha de tener en cuenta factores como que proceso se va a realizar, que actor lo va ejecutar y como lo hara ',
                '- Estos detallan las funcionalidades del sistema',
            ]),
        new Item(Keys.TESTING_ADVANCED_SMELLS_CODES1,
            [
                '<strong>Convenciones de nombres:</strong>',
                '<strong>- Mistaken identity:</strong> Cuando el nombre de una prueba es contrario a lo que esta haciendo ',
                '<strong>- Anonymous test case:</strong> Cuando su nombre no describe lo que se esta probando ',
                '<strong>- Testy test:</strong> Cuando una prueba tiene la redundancia de que indica que es una prueba ',
                '<strong>- Ni verbos ni sustantivos:</strong> Esta tiene el nombre del concepto pero no del comportamiento previsto ',
                '',
                '<strong>Estructurales:</strong>',
                '<strong>- Todo es una propiedad:</strong> Cuando variables temporales se mantienen como variables de instancia ',
                '<strong>- Falta de parametrizacion:</strong> Cuando se llaman metodos fuera del metodo de tests o se hace un 2x1 en un mismo test ',
                '<strong>- Test de integracion enmascarado:</strong> Demasiadas capas estan involucradas en un test ',
                '<strong>- El Parasito:</strong> Los tests deben ser independientes y nunca depender de otros tests previos ',
                '<strong>- Pruebas cuajadas:</strong> Union inapropiada de varios tests o division innecesaria ',
                '',
                '<strong>Inicializacion y desmontaje (setup, teardown)</strong>',
                '<strong>- The First and Last Rites:</strong> Metodos repetivos en cada prueba al iniciar y finalizarla, en vez de una configuracion comun ',
                '<strong>- Oversharing on setup:</strong> Uso excesivo de datos compartidos que no todos los tests necesitan ',
                '<strong>- Test setup is somewhere else:</strong> La parte del Given y el When estan en otro lugar, la prueba solo hace las validaciones ',
                '<strong>- Well, My Setup Works:</strong> El test se puede desviar o duplicar el codigo de produccion innecesariamente por no compartir configuraciones ',
                '<strong>- Data-ja vu:</strong> Los datos que pueden ser inmutables y compartidos se instancian innecesariamente con cada test ',
                '<strong>- Limpieza dolorosa:</strong> Cuando se necesita crear o destruir un recurso cosotoso y la separacion del test con este es debil o muy larga ',
                '',
                '<strong>Codificacion</strong>',
                '<strong>- Herp Derp:</strong> Cuando algo que es parte fundamental del test esta como comentario pero no codificado ',
                '<strong>- Sobre refactorizar:</strong> Se ha aplicado tando DRY al codigo de pruebas que ha perdido significado y legibilidad ',
                '<strong>- Boilerplate hell:</strong> No se puede entender el tests ya que hay demasiado codigo, indicando la falta de fabricacion de datos ',
                '<strong>- Half a helper method:</strong> Cuando hay metodos de utilidad que no preparan todas las cosas como las necesita el test ',
                '<strong>- Automatizacion:</strong> Si el codigo de tests es autogenerado, es necesario revisarlo para saber que no es inutil o esta mal ',
                '',
                '<strong>Datos</strong>',
                '<strong>- What are we Testing ?</strong> Los datos del tests no son claros en lo que son o hacen ',
                '<strong>- Missing test data factory:</strong> Cuando cada tests construye sus propios datos en vez de tener un metodo comun para esto ',
                '<strong>- Unworldly Test Data:</strong> Son datos que sirven para el contexto de la prueba pero no son reales ',
                '<strong>- Wheel of fortune</strong> Los datos aleatorios pueden conducir al fallo de las pruebas, haciendolas erraticas ',
                '<strong>- Time Bomb Data:</strong> Cuando se prueban informacion con fechas, si no se tiene cuidado estos datos pueden volverse erraticos ',
            ]),
        new Item(Keys.TESTING_ADVANCED_SMELLS_CODES2,
            [
                '<strong>Aserciones - frameworks</strong>',
                '<strong>- Chat logging:</strong> Se usan mensajes por consola o logs para suplir el fallo de una asercion ',
                '<strong>- Bumbling assertions:</strong> Se escogen a voluntad afirmaciones poco sofisticadas y de facil verificacion ',
                '<strong>- Assertion diversion:</strong> Cuando se escoge la asercion erronea para que el fallo de la prueba sea más facil de entender ',
                '<strong>- Equality Sledgehammer Assertion:</strong> Se crean aserciones demasiado completas para no pensar en una mas general e indicativa ',
                '<strong>- Martini Assertion:</strong> En vez de verificar todo, se verifica lo que sea y como sea para que el test pase ',
                '<strong>- Conditional assertions:</strong> Sobreesfuerzo en la verificacion donde las aserciones son dinamicas de acuerdo a la ejecucion del codigo de pruebas ',
                '<strong>- Fuzzy assertions :</strong> La falta de control en el sistema conlleva a no predecir resultados exactos si no coincidencias parciales ',
                '',
                '<strong>Pruebas<strong>',
                '<strong>- The True Believer:</strong> La prueba convence al autor de que el codigo esta bien y no que tal vez esta erroneo ',
                '<strong>- Assert the world:</strong> Las aserciones prueban todo, hasta detalles sin sentido ',
                '<strong>- Circumstantial evidence:</strong> Las aserciones comprueban comportamientos indirectos ',
                '<strong>- Blinkered assertions:</strong> Las afirmaciones fallan en comprobar el panorama general al centrarse en subconjuntos de detalles ',
                '',
                '<strong>Locura por los mocks</strong>',
                '<strong>- Overmocking:</strong> Son pruebas de caja blanca que siempre pasan ya que todo es perfecto ',
                '<strong>- Mock madness:</strong> Cuando se abusa de los mocks hasta para crear simples objetos primitivos como POJOs',
                '<strong>- Remote Control Mocking:</strong> La clase que depende de un servicio se prueba con la dependencia simulada y no el servicio en si ',
                '<strong>- The telltale heart:</strong> Cuando existe codigo de produccion que solo cobra sentido en la ejecucion de los tests ',
                '',
                '<strong>Inestables</strong>',
                '<strong>- The Inhuman Centipede:</strong> No solo sucede cuando existe una prueba dependediente de otra, si no que hay una secuencia especifica para que no fallen ',
                '<strong>- Is There Anybody There ? </strong> Prueba o codigo inestable que dañan la compilacion ocasionalmente ',
                '<strong>- The Leaky Cauldron:</strong> Prueba sensible a condiciones creadas por otras pruebas o que corrompe a otras ',
                '<strong>- The Soloist:</strong> Solo funciona cuando nadie más se esta ejecutando ',
                '<strong>- The Bandwidth Demander:</strong> Si el sistema esta lento este test fallara, debido a procesos internos pesados ',
                '<strong>- The Temporal Tip Toe:</strong> Un test que utiliza el tiempo para coordinar eventos concurrentes, y aprovecha la suerte de tener tiempos perfectos ',
                '',
                '<strong>Implementacion</strong>',
                '<strong>- I wrote it like this:</strong> Probando la implementación conocida, en vez del resultado ',
                '<strong>- Contortionist testing:</strong> Debido a que las pruebas fueron escritas despues del codigo, este debe esforzarse para funcionar ',
                '<strong>- The Hans Moretti Sword Box:</strong> Entre mas tests se agreguen a los puntos testeables, menos se evitaran las vias no descubiertas del codigo ',
            ]),
        new Item(Keys.TESTING_ADVANCED_MUTATION,
            [
                '- Es una tecnica de pruebas para encontrar fallas en las variaciones de un software y determinar la efectividad de las pruebas ',
                '- Una mutación es una prueba con una ligera modificación del codigo, si estas llegan a pasar el mutante sobrevivio, por lo que el codigo esta mal ',
                '- Entre menos mutaciones sobrevivan, mejor sera la calidad del codigo probado ',
                '- Tambien se ha de tener en cuenta que pueden existir mutantes equivalentes, que hacen lo mismo que el codigo original, solo que con otra sintaxis ',
                '',
                '<strong>Casos:</strong>',
                ' - Cambiar valores usados en el codigo original, como empezar un ciclo en 1 y no en 0, etc... ',
                ' - Eliminar, intercambiar o duplicar bloques de codigo declarados ',
                ' - Decisiones al comparar valores, ya sea intercambiando un == por un != por ejemplo',
                '',
                '<strong>Ventajas:</strong>',
                ' - permiten cubrir gran parte de la logica a probar ',
                ' - detecta errores de facil alusión ',
                ' - verifica la efectividad de nuestro conjunto de pruebas y si es necesario aumentarlas o corregirlas ',
                '',
                '<strong>Desventajas:</strong>',
                ' - consumen una gran cantidad de recursos ',
                ' - es necesario contrarrestar mutantes que no tienen sentidos o no son validos en el contexto de la prueba ',
                '',
                '<strong>Supuestos en lo que se basan:</strong>',
                ' - Programadores competentes: Si un programador es capaz de escribir y probar segmentos pequeños, tambien lo hara con más grandes ',
                ' - Efectos del acoplamiento: Si se combinan 2 formas para formar un programa y ambas son buenas, entonces lo combinación tambien lo sera '
            ]),
        new Item(Keys.TESTING_ADVANCED_ANTI_PATTERNS,
            [
                '- <em>TDD</em> es una practica conocida para realizar pruebas, por lo que no esta excenta de malas practicas y antipatrones en su uso',
                '- Existen una gran variedad de malas practicas y codesmells, por lo que estos solo se consideran una aproximación inicial ',
                '',
                '<strong>The Liar:</strong> Toda prueba que se ejecuta, pero esta probando algo totalmente diferente, generando falsa seguridad',
                '',
                '<strong>Excesive Settup:</strong> Es comun cuando existe una mala arquitectura e importan más la pasos previos, que las verificaciones y el testing ',
                '',
                '<strong>The Giant:</strong> Una unica prueba, que prueba multiples escenarios, con muchos asserts no relacionados, son dificiles de entender y más de modificar',
                '',
                '<strong>The Mockery:</strong> Donde el sistema a probar, ha sido reemplazado por un mock, asi pasan por temas de cobertura, sin probar nada de verdad ',
                '',
                '<strong>Generous Leftover:</strong> Son pruebas que dejan restos sin limpiar y hacen que pruebas subsiguientes fallen, pero estas no fallan de manera individual ',
                '',
                '<strong>The Hidden Dependency:</strong> Es una prueba que requiere de forma secreta, alguna configuración o particularidad del entorno, que no esta presente',
                '',
                '<strong>The Stranger:</strong> Es una prueba totalmente valida y posiblemente bien estructurada, con el defecto de que no esta relacionada directamente con el <em>SUT</em>',
            ]),
        new Item(Keys.TESTING_ADVANCED_APDEX,
            [
                '- Es un estandar de la industria para medir la satisfacción de los usuarios con el tiempo de respuesta de las aplicaciones y servicios Web, ',
                ' - en lugar de metricas tradicionales que se pueden distorsionar, como el tiempo de respuesta promedio ',
                '- Esta puntuación es un valor de relación entre la cantidad de solicitudes satisfechas y toleradas, y el total realizadas ',
                '- Cada solicitud satisfecha cuenta como una solicitud',
                '- Cada solicitud tolerada cuenta como la mitad de una solicitud satisfecha ',
                '- La puntuación varia de 0 a 1, siendo 0 el peor y 1 el mejor',
                '- Esta medición esta hecha para aplicaciones de alto rendimiento, de lo contrario los datos provocaran resultados inestables ',
                '',
                '- Es necesario definir un umbral de manera arbitraria <strong>T</strong> y asi saber que peticiones recaen en cada definición ',
                '<strong>Satisfecho:</strong> El tiempo de respuesta es menor o igual a T, indicando que no existen problemas ',
                '<strong>Tolerancia:</strong> El tiempo de respuesta es mayor que T y menor o igual que 4T, algo que un usuario final podria notar ',
                '<strong>Frustrado:</strong> El tiempo de respuesta es mayor a 4T o la solicitud devuelve un error del lado del servidor, insatisfacción ',
                '',
                '- Una tasa de error alta puede provocar que tenga una tasa promedio satisfactoria, pero una puntuación Apdex baja ',
                '- Tambien se pueden dividir las puntuaciones especificas en calificaciones, para hacerlas más entendibles e informativas ',
                ' - Excelente(1 - 0.94)     ',
                ' - Buena(0.93 - 0.85)      Apdex Score = <u> (Satisfied + Tolerating/2) </u>',
                ' - Regular(0.84 - 0.70)                         Total samples               ',
                ' - Mala(0.69 - 0.49)',
                ' - Inaceptable(0.48 - 0)',
            ]),
        new Item(Keys.TESTING_ADVANCED_COSTS,
            [
                '- Las pruebas son fundamentales para garantizar la calidad y la confiabilidad, pero estas tienen multiples aspectos a tener en cuenta ',
                '- Estos conceptos estan interconectados y se afectan directamente e indirectamente por lo que se intentan equilibrar los costos y la calidad ',
                '',
                '<strong>Complejidad:</strong> La complejidad del producto/sistema juega un papel directamente proporcional en el tiempo y esfuerzo realizados ',
                '<strong>Alcance:</strong> Es la amplitud profundidad y detalles a considerar al realizar las pruebas ',
                '<strong>Duración:</strong> Periodos largos de prueba afectan el tiempo y los recursos invertidos además de la minuciosidad del proceso ',
                '<strong>Recursos:</strong> La disponibilidad y asignación de recursos no puede ser ilimitada, tampoco debe caer en el extremo de ser deficiente ',
                '<strong>Herramientas:</strong> Las herramientas más completas suelen ser de paga y son necesarias si se requieren resultados más precisos y detallados ',
                '',
                '<strong>Entornos de pruebas:</strong> Un entorno simulado generalmente requiere menos recursos en comparación a un entorno real y/o productivo ',
                '<strong>Cobertura:</strong> Entre más escenarios y más casos se prueben, se requerira más tiempo y recursos ',
                '<strong>Gestion de Datos:</strong> Generar datos realistas o incluso adquirirlos, puede representar un costo adicional ',
                '<strong>Ejecución de pruebas:</strong> Factores como la cantidad, complejidad, repeticiones, el tiempo requerido, tienen un costro intrinseco ',
                '<strong>Informes:</strong> Analizar los resultados y generar valor mediante informes va incrementando el costo de acuerdo a la complejidad necesitada ',
                '<strong>Mantenimiento:</strong> Las actualizaciones periodicas, la correción de errores y la adaptación a los cambios siempre estaran presentes ',
                '',
                '<strong>Diseño de casos y escenarios de pruebas:</strong> Son las especificaciones de las entradas y salidas esperadas, con las condiciones para su ejecución, ',
                ' - de manera que cubra la mayor cantidad de funcionalidades, caracteristicas, y casos extremos del producto/sistema ',
                '<strong>Planeación:</strong> Estos casos no solo se ejecutan, se deben realizar de manera controlada y si es posible siguiendo un plan, ',
                ' - asi registrar los resultados y monitorear la ejecución se simplifican ',
            ]),
        new Item(Keys.TESTING_ADVANCED_ISOLATION,
            [
                '<strong>Principio de Aislación:</strong> Indica que las pruebas deben ser aisladas y no depender unas de otras, evitando fallas en cascada y que el orden sea relevante ',
                '<strong>Patron de Pruebas hermetico:</strong> Cada prueba es una isla, que no afecta a las demás y de igual manera es autosuficiente ',
                '',
                '- La configuración puede ser reutilizada más no modificada, al mismo tiempo que deben poder existir escenarios individuales ',
                '- La destrucción o desmontaje de recursos siempre debe suceder despues de cada test para no afectar a los siguientes ',
                '- Aunque el entorno sea compartido, este siempre debe ser el mismo para cada prueba y si se requieren variaciones deben estar contenidas ',
                '- Un conjunto de pruebas con problemas de Aislación, dificilmente sera automatizado, además de que genera retrasos y desperdicio de recursos ',
                '',
                '<strong>Detectar pruebas mal aisladas</strong>',
                '- La ejecución individual falla, pero en una suite o conjunto no',
                '- La prueba falla de manera aleatoria ',
                '- Es dependiente de otra prueba ó de un orden de ejecución especificos, Smell code <strong>The Leaky Cauldron</strong> ó <em>caldero chorreante</em>',
                '- La transición hacia un nuevo ambiente rompe una o varias pruebas ',
                '- No soportan ser ejecutadas en paralelo, aun si estan diseñadas para permitirlo '
            ]),
        new Item(Keys.TESTING_ADVANCED_CHARGE,
            [
                '- Hoy en dia todas las aplicaciones deben ser escalables y estables, estos requisitos no funcionales tienen un gran impacto en la usabilidad ',
                '- Asi se garantiza que el software funcione de manera fluida y eficiente, con multiples cargas de trabajo ',
                '- De esta manera la experiencia de usuario no se ve afectada de manera negativa y se evitan daños en la reputación de la marca ',
                '',
                '<strong>¿ Porque se necesitan ?</strong>',
                '- Validar el rendimiento de la aplicación, de manera que que se comporte normal con cargas normales y cargas maximas ',
                '- Identificar cuellos de botella, fugas de memoria y otros problemas durante la fase de desarrollo ',
                '- Optimizar la escalabilidad de manera que se pueda manejar el crecimiento en base a la demanda sin degradaciones importantes ',
                '- Mitigar riesgos financieros en caso de tiempos de inactividad o fallos por eventos con mucha demanda ',
                '',
                '<strong>¿ Que debe tener una herramienta y como deberia ser ?',
                '- Creación de scripts de prueba ya sean mediante codigo ó interfaz grafica, de manera que se puedan simular escenarios reales ',
                '- Recopilación de metricas, como tiempos de respuestas, tasa de errores, utilización de recursos, latencia, etc.. ',
                '- Monitoreo en tiempo real de manera que permita detectar problemas sobre la marcha ',
                '- Escalabilidad de manera que pueda soportar niveles de carga variables, desde pocos usuarios hasta cientos o miles ',
                '- Integraciones con otras herramientas, ya sea para CD/CI, monitoreo, entre otras ',
                '- Informes y analisis detallados en base a la información recolectada ',
                '- Soporte para mutiples protocolos: Http, Ftp, Udp, Sockets, eventos, etc... dando soporte a multiples tipos de aplicaciones ',
                '- Reutilización de scripts o escenarios en diferentes fases, escenarios y entornos de prueba ',
                '',
                '<strong>Criterios de selección:</strong>',
                '- Compatibilidad con el ambiente y las tecnologias en que esta construida la aplicación a probar ',
                '- Facilidad de uso ó que tengan una curva de aprendizaje pequeña ',
                '- Costos, como si se tiene una versión gratuita ó los costos de los planes son bajos ',
                '- La comunidad y el soporte son invaluables para optimizar el uso de la herramienta, en especial en casos desconocidos ',
                '',
                '<strong>Tipos de pruebas:</strong>',
                '<strong>- Prueba de carga:</strong> Evalua la capacidad para funcionar bajo las cantidades de usuarios esperada ',
                '<strong>- Prueba de estres:</strong> Miden la estabilidad de la aplicación en condiciones extremas ',
                '<strong>- Prueba de resistencia:</strong> Rendimiento de la aplicación durante periodos prolongados ',
                '<strong>- Prueba de volumen:</strong> Capacidad de la aplicacion para manejar grandes cantidades de datos ',
                '<strong>- Prueba de escalabilidad:</strong> Mide como aumenta/disminuyen los recursos de la aplicación segun la demanda ',
                '',
                '<strong>Algunas herramientas conocidas:</strong>',
                '<strong>- Jmeter:</strong> Open-source y diseñada para pruebas de carga y de resistencia, con una interfaz grafica amigable ',
                '<strong>- Gatling:</strong> Open-source con scripts <em>DSL</em> compatibles con Scala y Java, con un enfoque asincronico de alto rendimiento ',
                '<strong>- K6:</strong> Open-source sin interfaz grafica, pero con scripts simples y eficientes, especialmente en entornos de la nube ',
                '<strong>- BlazeMeter:</strong> Basado en la nube como una extensión avanzada de Jmeter para empresas, con una gran compatibilidad de protocolos e integraciones ',

            ])
    ];
