import * as Keys from '../keys';
import { Item } from "../models";

export class Content2 {

    public temas: Item[] = [
        ...TESTING,
        ...TESTING_ADVANCED,
        ...ANALISIS,
        ...METODOLOGIAS,
    ];

}

export const TESTING =
    [
        new Item(Keys.TESTING_PRINCIPLES,
            [
                '- El testing es una actividad clave del Ciclo de vida del software, este garantiza la calidad y la funcionalidad de cualquier aplicación o servicio ',
                '- International Software Testing Qualifications Board, es una entidad con el proposito de definir un esquema de certificación internacional ',
                '- Cada entidad es libre de tener sus principios y metodos para realizar pruebas, <strong>ISTQB</strong> propone 7 Principios ',
                '',
                '- Las pruebas demuestran la presencia de defectos, más no su ausencia, por ende entre más pruebas halla mejor ',
                '- Es improductivo hacer pruebas exhaustivas, ademas de que es casi imposible de hacer, excepto en productos increiblemente sencillos ',
                '- Las pruebas tempranas ayudan a encontrar defectos con prontitud, y a su vez reducir tiempo y costos ',
                '- Agrupar defectos permite que las soluciones sean más especializadas, y lograr pruebas más efectivas ',
                '- La paradoja del pesticida, si nuestro software cambia, las pruebas tambien deben hacerlo, que sigan funcionando no siempre es buena señal ',
                '- Las pruebas dependen del contexto, entre más se parezca el entorno de pruebas al entorno de producción mejor ',
                '- Que no se presenten errores no significa que no existan errores, solo que no se han dado las condiciones, para estos casos existe <strong>QA</strong>',
            ]),
        new Item(Keys.TESTING_MANIFIESTO,
            [
                '- El testing no es una fase más, siempre debe estar presente en todo el desarrollo ',
                '- Se debe dejar de pensar como se hacia de manera tradicional(cascada) y que el testing tambien puede ser agil, colaborativo y que entregue valor ',
                '- Las pruebas igual que el software pueden usar un enfoque interativo e incremental ',
                '- La calidad no depende solo de las pruebas, es un proceso constante durante todo el ciclo de vida ',
                '',
                '- Testing inicial <strong>SOBRE</strong> testing final ',
                '- Prevenir bugs <strong>SOBRE</strong> encontrar bugs ',
                '- Entender que se prueba <strong>SOBRE</strong> probar una funcionalidad ',
                '- Construir un mejor sistema <strong>SOBRE</strong> romper el sistema ',
                '- Responsabilidad del equipo <strong>SOBRE</strong> la responsabilidad del tester ',
            ]),
        new Item(Keys.TESTING_TYPES,
            [
                '<strong>Funcionales:</strong> Prueban las funcionalidades del sistema y suelen ser de caja negra, al validar el <strong>QUE</strong> más que el <strong>COMO</strong> ',
                '',
                '<strong>No Funcionales:</strong> Estas validan cosas como carga, estres, rendimiento, confiabilidad, etc... ',
                '',
                '<strong>Estructurales:</strong> Indagan la estructura interna del programa y sus relaciones, aca se pueden incluir las pruebas unitarias y de integración ',
                '- Estan son de tipo caja blanca, ya que es necesario conocer todo el sistema y como funciona para que sean bien planificadas ',
                '',
                '<strong>Regresión:</strong> Se vuelven a correr todas la pruebas despues de que se cambien componentes ó se corrigen errores ',
                '- Dependiendo de la cantidad de pruebas que hayan y de su complejidad puede ser una operación demorada, por lo que suelen estar automatizadas ',
                '',
                '<strong>Pruebas de rendimiento:</strong> Se ponen a prueba factores como velocidad, desempeño, estres, confiabilidad ante grandes cargas de trabajo',
                '',
                '<strong>Pruebas de usabilidad:</strong> Se evaluan diferentes aspectos en terminos de aprendizaje y operatividad para el usuario final '
            ]),
        new Item(Keys.TESTING_BENEFICIOS,
            [
                '- La calidad mejora al encontrar errores en etapas previas y durante el desarrollo, en vez de hacerlo en etapas finales ',
                '- Los cambios son hechos de manera más agil al inducir una mayor comunicación con todo el equipo ',
                '- Reducen el tiempo y los costos asociados a la mantenibilidad del software ',
                '- Los tests pueden tener documentación la cual no debe ser muy extensa, y tambien pueden servir como documentación ',
            ]),
        new Item(Keys.TESTING_NAMING,
            [
                '- Representa el intercambio de mensajes entre los diferentes componentes del sistema para lograr una funcionalidad ',
                '- El tiempo es importante ya que un mensaje debe terminar para que otro empieze (generalmente) ',
                '- Los objetos que interactuan puede ser simple clases, hasta modulos y sistemas completos ',
                '- El diablo esta en los detalles, saber nombrar los elementos que intervienen ayudara al analisis ',
                '',
                '<strong>Clases:</strong> Deben tener un indicador que las agrupe, como: <em>nombreClase</em><strong>Test</strong> ',
                '<strong>Metodos:</strong> Hay varias convenciones, pero generalmente deben incluir:  ',
                ' - nombre del metodo, estado a probar, comportamiento esperado; tambien se pueden incluir las palabras de given, when, should, test  ',
                '<strong>Variables:</strong> Deben describir el proposito de cada variable, no deben ser resumidas ni genericas, algunos ejemplos pueden ser: ',
                ' - target, expected, actual, valid, invalid, Object(Mock)',
            ]),
        new Item(Keys.TESTING_FIRST,
            [
                '<strong>Fast:</strong>            Deben ser rapidos, ya que se suelen tener cientos de pruebas y ejecutarlas conlleva tiempo y recursos ',
                '<strong>Independent:</strong>     Cada test debe ser independiente de los demás, de lo contrario habra un acoplamiento no deseado ',
                '<strong>Repeatable:</strong>      Las pruebas deben funcionar en cualquier ambiente que se ejecuten, ya sea local o en un ambiente de integración ',
                '<strong>Self-Validating:</strong> Las pruebas deben mostrar resultados concluyentes, estos no deben tener intervención humana para que sean validos ',
                '<strong>Timely:</strong>          Toda prueba debe ser oportuna y debe tener una razon de ser, si no se pueden justificar, estas habran sido una perdida de tiempo ',
            ]),
        new Item(Keys.TESTING_DATA_SUT_DOC,
            [
                '- Es un competencia basica para empezar a realizar testing, de cualquier tipo, donde se define claramente que se esta probando y que necesita',
                '',
                '<strong>System Under Test:</strong> Es aquello que se esta probando ya sea una clase, un componente, una funcionalidad, etc..',
                ' - Cada prueba deberia tener solamente un <strong>SUT</strong> y asi limitar la complejidad y el mantenimiento de cada test ',
                '',
                '<strong>Depend On Component:</strong> Es lo que necesita cada SUT para poder funcionar, y generalmente suelen tener una relación de 1-1 o 1-n',
                ' - Un <strong>DOC</strong> idealmente es pequeño y limitado, ya que se puede considerar un reflejo directo del diseño de nuestro sistema ',
                ' - Si este cuenta con un gran numero de dependencias, el sistema tambien cuenta con muchas responsabilidades y se deberia desacoplar un poco más ',
                '',
                '<strong>- Organización:</strong> Generalmente se organizan mediante una tabla que contiene el tipo de prueba, los SUTs y los DOCs ',
            ]),
        new Item(Keys.TESTING_MOCKS,
            [
                '- Son objetos que se comportan de manera igual que el elemento que copian, pero son más simples de manejar ',
                '- Tambien incluyen mecanismos para verificar los comportamientos que se estan simulando',
                '',
                '<strong>Dummy:</strong> Es un objeto con valores concretos que solo sirve para que se cumplan ciertas precondiciones, sin un comportamiendo adyacente alguno ',
                '<strong>Fake:</strong>  Son funcionales y se comportan igual que en producción, solo que de una manera más simple y limitada ',
                '<strong>Stub:</strong>  Es un objeto que ya viene con una información predefinida, en vez de información real e impredecible ',
                '<strong>Mock:</strong>  Son objetos que actuan de acuerdo a una llamada en especifico, de lo contrario no funcionaran debidamente para las pruebas ',
                '<strong>Spies:</strong> Este objeto se encarga de visualizar sin interferir todos los procesos y llamados internos, para verificar que sean los deseados ',
            ]),
        new Item(Keys.TESTING_AAA,
            [
                '<strong>Arrange:</strong> En esta parte se organiza todo lo necesario y se deben establecer las condiciones del test ',
                '<strong>Act:    </strong> Es la ejecución del fragmento a testear, invocando al metodo en cuestión ',
                '<strong>Assert: </strong> Ultimo paso de la prueba y es la comprobación de lo resultados o comportamientos esperados ',
            ]),
        new Item(Keys.TESTING_GWT,
            [
                '- Funciona de la misma manera que AAA, con algunas ventajas <strong>Given, When, Then</strong>',
                '- Puede ser usado con frameworks de BDD, es más que solo una estructura',
                '- Es obicuo por lo que más personas pueden entenderlo sin necesidad de un conocimiento completo del sistema ',
                '- Añade valor extra al negocio, al interconectar el codigo y las pruebas a un nivel mayor ',

            ]),
        new Item(Keys.TESTING_PIRAMIDE,
            [
                '     <em>Exploratorias/Humo</em>      <strong>Piramide de tests:</strong>',
                '         GUI  Tests          La mayor parte de las pruebas deberian ser unitarias',
                '       API      Tests         y la menor deberian ser de la interfaz grafica',
                '     Integration  Tests       seguidas de integracion/componentes de alto nivel',
                '   Component       Tests   ',
                ' Unit               Tests  ',
                '',
                '     <em>Exploratorias/Humo</em>      <strong>Cono de helado:</strong>',
                ' GUI                Tests    Es un anti patron de pruebas donde la mayoria de pruebas',
                '   API             Tests      son de la interfaz grafica y NO pruebas unitarias',
                '     Integration  Tests       ',
                '       Component Tests        ',
                '         Unit   Tests      ',
                '',
                '     <em>Exploratorias/Humo</em>      <strong>Tipo Cigarrillo:</strong>',
                '         GUI Tests           Poco o nada de ningun tipo de test ',
                '         API Tests            centrando el grueso en pruebas manuales ',
                ' Integration Tests            dificiles de automatizar y de mantener ',
                '   Component Tests',
                '        Unit Tests',
            ]),
        new Item(Keys.TESTING_TRIANGULO,
            [
                '         Alcance              <strong>Alcance:</strong> Requisitos ó tareas a realizar              - personas  - alcance   + tiempo ',
                '                                                                   ',
                '         Calidad              <strong>Tiempo:</strong> Planificación de la duración del proyecto    - tiempo    - alcance   + costos ',
                '                                                                      ',
                '   Costo         Tiempo       <strong>Costos:</strong> Recursos a gastar el proyecto                + alcance   + tiempo    + costos ',
            ]),
        new Item(Keys.TESTING_COBERTURA,
            [
                '- La cobertura del codigo es fundamental para garantizar un alcance optimo de las pruebas ',
                '- No hay un numero magico para todos los proyectos, cada uno tendra una cobertura ideal',
                '- El 100% de esta cobertura no es garantia de ausencia de errores, como el 50% no es garantia de la calidad de las pruebas ',
                '- Esto es importante ya que se puede usar para hacer despliegues e integración continua, y encontrar codigo muerto ',
                '- Existen varios tipos de cobertura, pero el más usado es la cobertura de las lineas de codigo ',
            ]),
        new Item(Keys.TESTING_FALSES_POSITIVES_NEGATIVES,
            [
                '- Son resultados de pruebas erroneos, por problemas comunes como ambientes inestables o poco hermeticos ',
                '- Tambien estan directamente relacionados con probar detalles directos de la implementación y no los comportamientos importantes ',
                '',
                '<strong>Falso Positivo:</strong> Ocurre cuando se detectan defectos, que no existen realmente, incurriendo en costos y trabajo extra ',
                '- Esto puede ser debido a fuentes externas de error, inestabilidad del ambiente, errores de los datos, problemas en las automatizaciones, etc.. ',
                '',
                '<strong>Falso Negativo:</strong> Ocurre cuando no se detectan errores, pero si existen realmente, incurriendo en errores silenciosos ',
                '- Suelen suceder por pruebas mal desarrolladas, más que por el propio entorno y minan la confiabilidad del producto ',
            ]),
        new Item(Keys.TESTING_QUALITY_ASSURANCE,
            [
                '- <strong>Quality Assurance</strong> Es un concepto donde todos los involucrados deben aportar, aunque haya personas especificas para verificar su cumplimiento ',
                '- Todo proyecto deberia contar con un plan de pruebas que asegure la calidad del proyecto entregado ',
                '- En etapas iniciales es importante saber que expectativas se tienen ó que requisitos se debe cumplir, asi se estructuran mejor los tests de aceptación ',
                '- La integración continua y los tests son herramientas con las que el proyecto deberia contar desde su inicio ',
                '- El encargado de estos aspectos debe ser el intermediario entre los clientes, sus espectativas y lo que ha sido elaborado ',
                '- QA no se limita a encontrar fallos, sino anticiparse a las casuisticas posibles y validar probabilidades y/o soluciones con los actores involucrados ',
                '- Tambien es el encargado de crear ambientes de prueba que sean similares al ambiente de producción ',
            ]),
        new Item(Keys.TESTING_DATA_CREATION,
            [
                '- Crear datos para los tests, es una parte importante, ya que un buen set de datos, son la base de pruebas exitosas y confiables ',
                '- Mejoran la legibilidad de los casos, al separar la creación de datos de la logica de la prueba ',
                '- Permiten la flexibilidad y la reutilización de codigo, además de mejorar la mantenibilidad de las pruebas ',
                '',
                '<strong>Patron Object Mother:</strong> Es una forma sencilla de crear datos, este implica crear un unico objeto que contenga todas, ',
                ' - las propiedades y metodos necesarios para crear los datos de prueba',
                '',
                '<strong>Patron Test Data Builder:</strong> Es una forma más organizada y flexible de crear los datos de prueba, implica crear un constructor ',
                ' - para cada objeto, y metodos personalizados para modificar sus propiedades o crear copias a su conveniencia ',
            ]),
        new Item(Keys.TESTING_FIVE_FACTORS,
            [
                '- Existen casos donde se crean pruebas solamente para cubrir casos de cobertura o porque simplemente es un actividad más que hacer ',
                '- Esto va en contra del espiritu que hizo que las pruebas nacieran en primer lugar ',
                '- Existen 5 factores por los que escribimos pruebas y generalmente las primeras 2 razones son la razones estandar para hacerlo ',
                '',
                '<strong>Verificar que el codigo funciona correctamente:</strong> Las pruebas dan confianza de que el codigo que se esta agregando/modificando ',
                ' - funciona de la forma que esperamos y logre su objetivo ',
                '',
                '<strong>Prevenir futuras regresiones:</strong> La verificación inmediata es suficiente para ajustes pequeños asi evitas regresar a versiones anteriores ',
                ' - por problemas insospechados al haber modificado codigo sin hacer las respectivas pruebas ni haber tenido en cuenta posibles efectos segundarios ',
                '',
                '<strong>Documentación:</strong> <em>Los programas deben escribirse para que los lea la gente y, sólo incidentalmente, para que los ejecuten las máquinas</em> <strong>Hal Abelson</strong> ',
                '- El codigo es comunicación y aunque ya existen muchas practicas y formas para documentar el funcionamiento del sistema ',
                '- Las pruebas tambien son codigo y pueden ser diseñadas explicitamente con ese fin, y al ser ejecutables no se vuelven obsoletas con tanta facilidad ',
                '',
                '<strong>Proporcionar orientación sobre el diseño:</strong> Escribir pruebas genera tanta experiencia como escribir el codigo que se prueba ',
                '- Diseñar una solución es un equilibrio entre lo que se planea resolver(problema) y la generalidad con lo que se hace(reutilización)',
                '- El codigo especifico es util al principio, pero puede quedar facilmente obsoleto ó es dificil de mantener ',
                '- El codigo generalizado en cambio suele agregar complejidad a cambio de ser más util para el futuro ',
                '',
                '<strong>Apoyar la refactorización:</strong> La unica constante del software es el cambio, por lo que una base de codigo que sea evolucionable debe ',
                ' - tener un conjunto de pruebas que admita la refactorización mientras estas siguen comprobando la funcionalidad del codigo base ',
            ]),
        new Item(Keys.TESTING_BUG,
            [
                '- Un error(Bug) es cualquier tipo de error falla o deficiencia que provoca que el software se desvie del comportamiento esperado ',
                '- Todo error tiene un tiempo de vida, desde su descubrimiento hasta su solución hay ciertos criterios y pasos que seguir ',
                '',
                '<strong>Encontrado:</strong> Es el estado inicial de cualquier error en el cual es documentado y presentado al equipo de desarrollo ',
                '<strong>Asignado:</strong> Se autoriza para que algun desarrollador lo revise y corrija ',
                '<strong>Abierto:</strong> Se replica el caso y se buscan soluciones, tambien se puede dar el caso de que sea rechazado o aplazado ',
                '<strong>Corregido:</strong> Se han realizado los cambios correspondientes y lo han verificado ',
                '<strong>Pruebas:</strong> Se realizan tests unitarios, de integración o cualquier otra prueba para verificar que se ha resuelto ',
                '<strong>Verificado:</strong> Si no se presenta y tampoco es posible reproducirlo ',
                '<strong>Cerrado:</strong> El error ha sido corregido y es posible desplegarlo ',
                '<strong>Reabrir:</strong> Si despues de la correción este vuelve a suceder, es necesario repetir todos los pasos anteriores ',
                '<strong>Duplicado:</strong> El mismo error puede informarse multiples veces, solo se deja el reporte más completo ',
                '<strong>Aplazado:</strong> Si el error no es critico y ya estaba planeado para realizarse en proximos despliegues ',
                '<strong>Rechazado:</strong> Si no es un defecto o no es posible reproducirlo, ya sea por compilaciónes erroneas o codiciones anomalas ',
                '<strong>Irreparable:</strong> Si la capacidad actual del equipo o los recursos a gastar resulta demasiado costoso ',
                '',
                '&brvbar;------------------------------------------ Criterios Tecnicos ------------------------------------------&brvbar;',
                '&brvbar; Gravedad &brvbar; Prioridad &brvbar;  Reproducible ? &brvbar;         Causa raiz         &brvbar;    Tipo de error    &brvbar; Frecuencia &brvbar;',
                '&brvbar;--------------------------------------------------------------------------------------------------------&brvbar;',
                '&brvbar; Critica  &brvbar; Alto      &brvbar; Siempre         &brvbar; Errores de codigo          &brvbar; Funcional           &brvbar; Siempre    &brvbar;',
                '&brvbar; Alta     &brvbar; Medio     &brvbar; Intermitente    &brvbar; Falla de diseño            &brvbar; Rendimiento         &brvbar; Frecuente  &brvbar;',
                '&brvbar; Medio    &brvbar; Bajo      &brvbar; No reproducible &brvbar; Configuración              &brvbar; Usabilidad          &brvbar; Ocasional  &brvbar;',
                '&brvbar; Bajo     &brvbar;           &brvbar; No es posible   &brvbar; Errores del usuario        &brvbar; Vulnerabilidad      &brvbar; Raro       &brvbar;',
                '&brvbar;          &brvbar;           &brvbar;                 &brvbar; Dependencias de un tercero &brvbar; Compatibilidad      &brvbar; Especifica &brvbar;',
                '&brvbar;          &brvbar;           &brvbar;                 &brvbar;                            &brvbar; Integridad de datos &brvbar;            &brvbar;',
                '&brvbar;          &brvbar;           &brvbar;                 &brvbar;                            &brvbar; Defecto de UI/UX    &brvbar;            &brvbar;'
            ]),
        new Item(Keys.TESTING_INTEGRATION,
            [
                '- Las aplicaciones cada vez son más complejas e interconectadas, la unión entre multiples aplicaciones se ha convertido indicador de exito ',
                '- Un software robusto y que satisfaga las necesidades del consumidor no es lograble sin que haya una fuerte cohesión entre las partes involucradas ',
                '- Estas pruebas son utiles ya que evaluan la forma en que interactuan y operan los multiples componentes para una tarea especifica ',
                '- Despues de que se han corregido los problemas se puede garantizar que todas las partes, individuales y generales funcionan ',
                '- Las pruebas de integración suelen ser el punto previo para realizar pruebas E2E y pruebas de sistema ',
                '',
                '- Pueden hacerse de manera incremental, de manera que se empieza desde modulos pequeños y avanzan progresivamente hasta todo el sistema ',
                '- Este enfoque <em>Bottom-Up</em> es beneficioso cuando nuevas funcionalidades a algo ya existente, garantizando que tanto lo nuevo como lo existente sigan funcionando ',
                '- Tambien esta el enfoque <em>Top-Down</em> que se hace de manera sistematica empezando con modulos superiores, descendiendo a traves de la jerarquia del sistema ',
                '',
                '- Enfoque <em>Big-Bang</em> Toda la aplicación se evalua como una sola unidad, sin diferenciar ninguna parte de manera que todo se combine ',
                '- Requiere una comunicación firme entre los equipos de desarrollo y de pruebas para identificar y resolver problemas ',
                '- Es una estrategia recomendable para sistemas de software con pocas relaciones entre componentes, en especial si no son complejas ',
                '',
                '- Las pruebas de integración suelen automatizarse debido a que son demoradas e implican multiples componentes que no siempre son faciles de coordinar ',
                '- Los pipelines de <em>CI/CD</em> estan en capacidad de ejecutar estas pruebas de manera automatica como un paso previo a cualquier despliegue ',
                '- Cuando se necesitan sistemas de terceros, se suelen usar <em>mocks</em> y <em>stubs</em> de manera que no se rompan las pruebas por cambios imprevistos ',
                '',
                '<strong>Ventajas</strong>',
                '&bull; Validar el flujo de datos entre todas las partes del sistema, sin que hayan degradaciones y se transmiten de manera eficaz ',
                '&bull; Identificación de dependencias externas como APIs o sistemas de terceros, evitando problemas de compatibilidad ',
                '&bull; Escenarios de casos criticos personalizables, de manera que sean precisos y funcionen como puntos de control ',
                '&bull; Escalabilidad de manera que se puedan soportar la carga actual y la carga a futuro ',
                '&bull; Detección temprana de inconsistencias, reduciendo riesgos antes de un despliegue '
            ]),
        new Item(Keys.TESTING_CONTRACT_TESTING,
            [
                '- Los microservicios no solo traen beneficios, tambien conllevan complejidad, en este caso la comunicación entre servicios y las pruebas de integración ',
                '- Estos se comunican con otros microservicios, generalmente mediante API Rest ó usando Eventos ',
                '- Tambien se pueden aplicar para eventos, pero estos al poder implementar herramientas como un registro de esquemas ',
                ' - ya tienen una forma de evitar problemas de compatibilidad, especialmente problemas de serialización/deserialización ',
                '',
                '- Como principio deben ser evolucionables sin romper a otros consumidores en el proceso, <strong>Consumer-Driven Contract Testing</strong> representa ',
                ' - como un consumidor(cliente) define expectativas en un contrato(pact) que luego se usan para generar pruebas contra el proveedor(API/Servicio)',
                '- El resultado de estas pruebas valida si sigue cumpliendo lo esperado ',
                '',
                '- Los servicios pueden añadir campos o cambiar su respuesta de acuerdo a las necesidades/requerimientos del negocio ',
                '- Esto puede generar errores silenciosos que no se encuentran a tiempo y las pruebas <em>E2E</em> suelen ser costosas y requieren mucha coordinación ',
                '&bull; El consumidor define un contrato que describe las peticiones y respuestas, que espera de cada endpoint proveeido ',
                '&bull; El proveedor verifica automaticamente ese contrato en su pipeline de CI/CD para asegurarse de no introducir cambios incompatibles ',
                '',
                '<strong>Principios</strong>',
                '<strong>- Contratos impulsados por el consumidor:</strong> Este es quien sabe exactamente que necesita, evitando probar aspectos irrelevantes ',
                '<strong>- Versionado y publicación de contratos:</strong> Se almacenan en un broker o en Git de manera que consumidor y productor se puedan coordinar ',
                '<strong>- Integración continua:</strong> Cada cambio del proveedor verifica todos los contratos publicados por los consumidores y falla en caso de inconsistencias ',
                '<strong>- Colaboración entre equipos:</strong> Los equipos definen sus necesidades y estas se resuelven de antemano en fase de desarrollo ',
                '',
                '<strong>Ventajas</strong>',
                '<strong>- Detección temprana:</strong> Los proveedores saben con antelación si dañaran a cualquier consumidor ',
                '<strong>- Menos dependencias:</strong> Levantar todo el entorno de microservicios y realizar pruebas E2E deja de ser un requisito ',
                '<strong>- Documentación:</strong> Los contratos actuan como una especificación viva, de que necesita cada equipo ',
                '<strong>- Despliegues sin fallos:</strong> Cada microservicio puede evolucionar sin miedo a introducir Breaking Changes o errores inadvertidos ',
                '<strong>- Relaciones entre equipos:</strong> La automatización de estas pruebas no es un sustituto de la comunicación, sino un catalizador para ser objetivos ',
            ]),
        new Item(Keys.TESTING_PROPERTY_TESTING_FUZZING_TESTING,
            [
                '- La automatización de pruebas es una forma eficiente de generar una cobertura amplia, manteniendo escenarios de calidad para las pruebas ',
                '- En lugar de escribir pruebas con escenarios dados de Input/Output se generan cientos o miles de casos que deben cumplir caracteristicas específicas ',
                '- Esto se diferencia de las pruebas unitarias comunes de que no se espera una igualdad de valores, sino un cumplimiento de los comportamientos ',
                ' - esperados, aún en casos <em>extraños</em>, <em>particulares</em> o que implican riesgos de fallos no controlados ',
                '- Para lograr miles de casos se usan funciones generadoras que mediante el azar y parámetros cuidadosamente definidos generan estos conjuntos de datos ',
                '- Los generadores deben ser eficientes a la hora de probar, cumplir las restricciones del dominio y ser deterministas, ',
                ' - algo contraintuitivo, pero muy necesario para la reproducción fiable de las pruebas ',
                '',
                '- Estas pruebas son parte del <strong>Fuzz Testing</strong> que es la búsqueda de errores mediante datos aleatorios, permutaciones y otras tecnicas ',
                '- Tambien es una forma de fuzz más estructurada, que además de encontrar errores, también ayuda a visualizar falencias en la cobertura ',
                '- Estas propiedades pueden involucrar el manejo del estado y reconocimiento de estructuras, algo bastante util para componentes de caja negra, como las API ',
                ' - sin embargo esto no es el estandar y requiere implementaciones y configuraciones adicionales ',
                '- Cuando un caso activa áreas nuevas del codigo, estos casos se guardan para generar tests de mutación y así sucesivamente hasta que ',
                ' - hayan probado cada rincón y cada comportamiento observable, muchos errores de seguridad se han encontrado de esta forma ',
                '',
                '<strong>Casos que probar</strong>',
                '- Que no se generen excepciones inesperadas o existan vulnerabilidades explotables, como Inyecciones SQL, datos nulos, errores internos (5xx) ',
                '- Que las excepciones generadas sí sean las esperadas y no otros casos de fallo, las excepciones son tan importantes como sus causas ',
                '- Modelado, especialmente util si se tiene una versión alternativa de un algoritmo o proceso que se pueda usar como equivalente para las comprobaciones ',
                '- Operaciones reversibles, si se tiene una transformación inicial y una operación que la invierte, aplicar la función al dato invertido, ',
                ' - deberia devolver el dato original, util para comprobar operaciones como la serialización/deserialización ',
                '- Las invariantes son condiciones que deben cumplirse para todas las entradas, por ejemplo filtrar elementos no debe cambiar su orden, ',
                ' - las aserciones de estos casos deben combinar que la salida sea correcta y además de que la invariante o invariantes se cumplan ',
            ])
    ];

export const ANALISIS =
    [
        new Item(Keys.ANALISIS_COMPORTAMIENTO,
            [
                '- Estos modelos se usan para describir a profundidad el comportamiento de un sistema, como si es un sistema con base en los datos o en eventos ',
                '- Estos modelos pueden usarse de manera conjunta o de manera individual, eso depende de la cantidad de detalles necesarios ',
                '',
                '<strong>Flujos de datos:</strong> Modelan el procesamiento de los datos en el sistema, no solo sirven para saber las entradas y salidad del sistema ',
                '- Son valiosos ya que ayudan a realizar el seguimiento y documentan como los datos asociados siguen un flujo a traves de los componentes del sistema ',
                '- Tambien ayudan a entablar validaciones con los usuarios, que estos validen los datos y los procesos a nivel interno ',
                '',
                '<strong>Maquinas de estado:</strong> Modelan la reacción del evento en cuanto a los estimulos externos/internos ',
                '- Estos indican los posibles estados de un sistema, y que puede suceder cuando paso un estimulo en especifico ',
                '- Se usan para sistemas en tiempo real mas que todo, ya que estos son sumamente dependientes de su ambiente ',
                '- Para sistemas grandes se recomienda usar diferentes niveles de estados de mayor a menor complejidad ',
            ]),
        new Item(Keys.ANALISIS_ANALISIS_DOMAIN,
            [
                '- Estudio de los dominios de conocimientos de las sociedades ',
                '- De esta manera el enfoque socio-cognitivo no es el unico usado para la toma de información ',
                '- Tambien se ha de tener en cuenta el contexto presente y lo que motiva sus acciones ',
                '- Esto tambien da un conocimiento más profundo del entorno, y una mayor calidad de la información recolectada ',
            ]),
        new Item(Keys.ANALISIS_DISENO,
            [
                '- Un buen analisis desemboca en un buen Diseño (generalmente) ',
                '- Esta etapa es fundamental para llegar a una solución optima que cumpla los requisitos Funcionales y NO Funcionales ',
                '- Tambien se basa en la creatividad y experiencia de los profesionales a cargo, por lo que siempre existiran diseños mejores ó peores ',
                '',
                '<strong>Entendimiento de los requisitos:</strong> Sean funcionales o NO funcionales estos deben ser claros y sin ambiguedades ',
                '<strong>Usar patrones de diseño:</strong> No reinventes la rueda, sabiendo que hay soluciones a tus mismos problemas, documentadas y confiables ',
                '<strong>Calidad:</strong> Esta debe ser un objetivo a alcanzar en tu proyecto, no una fase más ',
                '<strong>Modularidad:</strong> Al ser modular esto facilitara la reutilización y que las futuras modificaciones afectan el menos codigo posible ',
                '<strong>A la medida:</strong> El diseño puede crecer y cambiar de acuerdo a las especificaciones de cliente, no necesariamente debe nacer completo ',
                '<strong>Documentación:</strong> La documentación debe existir en cualquier proyecto, para ayudar a la compresión del sistema, sea a nivel general ó especifico ',
            ]),
        new Item(Keys.ANALISIS_MODEL_DOMAIN,
            [
                '<strong>Dominio:</strong> Es el problema que quieres resolver, reglas de negocio, procesos, subtareas, etc...',
                '- Para dominios complejos y altamente conectados, probablemente se deba dividir en subdominios acotados y claramente definidos ',
                '',
                '<strong>Modelo:</strong> Es la abstracción de la realidad, en el contexto determinado, para darle solución al problema en cuestión ',
                '- Tambien suele estar acompañado de alguna descripción o imagenes que especifiquen alguna función, estructura o comportamiento ',
                '',
                '<strong>Modelo de Dominio:</strong> Organización y estructura de todo el conocimiento acerca del problema, sus partes, actores, relaciones, alcance, etc...',
                '- Se debe colocar en el foco la logica de negocio, que sera el nucleo(core)',
                '- Es de construcción grupal y colaborativa, teniendo en cuenta partes tecnicas y expertas del negocio'
            ]),
        new Item(Keys.ANALISIS_TIME_COMPLEXITY,
            [
                '- Un algoritmo es una secuencia logica de pasos, para resolver un problema especifico ',
                '- Debido a esto, suelen haber diferentes formas de hacerlo para un mismo problema, diferiendo en la forma pero no el resultado ',
                '- El consumo de recursos y tiempo, determina la eficiencia además de las instrucciones y sentencias de control usadas ',
                '- Aca es donde se introduce la notación <strong>Big O</strong>, que funciona para realizar estimaciones segun los datos introducidos ',
                '- Esta medicion se hace en función de la complejidad en el tiempo-espacio, representandose de manera algebraica ',
                '- Al estar directamente ligada al tamaño de la entrada, se suele hablar de tiempo, y sus implicaciones en los recursos del sistema ',
                '',
                '&bull; Constante: O(1)         -> Mejor     &bull; Cuadrático: O(n^2)  -> Horrible',
                '&bull; Logarítmico: O(log n)   -> Bueno     &bull; Exponencial: O(2^n) -> Horrible',
                '&bull; Lineal: O(n)            -> Justo     &bull; Factorial: O(n!)    -> Peor    ',
                '&bull; Logarítmico: O(n log n) -> Malo                                       ',
                '',
                '<strong>Constante:  </strong> Solo se tiene una instrucción, por lo que no importa el tamaño de los datos ',
                '<strong>Lineal:     </strong> Suelen darse cuando existen ciclos, a mayor tamaño, mayor tiempo ',
                '<strong>Logarítmico:</strong> Tambien depende del tamaño de la entrada, pero en este con cada iteración el tamaño crece o decrece ',
                '<strong>Cuadratico: </strong> Un buen ejemplo son 2 ciclos anidados, donde cada ciclo se ejecutara n veces ',
                '<strong>Exponencial:</strong> Cada iteración hace crecer el conjunto de datos, como puede ser la secuencia Fibonacci recursiva ',
            ]),
        new Item(Keys.ANALISIS_MANIFEST_REACTIVE,
            [
                '- En la ultima decada, los requerimientos de las aplicaciones, cambian de manera constante y acelerada ',
                '- Los tiempos de espera son cada vez menores, las largas pausas por inactividad ya no son tolerables ',
                '- Los datos ya se miden en Peta y no en Gigas y su procesamiento no se puede detener ',
                '- Todas estas necesidades se deben satifacer, de manera que el software sea <em>Reactivo</em>',
                '- Siendo más flexible, con bajo acoplamiento, escalables y faciles de desarollar/mantener además de que sus fallos no sean catastroficos ',
                '',
                '<strong> Los sistemas Reactivos son:</strong>',
                '<strong>- Responsivos:</strong> El sistema responde en la menor cantidad de tiempo posible, y de manera consistente ',
                '<strong>- Resilientes:</strong> El sistema sigue respondiendo, aun frente a diversos fallos, ya que estos se deben manejar sin comprometer al todo ',
                '<strong>- Elasticos:  </strong> El sistema debe continuar respondiendo con diferentes niveles de carga, evitando cuellos de botella Y sabiendo como crecer ',
                '<strong>- Orientado a mensajes:</strong> Los sistemas reactivos confian en el intercambio de mensajes asyncronos, ya sea para funcionar y/o delegar fallos, ',
                ' - esta comunicación debe tener estrategias para ser No-bloqueante e implementar back-pressure para no desperdiciar recursos ',
            ]),
        new Item(Keys.ANALISIS_DECLINE_DESIGN,
            [
                '- El diseño es una actividad intrinseca para crear cualquier producto, por eso es que esta presente en todo y en todas partes ',
                '- Tambien el espacio que nos rodea, moldea nuestros habitos para consumir, nuestros paisajes urbanos, y nuestra forma de movernos ',
                '- <i>Don Norman</i> autor de <strong>The design of Everyday Things</strong> define el diseño como: ',
                '- <em>La practica que se preocupa por como funcionan las cosas, como se controlan y la naturaleza de la interacción entre las personas y la tecnologia</em>',
                '- El diseño no es exclusivo de las cosas cotidianas, existe el diseño industrial, el diseño de las interfaces de usuario (UI) o el diseño grafico ',
                '- Un mal diseño es como una <strong>"Puerta Normanda"</strong> que tiene el cartel de empujar, pero una manija que por instinto se tomara para jalarla ',
                '- Esto no es culpa del usuario, es culpa de un diseño ambiguo y poco pulido ',
                '- Este libro es una gran ayuda para trabajadores y diseñadores involucrados con la tecnologia ',
                '- El diseño se debe centrar en el ser humano y se deben tener en cuenta 5 pasos: <strong>Empatizar</strong>, <strong>Definir</strong>, <strong>Idear</strong>, <strong>Prototipos</strong>, <strong>Iterar</strong>',
                '',
                '<strong>Cuando el diseño funciona naturalmente</strong>',
                '- El senderismo es una actividad ideal para los habitantes de las ciudades, para que estos se vuelvan a conectar con la naturaleza ',
                '- Una buena ruta de senderismo se siente natural, aunque haya sido construida artificialmente, y tiene varios puntos en comun: ',
                ' - Se puede sostener por un largo periodo de tiempo, con una afectación minima al ecosistema ',
                ' - Es directa y en caso de no serlo cuenta con pocos desvios ',
                ' - Genera sensaciones de riesgo, de manera controlada ',
                '',
                '<strong>¿ Para quien se diseña ?</strong>',
                '- Las innovaciones tambien pueden traer problemas raciales, ya sea por fallas de diseño, o falta de grupos más grandes de prueba ',
                ' - Dispensadores de jabon racistas, debido a que tenian problemas al detectar la luz infrarroja reflejada, por personas con la piel oscura',
                ' - Face ID, que no era capaz de diferenciar a los usuarios chinos entre si',
                ' - Google photos, y su reconocimiento de imagenes, llego a etiquetar fotos de personas negras como primates, un nivel peor que los anteriores ',
                '- Es increible pensar que empresas tan grandes y con tantos recursos hallan cometido errores tan graves, por mas innovador que sea el producto, ',
                ' - no se deben dejar de lado los pasos 4 y 5, además de probar con muestras grandes y variadas, para compensar los posibles sesgos ',
                '- El punto ciego del diseño, siempre sera los diseñadores, ya tambien son personas, con sesgos e ideas que afectan sus decisiones ',
                '',
                '<strong>La sordida religion de arreglar el mundo</strong>',
                '- El diseño se ha convertido en algo que se puede "enseñar" y han surgido decenas de negocios alrededor de esto ',
                '- <strong>Rebbeca Ackermann</strong> Describe como democratizar el diseño pudo haber sido un error, estos nuevos innovadores y disruptores ',
                ' - a menudo no estan con contacto con la realidad, y carecen de experiencia conceptual para inspirar un cambio verdadero ',
                '',
                '<strong>Cuando el diseño falla</strong>',
                '- La arquitectura hostil, como bancos contra personas sin hogar, o la segregación de comunidades ',
                '- El diseño falla cuando los diseñadores estan cegados por sus propios prejuicios, politicas o interese corporativos ',
                '- El mundo del diseño, deberia ser mas diverso y tener en cuenta posibles efectos no intencionados e intencionados con las comunidades marginadas ',
            ]),
        new Item(Keys.ANALISIS_OPINIONATED_NO,
            [
                '- En era recientes y desde la existencia de Software como Servicio<strong>(SaaS)</strong> el desarrollo de software se enfrenta a 2 decisiones importantes ',
                ' - crear algo generico que permita al usuario decidir que utilizar y como, o desarrollar algo que guie al usuario hacia una determinada manera ',
                '- Antes de la nube las soluciones de software se negociaban y creaban como demandaba del usuario, para lo que necesitara el usuario ',
                '- Con la llegada de la nube y del SaaS posteriormente, se reflexiono si la mejor idea erar crear flujos de trabajo especializados y eficientes o ',
                ' - crear soluciones más generales y por consiguiente flexibles; en si mismo, vender servicios generios o especializados ',
                '',
                '<strong>Sin opiniones:</strong>',
                '- El usuario tiene toda la capacidad de tomar sus decisiones, proporcionando diferentes maneras de realizar una misma tarea ',
                '- Aca se decidira la mejor opción dado el problema y su contexto, por eso es importante tener una gran flexibilidad ',
                '- Un ejemplo serian las hojas de calculo, que permiten crear diversas formas de almacenar y manipular los datos, si se hace de manera correcta ',
                '',
                '<strong>Con opiniones:</strong>',
                '- Se puede apreciar como la forma correcta de realizar los procesos, por lo que el camino y sus elementos se muestran como se deben usar ',
                '- Aun asi, no solo ofrecen una unica manera, tambien existen otras formas, que por lo general suelen ser más dificiles y conllevar a problemas ',
                '- Un ejemplo seria un framework de programación, que facilita el trabajo, siempre y cuando se opere bajo sus reglas ',
            ]),
        new Item(Keys.ANALISIS_ALGORITHMS,
            [
                '- Es un conjunto de instrucciones para llevar a cabo una tarea, estas deben ser lo suficientemente claras para obtener el objetivo requerido ',
                '- Son especialmente utiles para resolver problemas e innovar en multiples ambitos, pero es necesario que sean expresados de una manera comprensible ',
                '',
                '<strong>Formas de expresión </strong>',
                '<strong>- Lenguaje natural:</strong> Puede describirse mediante cualquier lenguaje que usen las personas para comunicarse de manera cotidiana ',
                ' - Este metodo es accesible para todo el publico, pero generalmente carece de precisión y claridad para algoritmos complejos ',
                '<strong>- Pseudocodigo:</strong> Combina elementos del lenguaje natural, con una descripción de alto nivel similar o igual a las convenciones ',
                ' - del lenguaje especificado, ayudando a reducir la brechas a nivel tecnico sin perder comprensibilidad ',
                '<strong>- Diagrama de Flujo:</strong> Una forma dominante presente desde los primeros dias de la informatica, basicamente son una colección de figuras geometricas',
                ' - con significados intrinsecos previamente acordados, que contienen descripciones de los pasos del algoritmo ',
                '<strong>- Codigo fuente:</strong> El enfoque directo y practico, donde se precisa tener conocimiento del lenguaje usado y del objetivo del algoritmo ',
                '',
                '<strong>Fundamentos</strong>',
                '- Un algoritmo despues de que sea <strong>eficaz</strong>, debe ser <strong>eficiente</strong>, y si las condiciones lo permiten, tambien deberia ser <strong>simple</strong>',
                '- Tambien existe una caracteristica deseable, que es la <strong>generalidad</strong>, si el algoritmo no cumple ninguna de estas condiciones, ',
                ' - significa que debe ser <strong>corregido</strong>, hasta que se encuentre un equilibrio justo entre las caracteristicas que más se deseen ',
                '- La solución debe ser alcanzable y no se considere un problema <strong>irresoluble</strong>, como el problema del <em>Puente de Königsberg</em>',
                '',
                '<strong>Rendimiento:</strong> Se tienen en cuenta 2 metricas importantes, Tiempo de ejecución y Memoria utilizada, para eso existe la notacion <em>Big-O</em>',
                '',
                '<strong>Tecnicas de diseño</strong>',
                '<strong>- Divide y venceras:</strong> Constan de 3 pasos principales',
                ' - Dividir el problema en subproblemas, idealmente del mismo tipo y en tamaños aproximados ',
                ' - Resolución de los subproblemas, puede ser de manera recursiva',
                ' - Se combinan las soluciones de los subproblemas, para resolver el problema original',
                '',
                '<strong>- Transformar y conquistar:</strong> Funcionan en 2 etapas',
                ' - En primer lugar la transformación, se modifica la instancia del problema a otro que sea más suceptible a tener solución',
                ' - En la segunda etapa, o la conquista, se resuelve ',
                '',
                '<strong>- Programación dinamica:</strong> Tecnica de programación, generalmente usada para encontrar maximos y minimos ',
                ' - Dividir el problema en subproblemas',
                ' - Guardar los resultados y optimizar los subproblemas',
                ' - Encontrar la solución general ',
                '',
                '<strong>- Algoritmos codiciosos:</strong> Cada paso debe generar la mejor opción disponible, con la esperanza de al final se obtenga la mejor solución global ',
                '',
                '<strong>- Fuerza Bruta:</strong> Son metodos sencillos que se basan directamente en la capacidad computacional y en la prueba y error de cada posibilidad ',
                '',
                '<strong>- Programación lineal:</strong> Se basa en la matematicas para optimizar el rendimiento ó la eficiencia de un problema con multiples variables ',
                '',
                '<strong>- Branch & Bounds(Ramificación y Poda):</strong> Usado para problemas de optimización, de manera progresiva se van creando y solucionando subproblemas, ',
                ' - si las solución es optima se mantiene la rama, si no se poda, y asi se continua hasta encontrar la mejor solución ó agotar los recursos ',
                '',
                '<strong>- Backtracking:</strong> Ayudan a explorar multiples opciones hasta encontrar la mejor solución, probando diferentes caminos, si estos no funcionan ',
                ' - se devuelve hasta un punto de guardado previo e intenta otra opción, sucesivamente, hasta que se encuentre la solución ó se agoten los recursos ',
            ]),
        new Item(Keys.ANALISIS_HIGH_LEVEL_VS_LOW_LEVEL,
            [
                '- Un Diseño de Alto Nivel <strong>HLD</strong> es como la vista area de un software, donde se puede ver un bosquejo general como: ',
                ' - Componentes o modulos principales, Arquitectura de la aplicación a grandes rasgos ',
                ' - Interacciones entre los componentes',
                ' - Se puede visualizar como un plano que proviene de la fase inicial del proyecto ',
                ' - Funciones generales, sin ahondar en detalles',
                '',
                '- Un Diseño de Bajo Nivel <strong>LLD</strong> son detalles más especificos como la implementación, patrones, clases, algoritmos, etc... ',
                ' - Es la traducción de la solución, teniendo en cuenta la necesidad, los aspectos y las limitaciones tecnicas encontradas ',
                ' - Implica logica real y detalles importantes para ser usados en la implementación ',
                ' - Es la guia para seguir durante la codificación, con el objetivo de que las funcionalidades sean precisas y eficientes ',
                '',
                ' ----------------------------------------------------------------------------------------------------------------                            ',
                ' &brvbar;  <strong>Aspecto</strong>   &brvbar;  <strong>Diseño de Bajo Nivel</strong>                     &brvbar;  <strong>Diseño de Alto Nivel</strong>                               &brvbar;',
                ' ----------------------------------------------------------------------------------------------------------------                            ',
                ' &brvbar; Enfoque    &brvbar; Detalles especificos de la implementacion &brvbar; Arquitectura y Diseño general                       &brvbar;',
                ' &brvbar; Cobertura  &brvbar; Componentes / Modulos                     &brvbar; Componentes Principales                             &brvbar;',
                ' &brvbar; Artefactos &brvbar; Diagramas de clase, Esquemas de BD(ERD)   &brvbar; Diagramas de arquitectura, Diagramas de componentes &brvbar;',
                ' &brvbar;            &brvbar;  Modelos, Algoritmos                      &brvbar;  FLujo de datos, definiciones e interfaces          &brvbar;',
                ' &brvbar; Entradas   &brvbar; Diseño de Alto Nivel                      &brvbar; Requisitos, Limitaciones, Objetivos de negocio      &brvbar;',
                ' &brvbar; Salidas    &brvbar; Codigo base                               &brvbar; Plan de diseño, plan de pruebas                     &brvbar;',
                ' &brvbar; Etapas     &brvbar; Durante la codificación                   &brvbar; Al principio del ciclo de vida del software         &brvbar;',
                ' &brvbar; Ejemplos   &brvbar; Normalización de BD, Domain Driven Design &brvbar; Estilos arquitectonicos, stack de tecnologias       &brvbar;',
            ]),
        new Item(Keys.ANALISIS_TYPE_EVENTS,
            [
                '<strong>Event-Driven Architecture:</strong> Es una de las arquitecturas más comunes en microservicios debido a su flexibilidad ',
                '- Los eventos son la columna vertebral de esta arquitectura, por lo que es vital conocer sus tipos y saber modelarlos ',
                '- Cada evento suele tener una carga útil de datos (payload), la cual puede variar por múltiples razones, como propósito, frecuencia, volumen, etc ',
                '',
                '<strong>- Eventos de Notificación:</strong> Suelen denominarse eventos ligeros, con mínima información para notificar de un suceso ',
                '&#10003; Cuanto menor sea el payload, menor tiempo tomará el viaje en la red del broker ',
                '&#10003; Menos campos significan menos problemas a la hora de evolución y compatibilidad de eventos ',
                '&#10003; Fáciles de implementar y son ideales si se generan con mucha frecuencia ',
                '&#10007; Aumentan la dependencia/complejidad del lado de los consumidores, al obligarlos a conocer más contexto ',
                '&#10007; Eventos demasiado simples pueden obligar a consumir datos de más lugares, encareciendo la latencia del procesamiento ',
                '',
                '<strong>- Eventos de Transferencia de Estado:</strong> Integran el estado de la información, además de todo el contexto necesario del payload ',
                '&#10003; Los consumidores están más desacoplados y pueden actuar de forma independiente de los productores ',
                '&#10003; Refuerza la importancia de los contratos como medio de entendimiento comun ',
                '&#10003; Son utiles en casos de procesos ETL o replicación de datos entre sistemas ',
                '&#10007; En caso de una alta frecuencia de los eventos se puede generar una mayor carga en la red ',
                '&#10007; Se debe tener en cuenta la consistencia y duplicación de datos en el sistema completo  ',
                '',
                '<strong>- Eventos Delta:</strong> Capturan y propagan cambios incrementales, proporcionando información minima, lo que optimiza el uso del ancho de banda ',
                '&#10003; Se pueden usar si no se necesita un historico de los datos o existen limitaciones con el uso de la red ',
                '&#10003; Ideales para sistemas en tiempo real y con mucha frecuencia de cambio de datos, como los sensores de IoT',
                '&#10007; Requieren que los consumidores gestionen la complejidad de reconstrucción del estado y ordenación de los mensajes ',
                '',
                '<strong>- Eventos de Dominio/integración:</strong> Representan cambios o acciones significativas para un dominio especifico; son impulsados por DDD ',
                '&#10003; Funcionan como puente entre distintos dominios y/o orquestadores de flujos de trabajo dentro de las aplicaciones ',
                '&#10007; Requieren una solida gobernanza de datos y prácticas maduras de versionamiento de esquemas ',
                '',
                '<strong>&bull; Los comandos no son eventos:</strong> Es importante distinguir claramente un evento de un comando, de lo contrario se presentarán problemas como: ',
                '- Se pierde la intención de la acción, mientras que los eventos transmiten un contexto descriptivo, el comando es imperativo y concreto ',
                '- Acoplamiento estrecho, los comandos introducen acciones específicas en cada consumidor, más que los eventos que suelen ser generalistas ',
                '- Un comando etiquetado erróneamente en un flujo de eventos, contribuye a la sobrecarga de procesos y filtros que dificultan la mantenibilidad ',
                '',
                '<strong>&bull; Validación de payloads y manejo de errores:</strong> Garantizar la integridad y validez de los datos es esencial para la estabilidad del sistema ',
                '- Utilice formatos livianos y eficientes para la serialización/deserialización como JSON, Avro Schema, Protobuf para la definición de los mensajes ',
                '- Manejo de payloads malformados de manera que no degraden el sistema, yendo desde la detección y recuperación, hasta su registro para analisis ',
                '',
                '<strong>&bull; Mensajes tipo <em>"Poison Pill"</em>:</strong> Son mensajes que hacen fallar directamente a los consumidores al momento de ser consumidos ',
                '- Las <em>píldoras venenosas</em> fallan al momento de deserializarse por los consumidores y bloquean el procesamiento si no se manejan correctamente ',
                '- No solo detienen el procesamiento de mensajes; pueden provocar un ciclo infinito de error y reintentos dentro de la aplicación ',
            ]),
        new Item(Keys.ANALISIS_DOMAIN_EVENTS,
            [
                '- Que un proyecto use <strong>DDD</strong> no es sinonimo de que carezca de acoplamiento ',
                '- Los eventos son consumidos por cualquiera y no respetan los contextos para los cuales fueron creados ',
                '- Un evento de dominio es una representación de un hecho innegable que ha ocurrido en nuestro negocio ',
                '- Tambien suelen tener información basica como: ',
                ' &bull; Identificador       &bull; Fechas del suceso',
                ' &bull; ID relacionados     &bull; Carga util (payload)',
                '',
                '- El problema surge cuando el evento es consumido por cualquiera que necesite ser avisado de la acción, sin validar el contexo al que pertenece ',
                '- Cuando se expone un evento y este es consumido, se genera un contrato <strong>implicito</strong> el cual deriva en 2 posibles escenarios ',
                ' &bull; En el <em>Mejor escenario</em> se sabe quienes son los consumidores y cualquier cambio se retrasa mientras todos se adaptan ',
                ' &bull; En el <em>Peor escenario</em> hay consumidores ocultos y cualquier cambio puede desestabilizar componentes insospechados ',
                '',
                '- El mejor enfoque es crear eventos publicos y que los contratos sean <strong>explicitos</strong>, asi todo cambio debe ser avisado y acordado con anterioridad ',
                '- Es inevitable que el negocio cambie, por lo que tambien su comunicación debe hacerlo, aca entra en juego la necesidad de versionar los eventos ',
                '- Agregar nuevos atributos usualmente no genera problemas, modificar/eliminar si, se suele publicar simultaneamente ambos eventos ',
                '- Tambien se suele separar el evento en 2 partes, la información del evento(data) y la información tecnica del evento(metadata)',
            ]),
        new Item(Keys.ANALISIS_LIGHT_EVENTS_VS_RICH_EVENTS,
            [
                '- Un aspecto importante y poco valorado de las Arquitecturas Basadas en Eventos (EDA) es la cantidad de información a incluir en los eventos ',
                '',
                '<strong>Eventos Ligeros</strong>',
                '- Contiene solo información directamente relacionada con el evento, como los ID relacionados a otras entidades ',
                '- Suelen ser tan compactos que parecen una fila de una tabla relacional normalizada en 2F o 3F',
                '----------------------------------------------------------------------------------------                                                       ',
                '&brvbar;                    <strong>Pros</strong>                     &brvbar;                <strong>Contras</strong>                 &brvbar;',
                '----------------------------------------------------------------------------------------                                                       ',
                '&brvbar; Son simples y utilizan poco ancho de banda  &brvbar; Necesidad de hidratar los datos        &brvbar;                                  ',
                '&brvbar; Consumen poco almacenamiento                &brvbar; Sobrecostos en el procesamiento        &brvbar;                                  ',
                '&brvbar; Simplicidad para la generación              &brvbar; Complejidad para los suscriptores      &brvbar;                                  ',
                '&brvbar; Simplicidad para su publicación             &brvbar; Condiciones de carrera para consultas  &brvbar;                                  ',
                '',
                '',
                '<strong>Eventos Enriquecidos</strong>',
                '- Contiene toda la información necesaria para que el evento pueda ser procesado por los suscriptores sin consultas extras ',
                '- Esto suele implicar estructuras más complejas como listas y estructuras anidadas',
                '----------------------------------------------------------------------------------------                                                       ',
                '&brvbar;                    <strong>Pros</strong>                     &brvbar;                <strong>Contras</strong>                 &brvbar;',
                '----------------------------------------------------------------------------------------                                                       ',
                '&brvbar; Sin necesidad de consultas extras           &brvbar; Mayor consumo de ancho de banda        &brvbar;                                  ',
                '&brvbar; Sistemas menos acoplados entre si           &brvbar; Mayor cantidad de datos que publicar   &brvbar;                                  ',
                '&brvbar; Permiten manejar logica empresarial         &brvbar; Mayores costos de infraestructura      &brvbar;                                  ',
                '&brvbar; Simplicidad para los suscriptores           &brvbar; Complejidad para los productores       &brvbar;                                  ',
                '',
                '- En el contexto de <strong>DDD</strong> Existen diferencias entre eventos de dominio y eventos de integración ',
                '- Un Evento de Dominio son importantes dentro del dominio empresarial e impulsan logica de negocio ',
                '- Un Evento de Integración se utiliza para comunicar cambios en diferentes contextos y mantener la coherencia de los datos ',
                '- Existe una afinidad natural entre los eventos de dominio y los eventos ligeros, igual que los eventos de integración y los eventos enriquecidos',
            ]),
        new Item(Keys.ANALISIS_DELIVERY_GUARANTED,
            [
                '- En la mensajeria de eventos existen 3 actores principales <strong>Productor</strong> <-> <strong>Broker</strong> <-> <strong>Consumidor</strong> y para que todo funcione correctamente, ',
                ' - debe existir un acuerdo o protocolo sobre los mensajes, validando que fueron producidos & consumidos ',
                '',
                '<strong>Productor</strong>',
                '<strong>At most once:</strong> Los mensajes se entregan una sola vez, si hay alguna falla los mensajes se pueden perder, ya que nunca reintenta ',
                ' - de esta manera se obtiene la menor latencia posible ',
                '<strong>At least once:</strong> Los mensajes se entregan una o más veces, si hay alguna falla los mensajes no se pierden, pero con los reintentos, ',
                ' - se pueden entregar más de una vez, aca es necesario configurar o tener validaciones para garantizar la idempotencia ',
                '<strong>Exactly once:</strong> Este comportamiento garantiza que el mensaje se entrega una sola vez, incluso con fallas en el sistema ',
                ' - esto se puede lograr de diversas maneras y una de ellas es manejar cada mensaje como si fuera una transacción involucrando cada una de las partes ',
                '',
                '<strong>Consumidor</strong>',
                '<strong>At most once:</strong> Lee el conjunto de mensajes y guarda la posición, si el proceso del consumidor falla despues de guardar su posición, ',
                ' - pero antes de guardar la salida del procesamiento de los mensajes, puede llegar el caso en que haya alguna perdida de mensajes ',
                '<strong>At least once:</strong> Si el consumidor lee el conjunto de mensajes los procesa y guarda su posición, ',
                ' - en este caso si el proceso del consumidor falla despues de procesar los mensajes pero antes de guardar la posición, podria darse ',
                ' - un doble procesamiento, para garantizar la idempotencia de los mensajes se pueden usar llaves unicas y evitar duplicaciones ',
                '<strong>Exactly once:</strong> El mensaje se entrega una sola vez, para lograr esto se pueden usar transacciones pero todas las partes deben estar configuradas ',
                ' - para que la transacción se de correctamente ',
            ]),
        new Item(Keys.ANALISIS_COHESERS_DECOUPLERS,
            [
                '- Todo proyecto siempre tendra restricciones que actuan sobre el, ya sea las que intentan ',
                ' - que el codigo se mantenga unido(cohesión) mientras que otras buscan separarlo(desacoplamiento)',
                '- Estas acciones estan directamente ligadas al tamaño de nuestra aplicación, nunca sera lo mismo un scripts de 5 lineas ',
                ' - a un proyecto con más de 1000 clases, miles de metodos y cientos de funcionalidades ',
                '- Generalmente se puede partir desde un codigo sin estructura, pasando por clases, modulos, servicios, monolitos modulares hasta microservicios ',
                '- Una base pequeña se beneficia de una gran cohesión, pero en proyectos más grandes tener multiples partes desacopladas ayuda a tener claridad ',
                '',
                '<strong>Fuerzas Bidireccionales:</strong>',
                '<strong>- Velocidad de desarrollo:</strong> Un programador que conoce su codigo es altamente productivo, pero esto tiene un limite, si deseas aumentar ',
                ' - esta velocidad este se debe dividir pasando de un rendimiento individual a uno con mayor capacidad por simple fuerza bruta ',
                '<strong>- Latencia:</strong> Es baja para un sistema distribuido, pero es casi nula para un monolito siempre y cuando no presenten puntos muertos ',
                '<strong>- Rendimiento:</strong> La comunicación entre servicios siempre dependera de la red, pero tambien el hardware tiene sus limitantes fisicas ',
                '<strong>- Seguridad:</strong> Un solo sistema siempre sera más facil de proteger, sin embargo al crecer sus necesidades estas aumentan el perimetro ',
                '',
                '<strong>Fuerzas que empujan a fusionar el codigo:</strong>',
                '<strong>- Depuración:</strong> Buscar errores ó depurar un sistema distribuido es dificil, en especial si no es documentado ',
                '<strong>- Consistencia de datos:</strong> Cuando no hay concurrencia y todo ocurre de manera predecible, no existen estos problemas, o almenos se reducen: ',
                ' &bull; Condicion de carrera  &bull; Teorema CAP',
                ' &bull; Idempotencia          &bull; Perdida de paquetes ',
                '<strong>- Analisis de datos:</strong> Es dificil recopilar datos de diversas fuentes, no se pueden usar Joins y las consultas SQL se vuelven complejas ',
                ' - Este punto es dependiente del tamaño, ya que si el rendimiento es esencial existen formas de mejorarlo como la replicación y la fragmentación ',
                '<strong>- Relaciones:</strong> Componentes o partes similares se tienden a agrupar debido a que son parecidos ',
                '',
                '<strong>Fueras que Intentan mantener el codigo separado</strong>',
                '<strong>- Variabilidad:</strong> A mayor cantidad de requisitos que cumplir, una sola base de codigo unica no es apta ',
                '<strong>- Ubicación:</strong> Partes de la aplicación pueden ser limitadas geograficamente, ó usar los dispositivos de los usuarios ',
                '<strong>- Estructura organizacional:</strong> Segun la <em>Ley de Conway</em> ',
                '<strong>- Mantenimiento:</strong> Modulos, clases o metodos demasiados grandes solo dificultan los cambios ',
                '',
                '- Se podria decir que en proyectos pequeños e incipientes, la velocidad es un requisito, pero despues de que se estabilicen, empieza el crecimiento ',
                ' - se empiezan a agregar nuevas funcionalidades y las opciones de experimentar y crecen tambien ',
            ]),
        new Item(Keys.ANALISIS_BOUNDED_CONTEXT,
            [
                '- Es un elemento central de <strong>DDD</strong> que consiste en la gestión de modelos y equipos de gran tamaño, de manera que puedan ser claramente divididos ',
                '- En DDD consiste en diseñar software en base al dominio subyacente y de manera entendible mediante un <em>lenguaje obicuo</em> ',
                '- Esta es la base en que diseañadores, desarrolladores y conocedores se pueden poner de acuerdo para que no hayan contradicciones y mantener la consistencia ',
                '',
                '- A medida que el negocio crece, los dominios se vuelven más amplios, y un modelo unificado se vuelve dificil de construir ',
                '- Esta confusión se suele dar alrededor de los conceptos centrales de negocio, conviertiendose en polisemas que son ',
                ' - casos donde una misma palabra tiene multiples significados totalmente validos, de acuerdo al momento y lugar usados ',
                '- Inicialmente siempre se necesitaba un modelo unificado, pero DDD ha evolucionado para tener en cuenta que esto no es viable ni rentable para sistemas grandes ',
                '',
                '- Aca entran en acción los Bounded Context(Contextos limitados) en donde cada uno si puede tener un modelo unificado ',
                '- Esto permite separar las cosas de manera que diferentes contextos pueden tener modelos completamente distintos de conceptos comunes ',
                '- Un ejemplo perfecto de esto puede ser algo tan comun como una <em>Cuenta</em>, <em>Cliente</em>, <em>Producto</em>, <em>Ticket</em> ',
                '- Las relaciones pueden seguir existiendo, pero esto requiere de un diseño estrategico que conlleve un minimo de acoplamiento y facilite las integraciones ',
            ]),
        new Item(Keys.ANALISIS_MULTI_BOUNDED_CONTEXT,
            [
                '- <strong>DDD</strong> Existe desde 2003 y muchos de sus conceptos hoy en dia ya son conocidos, como: <em>Bounded Context, Entity, Aggregate, Value Object</em> entre otros ',
                '- Gracias a su asociación directa con el codigo han sido asimilados y aplicados con relativa facilidad, mientras que otros más abstractos no tanto ',
                '- Aunque exista un lenguaje comun, tambien esto suele tener validez limitada y que existe dentro de un contexto limitado o scope ',
                '- Cuando Se habla de un contexto limitado <em>Eric Evans</em> afirma que se debe definir el contexto en el que se aplica un modelo y la existencia de ese limite ',
                '- Tambien refuerza que la existencia de que otros problemas y conceptos por fuera de este limite, que no deben distraernos ni confundirlos con el dominio ',
                '',
                '&bull; Los Bounded Context pueden tener o no relaciones entre ellos ',
                '&bull; Los modelos pueden tener el mismo dominio pero diferentes definiciones de un Bounded Context a otro ',
                '&bull; Los modelos pueden tener nombres diferentes de un contexto delimitado a otro, pero comparten algunos o todos los rasgos comunes ',
                '&bull; Si no tienen relación alguna entre si, salvo que por casualidad tienen nombres iguales, las decisiones deben estar debidamente documentadas ',
                '',
                '<strong>Upstream/Downstream:</strong> La entidad superior obliga a la entidad inferior a adoptar el lenguaje como propio ',
                '<strong>Anti-Corruption Layer:</strong> Los dominios no se conocen entre si, adoptan conceptos locales y realiza transformaciones de acuerdo a sus necesidades ',
                '<strong>vertical Development:</strong> Un enfoque de desarrollo vertical y refactorizaciones periodicas para lograr una adecuada descomposición funcional ',
            ]),
        new Item(Keys.ANALISIS_STRATEGIC_DESIGN,
            [
                '<strong>DDD</strong> Es una forma de diseñar que ha tomado mucha fuerza en la actualidad, para su implementación se deben conocer ciertos conceptos ',
                '',
                '&bull; Identificar el <strong>Negocio</strong> <em>Domains</em> & <em>Subdomains</em>',
                '&bull; Establecer limites claros entre las diferentes partes del sistema <em>Bounded Context</em>',
                '&bull; Desarrollar un lenguaje compartido <em>Ubiquitous Language</em> dentro de los <em>Bounded Context</em> y en la organización ',
                '&bull; Mapeo de relaciones entre diferentes <em>Bounded Context</em>, <em>Equipos</em> y <em>Context Mapping</em>',
                '&bull; Alinear la arquitectura del software con la estrategia del negocio y la estructura del dominio ',
                '',
                '- El <strong>Diseño Estrategico</strong> pertenece al un dominio el cual tiene un espacio para su problema, el cual se centra en analisis de alto nivel ',
                '',
                '- El <strong>Diseño Tactico</strong> se utiliza para realizar una transición gradual hacia el espacio de la solución a traves del codigo y sus transformaciones ',
                '',
                '- El <strong>Bounded Context</strong> es el vehiculo principal entre los espacios, es un modelo que se crea como parte del espacio del problema,  ',
                ' - y se desarrolla posteriormente hasta convertirse en un sistema que se integra con el espacio de la solución ',
                '&bull; Estos limites generalmente pueden agrupar a un dominio y sus subdominios ',
                '&bull; Tambien ayudan a gestionar la complejidad de la solución, evitando que crezcan de manera indebida ',
                '',
                '- Los <strong>Subdominios</strong> Representan una area especifica de conocimiento y funcionalidad dentro del sistema general ',
                '&bull; Objetivo comercial claro, dividiendo el modelo heredado en partes logicas que tengan un objetivo bien definido ',
                '&bull; Area clara de especialización, puede indicar un equipo especifico de expertos que poseen el subdominio ',
                '&bull; Importancia estrategica, de manera que aporta valor al negocio de alguna manera ',
                '',
                '- Los <strong>Dominios</strong> Son areas con importancia estrategica y ventaja competitiva para la organización ',
                '&bull; Una empresa suele tener un dominio central donde se suele concentrar la mayor parte de recursos y esfuerzos de innovación ',
                '',
                '- El <strong>Lenguaje ubicuo</strong> que maneja la aplicación es creado por un equipo de expertos y que todas las partes entienden sin problemas ',
                '&bull; Es un desarrollo colaborativo y depende del contexto en el que se este hablando ',
                '',
                '- El <strong>Equipo</strong> son los desarrolladores y expertos en el dominio, estos pueden trabajar en varios dominios, pero solo son dueños de uno ',
                '&bull; Mantienen y crean el lenguaje ubicuo de manera que no se filtren conceptos irrelevantes para el contexto ',
                '',
                '- Los dominios y subdominios no son entes aislados, se deben comunicar, ahi entra el <strong>Context Mapping</strong> como se relacionan entre si las partes del sistema ',
                '&bull; La colaboración entre equipos es una prioridad ya que esto ayuda a alcanzar los objetivos empresariales ',
                '&bull; Aca son de gran importancia los acuerdos y el intercambio de información que se da entre los equipos, estos no deben cambiar sin previo aviso ',
                '&bull; Una de las forma principales de esta comunicación, son los <strong>Eventos de dominio</strong> los cuales informan de cualquier cambio a cualquier interesado ',
                '',
                '<strong>- Tipos de integraciones:</strong>',
                '&bull; <strong>Partnership:</strong> 2 equipos se integran estrechamente tratandolo como un solo sistema combinado debido a su confianza y superposición ',
                '&bull; <strong>Shared Kernel:</strong> Varios equipos "comparten" un subconjunto del modelo de dominio el cual usan en sus respectivos contextos y dominios ',
                '&bull; <strong>Customer-Supplier:</strong> Un equipo desarrolla un sistema que es consumido por otro equipo ',
                '&bull; <strong>Conformist:</strong> Se adhiere a un modelo definido por otro equipo integrandolo como un modelo propio canonicamente ',
                '&bull; <strong>Anticorruption Layer:</strong> Es una capa intermedia que funciona como traducción en la comunicación, evitando un acomplamiento estrecho entre los modelos ',
                '&bull; <strong>Open Host Service:</strong> Un equipo proporciona un servicio que puede ser ampliado por otros equipos, mediante complementos o adaptadores ',
                '&bull; <strong>Published Language:</strong> Se define y publica un lenguaje o protocolo que otros equipos utilizan para integrarse, sin necesidad de conocer el modelo interno ',
                '&bull; <strong>Separate Ways:</strong> Los equipos trabajan en sistemas completamente separados, sin integración alguna o simplemente ignorando la existencia de otros equipos ',
            ]),
        new Item(Keys.ANALISIS_TACTIC_DESIGN,
            [
                '- En el ambito del desarrollo de software comprender y modelar dominios empresariales siempre sera un desafio, que solo aumenta en función de la complejidad ',
                '- Al usar <strong>DDD</strong> suele enfocarse en la estructura rigida del codigo, objetos de dominio, estructuras y acciones sin contexto, ',
                ' - lo que puede llevar a decisiones prematuras antes de comprender plenamente la esencia de los procesos del negocio ',
                '',
                '<strong>EventStorming</strong> es una tecnica de modelado desarrollada por <em>Alberto Brandolini</em> que traslada el enfoque de las estructuras estaticas en procesos dinamicos ',
                '- De esta manera se da un enfoque en los verbos alineado con <strong>DDD</strong>, este enfoque ofrece varias ventajas ',
                '&bull; <strong>Centrarse en los resultados:</strong> Enfatiza lo que sucede en lugar de lo que existe, esto de manera natural enmarca los procesos comerciales y las HUs ',
                '&bull; <strong>Modelo colaborativo:</strong> Prescribe talleres con diversas partes interesadas fomentando una compresión compartida del dominio ',
                '&bull; <strong>Flujo narrativo:</strong> Crea un enfoque narrativo para el modelado del dominio, haciendolo accesible para todas las partes interesadas ',
                '',
                '',
                '&brvbar; EventStorming &brvbar;     Domain Driven Design    &brvbar; Correlacion &brvbar;                                       Profundización                                         &brvbar;',
                '&brvbar; ------------- &brvbar; --------------------------- &brvbar; ----------- &brvbar; -------------------------------------------------------------------------------------------- &brvbar;',
                '&brvbar;     Actor     &brvbar;                             &brvbar; Ninguna     &brvbar; Encargado de interactuar con el sistema, o de empezar acciones y/o procesos                  &brvbar;',
                '&brvbar; ------------- &brvbar; --------------------------- &brvbar; ----------- &brvbar; -------------------------------------------------------------------------------------------- &brvbar;',
                '&brvbar;               &brvbar; Entity                      &brvbar; Implicito   &brvbar; No se representan directamente, suelen estar implicitas en descripciones de eventos/comandos &brvbar;',
                '&brvbar;   Aggregate   &brvbar; Value Object                &brvbar; Implicito   &brvbar; Pueden ser parte de los detalles de un evento/comando pero no se modelan explicitamente      &brvbar;',
                '&brvbar;               &brvbar; Aggregate                   &brvbar; Directo     &brvbar; Suelen corresponder entre si, aunque con menos detalles estructurales                        &brvbar;',
                '&brvbar; ------------- &brvbar; --------------------------- &brvbar; ----------- &brvbar; -------------------------------------------------------------------------------------------- &brvbar;',
                '&brvbar;    Command    &brvbar; Action(method) of aggregate &brvbar; Parcial     &brvbar; Son acciones que puede hacer el agregado o del servicio de dominio                           &brvbar;',
                '&brvbar; ------------- &brvbar; --------------------------- &brvbar; ----------- &brvbar; -------------------------------------------------------------------------------------------- &brvbar;',
                '&brvbar;               &brvbar; Factories                   &brvbar; Ninguna     &brvbar; Implicados en la creación de comandos, entidades o agregados, sin representación directa     &brvbar;',
                '&brvbar; ------------- &brvbar; --------------------------- &brvbar; ----------- &brvbar; -------------------------------------------------------------------------------------------- &brvbar;',
                '&brvbar;     Event     &brvbar; Domain Event                &brvbar; Directo     &brvbar; Alineación directa entre ambos conceptos                                                     &brvbar;',
                '&brvbar; ------------- &brvbar; --------------------------- &brvbar; ----------- &brvbar; -------------------------------------------------------------------------------------------- &brvbar;',
                '&brvbar;  Read Model   &brvbar; Repository                  &brvbar; Parcial     &brvbar; Implicitos en el manejo de eventos y ejecución de comandos pero no modelados explicitamente  &brvbar;',
                '&brvbar; ------------- &brvbar; --------------------------- &brvbar; ----------- &brvbar; -------------------------------------------------------------------------------------------- &brvbar;',
                '&brvbar;    Policy     &brvbar; Domain Service              &brvbar; Parcial     &brvbar; Se describen junto a politicas complejas o interacciones con multiples agregados             &brvbar;',
                '&brvbar; ------------- &brvbar; --------------------------- &brvbar; ----------- &brvbar; -------------------------------------------------------------------------------------------- &brvbar;',
                '&brvbar;    System     &brvbar; External Bounded Context    &brvbar; Parcial     &brvbar; Presentan la necesidad de capas anticorrupción, mapeo entre contextos o otras integraciones  &brvbar;',
                '',
                '',
                '&brvbar;                             <strong>Fortalezas</strong>                                   &brvbar;                         <strong>Limitaciones & Mitigaciones</strong>                         &brvbar;',
                '&brvbar; &bull; Exploración del dominio, descubriendo aspectos dinamicos de un dominio &brvbar; &bull; Falta de detalle estructurales de las estructuras internas del codigo     &brvbar; ',
                '&brvbar;  complementando el enfoque de DDD en el analisis del conocimiento        &brvbar; - Mediante diagramas UML o notas cuando sean necesarias                     &brvbar;',
                '&brvbar; &bull; Lenguaje Ubicuo construido por todas la partes interesadas de manera   &brvbar; &bull; Representación implicita de algunos conceptos de <em>DDD</em> como las <em>fabricas</em>    &brvbar;',
                '&brvbar;  colaborativa entre los conocedores de diferentes areas                  &brvbar; - Modelado complementario cuando sean cruciales para el moddelo de dominio  &brvbar;',
                '&brvbar; &bull; Identificación del <em>Bounded Context</em> por el flujo de eventos             &brvbar; &bull; Alto Nivel de abstracción, beneficia la comunicación pero no los detalles &brvbar;',
                '&brvbar;  esto revela de forma natural los limites de cada dominio                &brvbar; - Prepararse para profundizar areas especificas utilizando otras tecnicas   &brvbar;',
                '&brvbar; &bull; Alineación con arquitecturas basadas en eventos como <em>CQRS</em> y            &brvbar;                                                                             &brvbar;',
                '&brvbar;  <em>Event Sourcing</em> que son algunos de los estilos de <em>DDD</em>                    &brvbar;                                                                             &brvbar;',
                '',
                '',
                '<strong>Integración entre EventStorming y DDD',
                '&bull; Comience con la exploración inicial inicial del dominio y la identificación de <em>Bounded Context</em>',
                '&bull; Profundice en procesos especificos dentro de contextos ya delimitados ',
                '&bull; Transición al nivel de diseño identificando agregados y eventos de dominio clave ',
                '&bull; Complemente o modele las adiciones mediante UML o notación personalizada para capturar detalles importantes ',
                '&bull; Iterar y perfeccionar el modelo ya sea con EventStorming o otras tecnicas de acuerdo a las necesidades ',
                '&bull; Alinear que la implementación esta de acuerdo con la arquitectura y los patrones de implementación elegidos ',
            ])
    ];

export const SYSTEM_DESIGN =
    [
        new Item(Keys.SYSTEM_DESIGN_QUEUES,
            [
                '<strong>Arquitectura Basica</strong>',
                '- Una cola de mensajes es un componente duradero y que soporta una comunicación asincrona ',
                '- El funcionamiento basico es simple, un servicio de entrada(productor ó publicador) generan mensajes en la cola(broker)',
                ' - y un servicio de salida(consumidor ó suscriptor) se conecta, procesa y borra los mensajes de manera pertinente ',
                '- En un diseño más real, suelen haber <strong>n-m</strong> productores y consumidores conectados a una o varias colas ',
                '- Cada broker suele tener una filosofia diferente, por lo que hay acciones como el enrutamiento de mensajes, garantias de entrega, idempotencia ',
                ' - pueden ubicarse a nivel de responsabilidades de manera diferente entre el publicador, broker y consumidor ',
                '',
                '<strong>Beneficios</strong>',
                '- Los eventos ó mensajes recibidos, pueden ser procesados de manera asincrona ',
                '- El productor o el consumidor pueden fallar temporalmente, sin generar errores importantes en el procesamiento de los mensajes ',
                '- La escalabilidad es relativamente facil, basta con agregar/reducir publicadores ó suscriptores de acuerdo a la oferta y la demanda ',
                '- El procesamiento suele ser de tipo <strong>FIFO(First In, First Out):</strong> ',
                '',
                '<strong>Tipos de consumo</strong>',
                '&bull; <strong>Push:</strong> La cola envian los mensajes directamente a los consumidores ',
                '&bull; <strong>Pull:</strong> La cola espera a que los mensajes sean consumidos ',
                '',
                '<strong>Tipos de colas</strong>',
                '<strong>- Con Prioridad:</strong> Los mensajes pueden contener prioridades, para ser procesados antes que otros ',
                '<strong>- Con persistencia:</strong> No solo evitan la perdida de mensajes, en caso de fallos, si no que permiten guardar un <em>historico</em> de datos ',
                '<strong>- Efimeras:</strong> Son dinamicas y solo existen mientras dure la conexión del cliente ',
                '<strong>- Exclusivas:</strong> Solo un consumidor se puede conectar a la cola, evitando duplicaciones y respetando el orden de los mensajes ',
                '<strong>- Consumidores en competencia:</strong> Permiten que multiples consumidores procesen mensajes de una misma cola ',
                '<strong>- Particionadas:</strong> Permiten dividir la cola de acuerdo a una llave (key), de manera que los mensajes fluyan a un productor -> consumidor especificos ',
                '',
                '<strong>Algunos Brokers</strong>',
                '&bull; <strong>RabbitMQ:</strong> Una cola versatil para muchos casos de uso general ',
                '- Consumidores estupidos (ACK gestionado por el broker), cola inteligente (enrutamiento, binding, reintentos)',
                '&bull; <strong>Kafka:</strong> Diseñado para un alto rendimiento y transmisión de datos en tiempo real ',
                '- Consumidores inteligentes (offsets, reintentos y particiones), cola estupida (gestión de topics y particiones)',
                '&bull; <strong>Amazon SQS:</strong> Servicio administrado y ofrecido por AWS, confiable y con diversos tipos de colas',
                '- Al ser un servicio autoadministrado muchas responsabilidades suelen ser compartida entre todas las partes ',
                '',
                '<strong>Casos reales</strong>',
                '&bull; Para distribución de datos en tiempo real se puede usar un patron publicador/suscriptor con una cola duradera ',
                '&bull; Para el procesamiento de pedidos o operaciones transaccionales utilizar el patron punto a punto con una cola exclusiva ',
                '&bull; Para escenarios solicitud/respuesta una cola efimera evitar tener que almacenar mensajes con muy poca validez en el tiempo ',
                '&bull; Para mucho trafico use colas no exclusivas y consumidores en competencia para distribuir las cargas de trabajo ',
                '&bull; Para enrutamientos especificos como notificaciones se pueden usar colas particionadas y con prioridades si se necesitan alertas '
            ]),
        new Item(Keys.SYSTEM_DESIGN_CONCEPTS_I,
            [
                '<strong>Colas de mensajes distribuidas:</strong> Habilita la comunicacion asincrona entre componentes ',
                '- Mejora la resiliencia y la escalabilidad de los sistemas ',
                '',
                '<strong>DNS y trafico en Internet:</strong> Traduce direcciones IP de manera que sean amigables para las personas',
                '- Critico para el enrutamiento y el trafico de red',
                '',
                '<strong>Load Balancer:</strong> Distribuye el trafico entrante a traves de los servidores disponibles ',
                '- Asegura una alta disponibilidad y confianza',
                '',
                '<strong>Cache:</strong> Almacena información en memoria que es accesada con mucha frecuencia ',
                '- Reduce la carga de las bases de datos y reduce los tiempos de respuesta ',
                '- Puede ser implementado de manera distribuida o de manera local',
                '- Debe contar con politicas de limpieza para determinar que elementos borrar cuando se llene ',
                '&bull; Least Recently Used - <em>LRU:</em> Elimina los elementos que no han sido usados recientemente ',
                '&bull; Most Recently Used - <em>MRU:</em> Elimina los elementos más usados recientemente ',
                '&bull; Least Frequently Used - <em>LFU:</em> Elimina los elementos que se han consultado poco ',
                '',
                '<strong>Observabilidad:</strong> Proporciona información del comportamiento y del rendimiento del sistema ',
                '- Incluye, logging, monitoreo y tracing(seguimiento)',
                '- Esencial para solución de problemas y optimización ',
                '',
                '<strong>Publish-Subscribe model:</strong> Permite una arquitectura orientada a eventos ',
                '- Desacoplamiento entre sistemas ',
                '- Facilita el flujo de datos en tiempo real ',
                '',
                '<strong>Almacenamiento de información sin estructura(BLOB):</strong> Manejo de grandes datos binarios, como imagenes, videos, archivos, backups ',
                '- Optimizada para almacenar y buscar en grandes volumenes de estos datos ',
                '',
                '<strong>Unique ID Generator:</strong> Creación de IDs globales unicos para sistemas distribuidos ',
                '- Esencial en sistemas donde la consistencia e integridad de los datos es critica ',
                '',
                '<strong>Task Scheduler:</strong> Maneja y ejecuta tareas entre multiples nodos ó sistemas distribuidos ',
                '- Asegura la confiabilidad y la escalabilidad para sistemas en segundo plano ',
                '',
                '<strong>Escalado:</strong> Tecnicas para manejar altas cargas de trabajo ',
                '- Incluye el escalado vertical(hardware) o horizontal(software) ',
                '- Esencial para mantener el rendimiento aun con altos volumenes de carga ',
                '',
                '<strong>Rate-Limiting:</strong> Controla la tasa de peticiones para resguardar los servicios ',
            ]),
        new Item(Keys.SYSTEM_DESIGN_CONCEPTS_II,
            [
                '<strong>Hashing consistente:</strong> Distribuye la carga de manera uniforme en entornos de servidores dinamicos ',
                '',
                '<strong>API Gateway:</strong> Punto de entrada centralizado para redireccionar y filtrar peticiones ',
                '',
                '<strong>Microservicios:</strong> Divide los sistemas en servicios independientes y poco acoplados ',
                '',
                '<strong>Service Discovery:</strong> Localización de servicios de manera dinamica en sistemas distribuidos ',
                '',
                '<strong>Fault Tolerance:</strong> Garantiza la disponibilidad del software durante fallos de hardware/software ',
                '',
                '<strong>Autenticación y autorización:</strong> Controla el acceso de los usuarios y verifica su identidad de forma segura ',
                '',
                '<strong>Bases de datos:</strong> El almacenamiento de grandes volumenes de datos de manera eficiente siempre sera vital ',
                '&bull; <strong>Schemas:</strong> Los datos pueden tener una estructura fija, no tener estructura o estar parcialmente estructurados ',
                '&bull; <strong>Sharding(Fragmentación):</strong> División de las BD para manejar el crecimiento a gran escala ',
                '&bull; <strong>Replicación:</strong> Copia los datos entre multiples replicas para aumentar la disponibilidad ',
                '&bull; <strong>Teoremas CAP & PACELC:</strong> Equilibrio entre consistencia, disponibilidad y tolerancia a la partición ',
                '&bull; <strong>Indexación:</strong> Acelerar la consulta mediante el uso de campos importantes ',
                '&bull; <strong>Particionamiento:</strong> Divide los datos entre nodos para mejorar la escalabilidad y el rendimiento ',
                '&bull; <strong>Eventual Consistency:</strong> Garantiza la consistencia a lo largo del tiempo en bases de datos distribuidas ',
            ]),
        new Item(Keys.SYSTEM_DESIGN_CONCEPTS_III,
            [
                '<strong>Heartbeats:</strong> Mensajes periodicos que se envian entre sistemas distribuidos para garantizar la actividad y el buen estado de los componentes ',
                '',
                '<strong>Bloom Filters:</strong> Estructura de datos probabilistica que comprueba si un elemento forma parte de un conjunto de manera rapida ',
                '- Es muy eficiente a nivel de tiempo/espacio pero puede generar falsos positivos (quizas), pero no falsos negativos (definitivamente no) ',
                '',
                '<strong>Diseño de APIs:</strong> Un API es la puerta de conexión y una de las mejores formas de generar integraciones entre multiples sistemas ',
                '&bull; <strong>API RESTful:</strong> Siguen métodos y convenciones HTTP ',
                '&bull; <strong>GraphQL:</strong> Permite a los clientes ser flexibles con las consultas amoldandolas a su conveniencia ',
                '&bull; <strong>gRPC:</strong> Garantiza un alto rendimiento en la comunicación entre servicios con base en HTTP/2 ',
                '',
                '<strong>Idempotencia:</strong> Es la garantia de que multiples operaciones identicas tengan el mismo efecto sin importar las veces que se hagan ',
                '- Esto es crucial para el procesamiento de pagos y las operaciones de tipo CRUD ',
                '',
                '<strong>Checksum:</strong> Es la suma de los valores usada para la verificación y la integridad de los datos ',
                '- Especialmente para evitar trazas o mensaje que se pudieran corromper durante su envio o almacenamiento ',
                '',
                '<strong>Bloqueo distribuido:</strong> Previenen las condiciones de carrera en sistemas distribuidos, especialmente si tienen tareas programadas ',
                '- Asi un solo sistema puede acceder a los recursos sin sufrir bloqueos o realizar la tarea en cuestión sin duplicaciones ni errores ',
                '',
                '<strong>Circuit Breaker:</strong> Previene fallos en cascada al detener solicitudes a un servicio con fallos o que se encuentre limitado ',
                '- Esto protege el sistema de fallos generales y reduce posibles tiempos de inactividad ',
                '',
            ]),
        new Item(Keys.SYSTEM_DESIGN_SINGLE_POINT_OF_FAILURE,
            [
                '- Un Punto Unico de Falla <strong>SPOF</strong> es la parte de un sistema que cuando falla, es capaz de tumbar al sistema entero ',
                '- Esto significa que el sistema entero dejara de funcionar, ya que este componente es tan critico que sin el, el sistema no es capaz de funcionar ',
                '- Para un sistema complejo es especialmente problematico ya que generan vulnerabilidades y reducen la confiabilidad y la resiliencia ',
                '- Es importante al menos identificarlos, para tener estrategias de como eliminarlos o al menos mitigarlo si lo anterior no es posible ',
                '',
                '<strong>SPOF Comunes:</strong>',
                '- Bases de Datos, en especial si solo esta en un servidor sin replicación ',
                '- Balanceadores de carga, al ser un unico punto de entrada ',
                '- Servidores de aplicaciones, y más si solo es un unico servidor ',
                '- Conexiones de red, los enlaces entre aplicaciones si no hay suficientes formas de conectarse a internet ',
                '',
                '<strong>Estrategias de eliminación:</strong>',
                '- Redundancia, se duplican componentes criticos, como bases de datos, balanceadores de carga, servicios ',
                '- Conmutación por error, si un componente critico deja de funcionar, una copia de seguridad se hace cargo de inmediato ',
                '- Balanceador de carga, puede considerarse tanto un problema como una solución, por lo que nunca deberia estar solo ',
                '- Distribución geografica, para sistemas de alcance global, se pueden ubicar y sincronizar multiples servidores ',
                '- Monitoreo y alertas, al detectar fallas de manera temprana, esto ayuda a abordar problemas antes de que generen afectaciones reales ',
            ]),
        new Item(Keys.SYSTEM_DESIGN_I,
            [
                '- Diseñar un sistema pone a prueba la capacidad de analizar problemas complejos y crear sistemas que satisfagan requisitos especificos ',
                '- Tambien deben comunicar la intención y todas las partes de pensamiento de manera eficaz ',
                '',
                '<strong>Aclarar los requisitos:</strong> Es la base sobre la cual se pueden empezar todo el analisis ',
                '- Asi se entiende por completo el problema a resolver y ayuda a evitar errores de comunicación al inicio y durante en el proceso ',
                '- No omita ningun de los 2, juntos dan la vista general de lo que se espera ',
                '<strong>Funcionales:</strong>                             <strong>No Funcionales',
                '- Caracteristicas principales            - Rendimiento & escalabilidad',
                '- Reglas de negocio                      - Latencia y tiempos de respuesta ',
                '- Procesos y operaciones existente       - Confiabilidad & disponibilidad ',
                '',
                '<strong>Estimación de capacidad:</strong> Con los requisitos claros es necesario comprender la escala en que operara el sistema ',
                '<strong>Metricas:</strong>',
                ' - Cantidad de usuarios, usuarios totales, usuarios simultaneos, usuarios activos, picos de uso, etc.. ',
                ' - Trafico, Solicitudes por segundo, cargas de trabajo, ancho de bando necesario ',
                ' - Almacenamiento, Cuantos datos se almacenaran, información producida en algun intervalo de tiempo ',
                '',
                '<strong>Diseño de alto nivel:</strong>',
                '- Componentes principales y sus tipos, como microservicios, bases de datos, aplicaciones web, balanceadores de carga, etc.. ',
                '- Cree un diagrama que una las partes y sus interacciones ',
                '- Centrarse en el flujo de datos, como viajan por el sistema, desde una acción inicial hasta su fin y viceversa ',
                '- Comienze con un diagrama simple el cual sirva como base a la que ir agregando detalles mientras se va refinando ',
                '',
                '<strong>Diseño de Base de Datos:</strong>',
                '- Es un componente principal en muchos sistemas, por lo que se debe ser consciente de que su impacto es general para la aplicación ',
                '<strong>Elija el tipo más adecuado</strong>',
                ' - SQL para datos estructurados y fuertemente relacionados, que permiten transacciones y necesitan ser consistentes ',
                ' - NoSQL para datos sin estructura y que cambian constatemente, que necesitan escalar y ser consultados eficientemente ',
                '<strong>Diseñe el esquema</strong>',
                ' - Tablas normalizadas para evitar la redundancia de datos ó desnormalizadas segun los patrones de busqueda ',
                ' - Defina indices, constraints, claves primarias, claves foraneas, etc.. ',
            ]),
        new Item(Keys.SYSTEM_DESIGN_II,
            [
                '- El diseño de un sistema tambien radica en juntar las piezas adecuadas y unirlas de la mejor forma posible ',
                '- Cosas como conceptos basicos, patrones, arquitecturas, tecnologias y si es necesario organizar el conocimiento ó profundizarlo ',
                '',
                '<strong>Diseño de interfaz:</strong>',
                '- Defina como interactuan los componentes y si lo haran a travez de APIs y sus protocolos ',
                '- Use convenciones de nombres estandar e identifique posibles apis que se deben exponer ',
                '- Con contratos claros la comunicación entre las APIs es fluida y reducen la ambiguedad a la hora de desarrollar ',
                '<strong>Protocolos</strong>',
                '  - REST: Interacciones simples y sin estado ',
                '  - GraphQL: Consultas complejas y la posibilidad de que sea el cliente quien las defina ',
                '  - gRPC: Acciones de alto rendimiento y baja latencia ',
                '- Contratos de los datos, como Json, Protobuf, Xml para las solicitudes y respuestas ',
                '',
                '<strong>Escalabilidad & Rendimiento:</strong>',
                '- Estan ligado directamente a los requisitos No funcionales y se cumplen teniendo en cuenta la infraestructura ',
                '- Escalamiento vertical agregando más recursos como Cpu, Ram, Almacenamiento a los servicios existentes ',
                '- Escalamiento horizontal se agregan más servicios para manejar el aumento de trafico ',
                '- Almacenamiento en cache para reducir los tiempo de respuesta y la carga de la base de datos ',
                '- CDN y balanceadores de carga para contenido estatico y repartir las cargas entre la infraestructura disponible ',
                '',
                '<strong>Fiabilidad & Resiliencia:</strong>',
                '- Igual de importante que garantizar el funcionamiento normal del sistema, tambien se debe manejar las fallas que se puedan presentar ',
                '- Replicación de datos en regiones diferentes y backups periodicos que garantizen la disponibilidad de los datos ',
                '- Se deben identificar los puntos unicos de falla <strong>SPOF</strong>, como bases de datos o balanceadores de carga y tener lista su redundancia ',
                '- Implemente el patron circuit breaker o mecanismos para evitar fallas en cascada ',
                '- Utilize reintentos de manera que el tiempo sea exponencial y mecanismos para que no se pierdan datos importantes como las <strong>DLQ & DLT</strong>',
                '- Si el sistema esta replicado, la coherencia entre los nodos debe estar garantizada para evitar problemas de confiabilidad ',
                '',
                '<strong>Bonus - Tipos de entrevistas:</strong>',
                '- Diseño de producto, son las más comunes en las cuales se solicita diseñar un sistema alrededor de un producto ',
                '- Diseño de infraestructura, suelen ser más tecnicas y hacen enfasis en casos especificos que demuestren un gran dominio del tema ',
                '- Diseño backend(<strong>POO</strong>), se basan en detalles de implementación con lenguajes como Java y C# y evaluan cosas como principios y patrones ',
                '- Diseño frontened, apuntan a aplicaciones que son visuales y de mucha interacción con los usuarios ',
            ]),
        new Item(Keys.SYSTEM_THINKING_I,
            [
                '- Los sistemas más complejos y resilientes son organismos vivos, trabajan de manera coordinada, dinamica y fluida ',
                '- Perciben su entorno, se adaptan al cambio y mantienen un equilibrio, con poco o ningun control centralizado ',
                '- El pensamiento sistemico nos puede ayudar a crear sistemas "<em>vivos</em>" adaptables y resilientes como en la naturaleza ',
                '- Los modelos tradicionales suelen tener un pensamiento lineal al cual responde antes los cambios y evoluciona de una manera más rigida ',
                '',
                '<strong>Principios</strong>',
                '- El desarrollo de software es un trabajo en equipo; la arquitectura, el diseño y el codigo deben comunicarse de forma clara e intuitiva ',
                '- La complejidad es el enemigo, esta debe reducirse lo más posible mediante iteraciones y mejora continua ',
                '- Escuchar a los expertos nos ayuda a crear aplicaciones que resuelven mejor las necesidades evitando cometer errores por falta de comunicación ',
                '- La arquitectura es plomeria, si el flujo de datos se detiene, el negocio tambien, los represamientos pueden llegar a ser desastrosos ',
                '- Mantener los componentes que hacen el trabajo pequeños y los conectores que los comunican claramente definidos ',
                '- Los mensajes son la carga util, transportando datos e instrucciones por lo que debe ser flexible y ser capaz de ser sincrona/asyncrona ',
                '- La organización es importante, una adecuada distribución de responsabilidades evita puntos criticos que puedan fallar ',
                '- La evolución de un sistema es inevitable, diseñar sin tener en cuenta afectara la mantenibilidad y escalabilidad del sistema ',
                '',
                '<strong>Caracteristicas</strong>',
                '- Las personas son parte fundamental ya que el comportamiento se puede ver afectado por estas y viceversa, como en la Ley de Conway',
                '- Es importante tener un entendimiento compartido, ya que generalmente no siempre hay una sola parte involucrada como en DDD',
                '- Los requisitos y la Arquitectura deben ir de la mano, sin unos requisitos bien definidos, se pueden tomar decisiones arquitectonicas erradas ',
                '- La comunicación es muy importante, entre más flexible mejor, y siempre se debe procurar mantener la Retrocompatibilidad ',
                '- La resiliencia y su capacidad para escalarse para mantener un estado interno estable, es similar a la <em>homeostasis</em> en los sistemas biologicos ',
                '- La personalización y evolución del sistema siempre requerira desarrollo y mantenimiento, factores que consumen recursos y deben ser tenidos en cuenta ',
                '',
                '&brvbar;                 <strong>Pensamiento Sistémico</strong>                &brvbar;                       <strong>Pensamiento Lineal</strong>                      &brvbar;',
                '&brvbar; Es directo y con un enfoque preciso                  &brvbar; La complejidad surge de las interacciones                     &brvbar;',
                '&brvbar; Los problemas tienen una unica causa raiz            &brvbar; Los bucles de retroalimentación moldean el comportamiento     &brvbar;',
                '&brvbar; Las soluciones se pueden implementar secuencialmente &brvbar; Los cambios se propagan por todo el sistema                   &brvbar;',
                '&brvbar; Los cambios solo afectan a los componentes locales   &brvbar; Los cambios pueden tener efectos inesperados(efecto mariposa) &brvbar;',
                '&brvbar; Optimizar las piezas mejora el conjunto              &brvbar; Optimizar el todo es más optimo que solo las partes           &brvbar;',
            ]),
        new Item(Keys.SYSTEM_THINKING_II,
            [
                '- Pensar en sistemas requiere una forma diferente de abordar los problemas, en la ingenieria de software es comun buscar soluciones fragmentadas ',
                '- Un sistema es más que codigo, o la suma de sus partes, es una ecosistema, en el cual la complejidad se va filtrando como agua en el cemento agrietado ',
                '- En un sistema bien diseñado ningun componente existe de manera aislada, los problemas pueden venir de componentes previos o posteriores, ',
                ' - y evidenciarse en un componente diferente, por eso no se deben realizar soluciones superficiales sin entender el problema de raiz ',
                '- Esto solo corrige el sintoma y no su causa, debido a que no se contempla una perspectiva más amplia, ',
                ' - pensar en un sistema es abandonar la ilusión de partes aisladas con pocos o nulos efectos colaterales ',
                '',
                '&bull; Un error -> Requiere una parche                     &bull; Dependencias desalineadas -> Cambiar la versión',
                '&bull; Problemas de rendimiento -> Buscar optimizaciones   &bull; Aumento de trafico -> Escalar ',
                '',
                '- Los sistemas tienen un comportamiento a largo plazo, los más engañoso del software es tomar datos de un instante, estos indican el <strong>Que</strong> ',
                ' - pero no <strong>Porque</strong> o <strong>Como</strong>, se vuelve necesario observar a traves del tiempo para determinar causas y consecuencias ',
                '- Si no se identifican los puntos importantes se pueden idear soluciones que solventan el problema, pero generan un cambio estructural ',
                '- El desfase temporal puede oscurecer comportamientos si no son debidamente observados, el silencio puede ser tan malo como el ruido ',
                '- Diseñar nunca se debe enfocar hacia un sistema perfecto, sino en un sistema que se adapte sin desmoronarse en el proceso ',
                '- El sistema tambien es directamente influido por los equipos que lo crean/mantienen, el comportamiento humano hace parte de la ecuación ',
                '',
                '<strong>Toma de decisiones en el contexto de una arquitectura</strong>',
                '- Pregunte cual es el problema que se esta resolviendo realmente, no solo la solución sin entender el problema de fondo ',
                '- Diseñar para el cambio, evolucionar sin algun plan solo hara que en algun momento las cosas se vuelvan rigidas ',
                '- ¿ Monolito ó Microservicios ? Las necesidades son más importantes que las tendencias, los monolitos modulares tambien son atractivos ',
                '- Las decisiones se basan en experiencias y problemas previos, por lo que un buen conjunto de datos y metricas son una excelente guia ',
                '- Separar en conceptos y capas es una forma de reducir problemas y mejorar el reparto de responsabilidades ',
                '- La documentación es la mejor forma de evitar depender de la memoria, en especial si son decisiones importantes ',
                '- Revisar decisiones pasadas y realizar retrospectivas con periodicidad puede ayudar a encontrar mejores soluciones y problemas por venir ',
                '- Las decisiones de arquitectura son mejores cuando se toman desde diferentes perspectivas, en especial si eso fomenta el debate ',
                '- Diseñar para el fracaso(errores) es tan importante como hacerlo para el flujo principal(camino feliz) ',
                '- Los sistemas deben ser mantenibles, no se gana teniendo un sistema intrincado y elegante si es dificil de evolucionar y/o mantener ',
            ]),
        new Item(Keys.SYSTEM_DESIGN_COMMON_METRICS,
            [
                '- Diseñar sistemas no solo es idear soluciones frente a determinados problemas, generar diagramas, diseñar arquitecturas, etc. ',
                '- Tu infraestructura debe estar preparada para manejar desde escenarios normales, hasta momentos de mucha carga y picos masivos ',
                '',
                '<strong>Operaciones por segundo</strong>',
                '<strong>- Requests por segundo(QPS):</strong> Son todas las solicitudes recibidas por un servidor en un segundo, como contenido estatico(imagenes) o dinamico(APIs) ',
                '<strong>- Queries por segundo(RPS):</strong> Mide la cantidad de consultas hechas a una Base de Datos en un segundo ',
                '<strong>- Transactions por segundo(TPS):</strong> Cantidad de transacciones que se pueden completar en un segundo ',
                '<strong>- Events por segundo(EPS):</strong> Cantidad de eventos que suceden en un segundo, como logs y actualizaciones de IoT',
                '',
                '<strong>Operaciones con la Red</strong>',
                '<strong>- Throughput:</strong> Cantidad de datos que viajan a traves de la red sin sufrir perdidas, en un intervalo definido ',
                '<strong>- Latency:</strong> Tiempo de respuesta para una sola operación, desde la petición hasta su respuesta ',
                '<strong>- Bandwidth:</strong> Capacidad maxima de transferencia de datos ',
                '',
                '<strong>Metricas del caché</strong>',
                '<strong>- Time To Live (TTL):</strong> Duración de los objetos en la memoria del cache y sean borrados por expiración ',
                '<strong>- Hit Rate:</strong> Porcentaje de solicitudes atendidas satisfactoriamente, entre mayor sea mejor ',
                '<strong>- Miss Rate:</strong> complementa el Hit Rate y representan las solicitudes que van directamente a la BD ',
                '<strong>- Eviction Rate:</strong> Frecuencia con que los objetos se borran del cache, una tasa alta es señal de politicas insuficientes ',
                '',
                '<strong>Uso de una BD</strong>',
                '<strong>- Conexiones activas:</strong> Un pool de conexiones demasiado alto puede resultar en una saturación y un aumento de la latencia ',
                '<strong>- Uso de CPU & Memoria:</strong> Si el uso se mantiene alto de manera constante indica una falta de optimización ',
                '<strong>- Uso de Disco:</strong> Los datos consumen espacio y este no es infinito, si se agota seria un error fatal ',
            ]),
        new Item(Keys.SYSTEM_DESIGN_SYSTEM_TYPES,
            [
                '- Identificar el tipo de sistema que se debe diseñar ayuda a estructurar mucho mejor las soluciones posibles en base a los problemas actuales ',
                '',
                '<strong>Sistemas de lectura intensiva</strong>',
                '- Las operaciones de lectura se hacen de manera masiva, y se prioriza una recuperación de datos rapida y escalable ',
                '<strong>Caracteristicas principales</strong>                                                        <strong>Prioridades del diseño</strong>',
                '&bull; Alta relación entre lectura-escritura (100:1 ó más)                              &bull; Disponibilizar datos con baja/nula latencia',
                '&bull; La obsolescencia de los datos es tolerada                                        &bull; Prevenir la sobrecarga del backend por un exceso de consultas ',
                '&bull; Mantener una latencia minima y una alta disponibilidad de los datos              &bull; Priorizar el escalado horizontal de las rutas de lectura',
                '<strong>Componentes comunes</strong>                                                                <strong>Errores comunes</strong>',
                '&bull; Caches de lectura/escritura     &bull; CDNs                                           &bull; Sobrecargar la BD por no usar cache o usarlo de manera inadecuada',
                '&bull; Replicación de la BD            &bull; Vistas materializadas                          &bull; Falta de identificación/manejo de datos muy usados(hot keys) ',
                '&bull; Fragmentación de la BD          &bull; Bloom filters                                  &bull; Errores en la consistencia o estampidas del cache',
                '',
                '',
                '<strong>Sistemas de escritura intensiva</strong>',
                '- El rendimiento en la escritura de datos es el principal cuello de botella, ya sea por grandes volumenes de eventos y/o peticiones ',
                ' - la durabilidad y la disponibilidad deben mantenerse, además de tolerar picos de trafico ',
                '<strong>Caracteristicas principales</strong>                                                        <strong>Prioridades del diseño</strong>',
                '&bull; La velocidad de escritura supera a la de lectura                                 &bull; Ingerir datos de manera constante sin demoras ni retrasar la escritura ',
                '&bull; Manejar el backpressure y la solución de conflictos son problemas importantes    &bull; Garantizar la durabilidad y la consistencia final ',
                '&bull; Los datos se agregan o procesan de manera posterior (asincronismo)               &bull; Evite el procesamiento sincrono cuando no sea necesario ',
                '<strong>Componentes comunes</strong>                                                                <strong>Errores comunes</strong>',
                '&bull; Colas de mensajes                    &bull; Almacenamiento y procesamiento de logs    &bull; Escritura directa en la BD de manera sincrona ',
                '&bull; Write Ahead Logs(WAL)                &bull; BD optimizadas para escritura             &bull; No planificar la logica de reintentos o de la idempotencia ',
                '&bull; Procesamiento por lotes & Streaming  &bull; Pipelines de compactación/agregación      &bull; No gestionar el crecimiento del almacenamiento ni de nuevas escrituras ',
                '',
                '',
                '<strong>Sistemas de mucha consistencia</strong>',
                '- La correción e integridad de los datos debe presevarse a toda costa, incluso antes fallos y alta concurrencia, especialmente ',
                ' - si se manejan transacciones, cambios de estado o operaciones financieras ',
                '<strong>Caracteristicas principales</strong>                                                        <strong>Prioridades del diseño</strong>',
                '&bull; Los estados son compartidos y se pueden mutar                                    &bull; Evitar actualizaciones erroneas o que generen conflictos ',
                '&bull; Riesgo ante condiciones de carrera o doble procesamiento                         &bull; Garantizar el cumplimiento de <strong>ACID</strong>',
                '&bull; Compensaciones entre disponibilidad y consistencia <strong>CAP</strong>                           &bull; Rutas de recuperación para fallos recurrentes ',
                '<strong>Componentes comunes</strong>                                                                <strong>Errores comunes</strong>',
                '&bull; BD relacionales que cumplan ACID    &bull; Two-phase commit or distributed locking    &bull; Omitir el control de concurrencia ',
                '&bull; Optimistic concurrency control      &bull; Transactional outbox pattern               &bull; Aplicación incorrecta de la consistencia eventual ',
                '&bull; Patron Saga  & Orquestación         &bull; Compensating transactions for rollback     &bull; Sin diseños para recuperación de fallos y reintentos ',
                '',
                '',
                '<strong>Sistemas de coordinación de tareas ó programación</strong>',
                '- Coordinan la ejecución de tareas distribuidas, ya sean en segundo plano o con retraso, de manera que sean fiables, sean idempotentes ',
                ' - y permitan su seguimiento a traves de sus estados ',
                '<strong>Caracteristicas principales</strong>                                                        <strong>Prioridades del diseño</strong>',
                '&bull; Modelo productor-consumidor                                                      &bull; Permitir la trazabilidad/seguimiento de cualquier tarea ',
                '&bull; Las tareas pueden fallar o tardar en completarse                                 &bull; Evitar duplicados o la perdida de tareas y datos ',
                '&bull; Los resultados pueden reintentarse y permiten seguimiento                        &bull; Gestión de la salud y escalamiento de los workers ',
                '<strong>Componentes comunes</strong>                                                                <strong>Errores comunes</strong>',
                '&bull; Task queues or priority queues            &bull; Programación de tareas               &bull; Suponer que las tareas siempre son exitosas y no necesitaran reintentos ',
                '&bull; Coordinacion de trabajos y bloqueos       &bull; Reintentos y manejo de las <strong>DLQ</strong>       &bull; No gestionar fallos en los trabajadores ni operaciones duplicadas ',
                '&bull; Registro de tareas y maquinas de estados  &bull; Pool de trabajadores                 &bull; No hay visibilidad del progreso o del fallo de las tareas ',
                '',
                '',
                '<strong>Sistemas basados en la proximidad/Trie</strong>',
                '- Ofrecen coincidencias parciales, busqueda de prefijos o consultas espaciales, para las cuales se usan estructuras de datos especializadas ',
                ' - para responder datos de manera eficiente de acuerdo a la ubicación del usuario ',
                '<strong>Caracteristicas principales</strong>                                                        <strong>Prioridades del diseño</strong>',
                '&bull; La entrada principal debe devolver sugerencias utiles                            &bull; Construcción de indices eficientes o mapas precalculados ',
                '&bull; Admite busquedas rapidas en conjuntos grandes de datos                           &bull; Manejar busquedas difusas y tolerancia a errores tipograficos ',
                '&bull; La proximidad espacial/semantica forman parte de la logica de clasificación      &bull; Priorizar una latencia baja sobre alta precisión en los resultados ',
                '<strong>Componentes comunes</strong>                                                                ',
                '&bull; Arboles para coincidencias por prefijos        &bull; Caches de autocompletado y clasificacion de sugerencias ',
                '&bull; Indices invertidos para busquedas tokenizadas  &bull; Filtros Bloom para espacios de busquedas limitados ',
                '&bull; GeoHash / QuadTrees para busquedas espaciales  &bull; Algoritmo del vecino más cercano ',
                '<strong>Errores comunes</strong>',
                '&bull; Usar busquedas lineales en conjuntos masivos de datos ',
                '&bull; Olvidar los limites de la memoria de las estructuras basadas en trie ',
                '&bull; Sobreindexación sin optimización para la actualización de datos '
            ]),
        new Item(Keys.SYSTEM_DESIGN_SCALING_WRITES,
            [
                '- Escalar un sistema es un problema que siempre se deber tener en cuenta a la hora de diseñarlo, este escalamiento se da en 2 frentes ',
                '- Escalar la lectura mediantes caches, replicas de datos y DNS generalmente suele ser la parte más facil ',
                '- Escalar la escritura suele ser más dificil, ya que implica cambiar la fuente de verdad, lo que puede generar conflictos y problemas de consistencia ',
                '',
                '<strong>Problemas comunes:</strong>',
                '- <strong>Limites de I/O:</strong> El disco no puede manejar lo suficientemente rapido la gran cantidad de transacciones ',
                '- <strong>Bloqueos:</strong> Varias escrituras en la misma fila o llave provocan bloqueos entre si ',
                '- <strong>Saturación de la red:</strong> Las escrituras de alta frecuencia saturan el ancho de banda ',
                '- <strong>Hot Keys:</strong> Pocos datos tienen una gran cantidad de escrituras/actualizaciones ',
                '',
                '- La escritura no es dificil, el problema surge cuando las cantidades crecen y es necesario garantizar la consistencia de toda operación ',
                '- Para estos problemas se suelen usar alguna o combinaciones de las siguientes estrategias: ',
                '',
                '<strong>Escalado vertical y Optimizaciones:</strong> Antes de crecer horizontalmente es necesario exprimir el maximo rendimiento actual ',
                '- Se empieza escalando las capacidades del hardware, buffers con mayor capacidad, discos SSD, más RAM, mejores CPU ',
                '- Optmizaciones a nivel de las BD, Bases de datos OLTP como PostgreSQL ideales para altas cargas transaccionales y que cumplen <strong>ACID</strong>',
                ' - tambien se pueden hacer cambios de diseño como reducir los indices, inserciones tipo batch, ajustes de los commits o ajustes en el WAL ',
                '- Bases de datos basadas en arboles (LSM) como Cassandra y RocksDB especialmente optimizadas para manejar grandes volumenes de escritura, ',
                ' - evitando hacer escrituras directamente en el disco, primero almacenan en memoria y despues insertan secuencialmente en el disco, ',
                ' - en lotes ordenados sin sobrecarga por operaciones de I/O aleatorias ',
                '- Sistemas estructurados de registros Kafka y ClickHouse estan optimizados para cargas de trabajo de solo escritura, ',
                ' - la escritura es secuencial y la compactación es asincrona ',
                '',
                '<strong>Sharding and Partitioning:</strong> Cuando se ha llegado a los limites de una sola maquina, es inevitable escalar horizontalmente ',
                '- Distribuir los datos por claves para que diferentes nodos gestionen subconjuntos de información, ',
                ' - gestionados mediante hash dinamicos o división dinamica de fragmentos ',
                '- Subdivisión de tablas de acuerdo a su funcionalidad, repartiendo la carga de escritura a multiples servidores y regiones, ',
                ' - su principal inconveniente es manejar la complejidad extra de la operación y el diseño de las llaves para una distribución equitativa ',
                '',
                '<strong>Arquitecturas orientada a eventos:</strong> Esto evita que ante picos de trafico este sea causa de caidas abruptas y en cambio, ',
                ' - sea absorbido adecuadamente, se pueden usar colas de eventos y brokers de mensajeria ',
                '- Esto ayuda a que las escrituras no sean operaciones directas en base de datos, sino que sean más controladas e incluso que puedan ser asincronas ',
                '- Garantizar la entrega de los mensajes y el manejo de los reintentos se convierten en nuevas preocupaciones como la perdida de datos o su duplicación ',
                '',
                '<strong>Batching and Hierarchical Aggregation:</strong> No siempre es necesario que cada escritura se guarde inmediatamente ',
                '- Guardar por lotes, hace que multiples escrituras individuales se conviertan en una sola ',
                '- Agregación jerarquica, datos agregados en multiples capas como nodos o caches externos mantienen los datos y periodicamente actualizan la BD principal ',
                '- Los datos dejan de ser fuertemente consistentes a ser eventualmente consistentes, además de las capas de cache intermedias extras que se deben considerar ',
                '',
                '&bull; No existe una solución universal, solo pautas y requerimientos que seguir, debido a eso es normal combinar estas soluciones de acuerdo a las necesidades ',
                '- Escalar verticalmente para ganar tiempo y mantener la simplicidad ',
                '- Fragmentar y particionar si el crecimiento exige distribución de datos ',
                '- Colas y broker de mensajeria si existen picos impredecibles de carga y se pueda escalar de formar organizada ',
                '- Procesamiento de lotes para operaciones predecibles y que necesites que la escritura sea eficiente '
            ]),
        new Item(Keys.SYSTEM_DESIGN_CONTENTION,
            [
                '- La contención es un desafío común en sistemas distribuidos, con recursos que son usados simultáneamente, si no se controla eficazmente ',
                ' - puede generar problemas como condiciones de carrera, inconsistencias de datos, lecturas incorrectas y degradación del rendimiento ',
                '- La contención se da cuando varias operaciones o procesos compiten por el mismo recurso (fila de DB, archivo, memoria, conexión de red) ',
                '- <strong>ACID</strong> Es la base para el exito o fracaso de una transacción, pero por sí solo no es suficiente en sistemas más elaborados ',
                '',
                '<strong>Problemas Comunes:</strong>',
                '<strong>- Condición de carrera:</strong> 2 o más procesos acceden a un recurso de manera concurrente y desincronizada ',
                '<strong>- Actualización perdida:</strong> Actualizaciones de una transacción sobreescriben los cambios de otra ',
                '<strong>- Doble reserva:</strong> Múltiples usuarios/procesos reservan el mismo elemento/recurso simultáneamente debido a falta de coordinación ',
                '<strong>- Lectura sucia:</strong> Lectura de datos sin confirmación (commit) ',
                '<strong>- Estado inconsistente:</strong> El sistema termina en un estado invalido o incorrecto que viola las reglas existentes ',
                '',
                '<strong>Soluciones comunes:</strong>',
                '<strong>- Bloqueo pesimista:</strong> Adquiere bloqueos preventivos antes de usar el recurso, excluyendo a otros y evitando conflictos ',
                '<strong>- Concurrencia optimista:</strong> Permite leer/escribir sin bloqueos, verificando conflictos solo cuando se confirma la operación ',
                '<strong>- Modificar el aislamiento:</strong> Ajustar el nivel de aislamiento SQL para equilibrar rendimiento y consistencia ',
                '<strong>- Bloqueos distribuidos:</strong> Utilizar sistemas externos para coordinar bloqueos entre nodos ',
                '<strong>- Colas:</strong> Las colas de mensajes permiten procesar mensajes de manera secuencial ',
                '<strong>- Patrón SAGA:</strong> Usado en transacciones distribuidas y microservicios que necesitan coordinación y acciones de compensación ',
                '<strong>- Rate Limit:</strong> Limitación directa de la cantidad de solicitudes a procesar ',
                '<strong>- Control de concurrencia Multiversión (MVCC):</strong> Maneja múltiples versiones de datos para lectores/escritores evitando bloqueos al leer ',
                '<strong>- Tipos de Datos Replicados sin Conflicto (CRDT):</strong> Permite sincronización eventual entre réplicas, logrando convergencia sin coordinación central ',
                '<strong>- Ejecuciones duraderas y flujos de trabajo:</strong> Usar checkpoints y estados persistentes para manejar procesos de larga duración que pueden detenerse/reanudarse '
            ]),
        new Item(Keys.SYSTEM_DESIGN_COMMON_FAILS,
            [
                '- Los sistemas de producción no fallan aleatoriamente, los incidentes en producción suelen ser problemas que pasan de forma predecible ',
                '',
                '<strong>Memory Leaks:</strong> Todo funciona bien y el monitoreo también lo está, pero con el paso del tiempo el uso de la memoria crece ',
                ' - gradualmente y sigue creciendo sin disminuir, hasta que la aplicación se queda sin memoria y entra en un ciclo de ',
                ' - bloqueos y reinicios o bloqueo -> muerte dependiendo de la automatización o nula automatización subyacente ',
                '',
                '<strong>Database connection Pool Exhaustion:</strong> Todo salió bien, las pruebas de carga no mostraron problemas, pero cuando el tráfico aumentó ',
                ' - se degradó el servicio y murió, esto es especialmente crítico cuando las conexiones concurrentes crecen ',
                '- Para evitar esto es fundamental revisar cual es la fuente del bloqueo principal, reducir esa latencia reduce el bloqueo ',
                ' - los tiempos de espera y mejora el uso de los recursos sin necesidad de incrementarlos ',
                '',
                '<strong>Cascading Timeout:</strong> El <em>Servicio A</em> necesita del <em>Servicio B</em> y este necesita del <em>Servicio C</em> ',
                '- Todo este llamado de APIs toma tiempo que inevitablemente se van acumulando y más aun si algún elemento de la cadena tardó más de lo normal, ',
                ' -  para evitar eso es importante tener timeouts mínimos de espera para evitar respuestas que probablemente sean insatisfactorias ',
                '- Tambien se puede implementar el patrón circuit breaker, de manera que se tomen alternativas o se falle de manera rápida ',
                '',
                '<strong>Thread Pool Starvation:</strong> Cuando se tienen tareas asíncronas o tareas programadas, estas deberían reservar recursos propios ',
                ' - y no usar la capacidad sobrante del sistema, cada grupo de tareas debería tener recursos asignados en función de la prioridad y el tiempo que demoran ',
                '- Un pool limitado de hilos sin separaciones se ve directamente afectado si la cola de trabajos se bloquea o estos empiezan a demorarse demasiado ',
                '- La resiliencia y la separación de recursos se puede lograr mediante el patrón Bulkhead, como si fueran los mamparos de un barco ',
                '',
                '<strong>Unhandled Backpressure:</strong> Consumir eventos, procesarlos y guardarlos puede convertirse en un cuello de botella ',
                '- Si alguna parte del proceso no puede seguir el ritmo de la publicación, el consumidor fallará sin un control adecuado del backpressure ',
                '- En este caso se suele monitorear y de ser necesario se ralentizarían las partes necesarias para evitar una degradación mayor ',
                '',
                '<strong>Clock Skew Chaos:</strong> En sistemas distribuidos la desincronización de los relojes del sistema puede causar errores en funcionalidades ',
                ' - que requieren de una sincronización precisa entre los nodos, el uso del reloj debería ser un servicio centralizado ',
                '- La sincronización de tiempos debería usar <em>NTP</em> (Network Time Protocol) o servicios especializados como AWS Time Sync Service',
                '',
                '<strong>Missing Circuit Breakers:</strong> El <em>Servicio A</em> necesita del <em>Servicio B</em> y este necesita del <em>Servicio C</em> ',
                '- Si el <em>Servicio C</em> tiene una interrupción, el <em>Servicio B</em> empezará a fallar, hasta que colapse y transmita el fallo al <em>Servicio A</em> ',
                '- Un Circuit breaker para la comunicación entre servicios permitirá que los servicios solo tengan una degradación parcial ',
                '',
                '<strong>Log Overflow:</strong> Los logs son muy útiles en producción, pero no deben vivir de manera indefinida ni tener una cantidad excesiva ',
                '- Si todo lo que pasa se registra, se corre el riesgo de agotar el almacenamiento y bloquear la aplicación ',
                '- La rotación de los logs, además de solo usar los niveles correctos para entornos productivos hace parte de las políticas para evitar el problema ',
                '',
                '<strong>Race Condition:</strong> A veces puede haber datos corruptos de manera aislada, o aparecen inconsistencias de manera aleatoria ',
                '- Si se pasa mucho tiempo buscando el problema y no se encuentra o no es reproducible, una posibilidad es una condición de carrera ',
                '- Esto se puede corregir usando bloqueo optimista (optimistic locking) si los casos tienen poca prevalencia o no son críticos ',
                '- También podría ser un bloqueo pesimista pero este suele ser más lento, debido a que solo se permite que un usuario/sistema opere, bloqueando a los demás '
            ])
    ];

export const METODOLOGIAS =
    [
        new Item(Keys.METODOLOGIAS_AGILES,
            [
                '- Las metodologias agiles buscan hacer que cualquier desarrollo sea de alta calidad, con tiempos y costos reducidos ',
                '- Estas permiten la rapida adaptación a cualquier caracteristica del proyecto',
                '- La participación de los clientes es fundamental en todo el transcurso del desarrollo',
                '- El progreso se mide de una manera más relevante y metodica generando metricas más precisas',
                '- Estas formas de trabajar no son marcos irrompibles pueden ser modificadas y combinadas de acuerdo a las necesidades ',
                '- Algunas de estas son: Extreme Programing, SCRUM, Kanban, Agile Inception, Desing Sprint',
            ]),
        new Item(Keys.METODOLOGIAS_SCRUM,
            [
                '- Se basa en entregas pequeñas e incrementales que van sumando al producto final',
                '',
                '<strong>Roles:</strong>',
                '<strong>- Product Owner:</strong> Es el encargado de defender los intereses del cliente y maximizar el valor del producto ',
                '<strong>- Scrum Master:</strong> Es el encargado de que el equipo de trabajo no tenga incovenientes atascantes, y vigilar la correcta implementacion de SCRUM',
                '<strong>- The Team:</strong> son los encargados del desarrollo directamente, debido a su conocimiento tecnico y de hacer las entregas a tiempo ',
                '',
                '<strong>Artefactos:</strong>',
                '<strong>- Product Backlog:</strong> Recoge el conjunto de tareas, requerimientos y funcionalidades del proyecto',
                '<strong>- Sprint Backlog:</strong> Definición de las tareas a realizar y del tiempo aproximado que deberian conllevar durante el sprint ',
                '<strong>- Incremento:</strong> Resultados del sprint, que fueron terminados satisfactoriamente, listos para añadir al proyecto ',
                '',
                '<strong>Eventos:</strong>',
                '<strong>- Planning Meeting:</strong> Planeación general donde el Product Owner prioriza las tareas a realizar para el sprint ',
                '<strong>- Daily Scrum:</strong> Seguimiento diario del proyecto, analizando posibles problemas, avances y que tareas se estan realizando ',
                '<strong>- Review:</strong> Se inspecciona el incremento realizado',
                '<strong>- Retrospective:</strong> Se da a conocer las dificultades del sprint y que cosas se pueden mejorar',
            ]),
        new Item(Keys.METODOLOGIAS_SCRUM_PRINCIPLES,
            [
                '- Scrum es uno de los marcos mas usados a la hora de desarrollar software, funciona como un marco para la gestion de proyectos, ',
                ' - que se enfoca en el trabajo en equipo y el progreso iterativo, dirigido hacia metas/objetivos bien definidos ',
                '- Su adopción puede ser inconveniente al principio, trayendo inconsistencias o un choque cultural en la forma de realizar los trabajos ',
                '',
                '<strong>Esencia</strong>',
                ' - Comentarios rapidos     - Innovación a una mayor tasa',
                ' - Mejora continua         - Mejor adaptación ante los cambios',
                ' - Clientes más felices    - Ritmo constante y rapido para la entrega de valor ',
                '',
                '<strong>Pilares fundamentales:</strong>',
                '<strong>- Transparencia:</strong> Mostrar los hechos tal como son, todos confian entre si, por lo que pueden decir tanto malas como buenas noticias ',
                ' - esto permite que no se oculte información relevante y todo el equipo tiene una vista clara de como va el trabajo ',
                '<strong>- Inspección:</strong> Todo integrante puede hacer una inspeccion al producto, los procesos, las practicas; en busqueda de mejoras, ',
                ' - y en caso de que se haya desviado el rumbo, se corrige o se negocia los cambios a realizar, de manera que siempre haya una conversación ',
                '<strong>- Adaptación:</strong> Un lazo inherente a la mejora continua es la capacidad de adaptarse, a nuevas circunstancias o necesidades, ',
                ' - esto se traduce en una mejora de la comercialización y de un retorno a la inversión más temprano',
                '',
                '- Scrum no solo funciona por estos valores, tambien porque se adhiere a los principios agiles subyacentes de entregar valor y escuchar al cliente ',
                '',
                '<strong>Valores</strong>',
                '<strong>- Compromiso:</strong> Todo el equipo trabaja sincronizado, como una unidad ',
                '<strong>- Coraje:</strong> Cada integrante debe poder decir Si, No, Pedir ayuda y trabajar en nuevos enfoques ',
                '<strong>- Enfocados:</strong> El enfoque siempre seran los resultados, todo lo que se empieza, se debe terminar ',
                '<strong>- Apertura:</strong> El aprendizaje continua y la mejora subyacente estan al orden del dia ',
                '<strong>- Respeto:</strong> Toda relación entre el equipo, se basan en el respeto, reconociendo debilidades y fortalezas de cada uno ',
            ]),
        new Item(Keys.METODOLOGIAS_KANBAN,
            [
                '- Nacido de metodologias usadas por Toyota donde se identificaban las necesidades de manera precisa',
                '- Esta metodologia tiene ciertos aspectos superiores que SCRUM, pero su implementación depende de las necesidades ',
                '- Se basa en una metodologia de tarjetas visuales para mostrar el completado de las tareas',
                '- Facil de usar y de asumir por parte del equipo, al ser sumamente visual',
                '',
                '<strong>Principios:</strong>',
                '<strong>- Calidad:</strong> Todo debe hacerse bien a la primera, los errores son más costosos cuando se arregla algo ',
                '<strong>- Sin desperdicio:</strong> No hacer más de lo necesario (YAGNI)',
                '<strong>- Mejora continua:</strong> Siempre hay espacio para mejorar',
                '<strong>- Flexible:</strong> Las prioridades pueden cambiar',
                '',
                '<strong>Aspectos a implementar:</strong>',
                '- Definir un flujo de trabajo accesible por todos, el tablero puede contener varios proyectos simultaneamente ',
                '- Se deben tener tantas columnas como estados hallan, y las tarjetas se iran desplazando entre estas',
                '- Visualizar las fases del desarrollo, al igual que SCRUM se basa en un desarrollo incremental',
                '- La prioridad son las actividades que se estan haciendo en vez de empezar nuevas',
                '- Las fases deben estar terminadas para poder iniciar la siguiente, además de tener un maximo de tareas',
                '- Los trabajadores nunca esta inactivos, ya que pueden solapar tareas de diferentes proyectos sin problemas',
            ]),
        new Item(Keys.METODOLOGIAS_ELEVATOR,
            [
                '- Es una sintexis sobre ti y tu proyecto en menos de lo que sube un ascensor (1-5 minutos) ',
                '- Debe ser claro, conciso y atrayente para atraer a potenciales inversores',
                '- Debes tener una preparación previa, conocer todo lo necesario y siempre ser directo',
                '- Mide los tiempos, repasa una y otra vez lo que vayas a decir, sin dejar de lado la naturalidad ',
                '- Tu presentación debe ser sorprendente, mostrar el problema y su solución innovadora',
            ]),
        new Item(Keys.METODOLOGIAS_CANVAS,
            [
                '- Sirve para crear y definir modelos de negocios, con la prioridad de crear valor para los clientes ',
                '- Debes de llenar 9 bloques que tu empresa ha de cumplir',
                '',
                '<strong>- Segmento de mercado:</strong> ¿ Quienes son tus clientes ?, ¿ Para quien creamos valor ?, Son la base de todo tu negocio',
                '<strong>- Propuesta de valor:</strong> ¿ Que problema y como ayudamos a solucionarlo ?, Tu diferencia frente a la competencia como ventaja competitiva ',
                '<strong>- Canales:</strong> ¿ Que canales usan y cuales prefieren nuestros clientes ?, Como vas a distribuir tu producto',
                '<strong>- Comunicación:</strong> ¿ Que relaciones haz creado con tus clientes, es la indicada ?, Como te comunicaras con tus clientes ',
                '<strong>- Ingresos:</strong> ¿ Porque se paga actualmente y hasta que punto estarian dispuestos ?, Como ganaras dinero y de que fuentes ',
                '<strong>- Recursos:</strong> ¿ Necesidades claves para nuestra propuesta de valor ?, Cosas como derechos de autor, personal, fondos, patentes, etc..',
                '<strong>- Actividades:</strong> ¿ Actividades claves requeridas para nuestra propuesta ? , Producción, soluciónes, plataformas, etc... para que tu modelo funcione ',
                '<strong>- Socios:</strong> ¿ Socios y Proveedores claves ?, Quienes te ayudaran a conseguir los recursos necesarios ',
                '<strong>- Costos:</strong> ¿ Principales costos de mayor a menor ?, Definiendo cuanto gastar y como gastarlo ',
            ]),
        new Item(Keys.METODOLOGIAS_MODEL_BING_BANG,
            [
                '- Es el modelo más simple, requiere de poca planificación a costa de absorber muchos recursos(tiempo, esfuerzo, personal) ',
                '- Se basa conceptualmente en la teoria del <em>Bing Bang</em>, donde el universo nacio despues un gran estallido inicial ',
                '- Asi es posible que el producto sea la mejor versión posible en base a los argumentos y necesidades iniciales',
                '- No se recomienda para proyectos grandes ni que tengan proyecciones a largo plazo ',
                '- Se puede usar en proyectos de expirementación, o donde el aprendizaje y la sabiduria es más valioso que el proyecto en si',
                '- Este modelo tambien es muy flexible ante los requerimientos, por lo que el riesgo y la incertidumbre son muy altos ',
                '- Es facil de gestionar ya que todas las etapas se hacen antes de entregar cualquier producto ',
            ]),
        new Item(Keys.METODOLOGIAS_CASCADA,
            [
                '- Es un metodo secuencial donde cada etapa se desarrolla una sola vez',
                '- Las fases del desarrollo no estan bien definidas y se pueden solapar entre si',
                '- Errores en etapas previas pueden ser fatales si no se corrigen con premura',
                '- Bastante inflexible en cuestion de cambios sin previo aviso',
                '- Los usuarios solo son consultados en etapas finales e iniciales, poca comunicación en etapas intermedias ',
            ]),
        new Item(Keys.METODOLOGIAS_ESPIRAL,
            [
                '- Es la evolución del modelo en cascada',
                '- Se basa en la repetición de las mismas tareas, haciendo controles con más periocidad ',
                '- Se reduce el riesgo del fracaso al dividir el proceso en partes más pequeñas ',
                '- Cada ciclo se planifica justo depues de terminar el objetivo del presente ',
                '- Los errores pueden evolucionar con cada ciclo, no necesarimente resolverse ',
            ]),
        new Item(Keys.METODOLOGIAS_ITERATIVO,
            [
                '- Cada entrega es un proyecto más completo',
                '- En cada oportunidad se pueden añadir nuevas funciones o actualizar las existentes ',
                '- Resiliencia frente a cambios inesperados, mayor comunicación con el cliente',
                '- Permite desconocer detalles iniciales que se iran solucionando con las iteracciones ',
                '- Es funcional desde el primer ciclo, permite mejorar las estimaciones del proyecto ',
            ]),
        new Item(Keys.METODOLOGIAS_MODEL_XP,
            [
                '- Muy utilizada en la gestión de proyectos y se enfoca en el equipo como principal factor de exito del proyecto ',
                '- Se centra en potenciar las relaciones intepersonales de los equipos como clave de exito mediante el trabajo en equipo ',
                ' - mejorando el ambiente laboral y manteniendo un aprendizaje continuo ',
                '- La retroalimentación es un aspecto fundamental para la mejora continua y es idonea para proyectos con requisitos imprecisos y cambiantes ',
                '',
                '<strong>Roles</strong>',
                '- <strong>Cliente:</strong> Responsable de definir los objetivos y conducir el proyecto ',
                '- <strong>Equipo:</strong> Estiman las acciones necesarias a realizar y ejecutan cada actividad de programación del proyecto ',
                '- <strong>Tester:</strong> Encargada de pruebas y aseguramiento de calidad QA ',
                '- <strong>Tracker:</strong> Encargado del seguimiento ',
                '- <strong>Coach:</strong> Guiar y entrenar al equipo ',
                '- <strong>Big Boss:</strong> Gestor del proyecto, encargado de llevar el proyecto a buen termino ',
                '',
                '<strong>Reglas de diseño de Beck:</strong> Fueron ideadas en conjunto con XP a finales de los 90',
                '- <strong>Pasa las pruebas:</strong> Es la regla con mayor prioridad ya que si las pruebas funcionan, significa que el software tambien funciona ',
                '- <strong>Revela la intención:</strong> El codigo debe ser <em>facil</em> de entender, debido a que el codigo es más leido que escrito ',
                '- <strong>No Duplicación:</strong> Es otra forma de expresar el principio de <strong>DRY</strong>, entre menos duplicación, mejores diseños ',
                '- <strong>Menos elementos:</strong> Todo lo que no cumpla estos 3 elementos anteriores deberia eliminarse, agregar elementos solo agrega complejidad ',
            ]),
        new Item(Keys.METODOLOGIAS_MODEL_V,
            [
                '- Desciende del modelo en cascada e igual que este consta de las siguentes fases: ',
                '- Es un modelo facil de seguir y el emparejamiento entre las etapas logra una mejor localizazion de fallos ',
                '- El producto final solo es obtenido al final de todas las fases por lo que es demorado y puede ser diferente de lo que se pidio ',
                '',
                '       <strong>Ciclo de desarrollo</strong>                               <strong>Ciclo de testing</strong>',
                ' &darr;  Definición de requerimientos          &rarr; &rarr;         Pruebas de aceptación   &uarr; ',
                ' &darr;    Diseño funcional del sistema        &rarr; &rarr;       Pruebas de sistema        &uarr; ',
                ' &darr;      Diseño tecnico del sistema        &rarr; &rarr;     Pruebas de componentes      &uarr; ',
                ' &darr;        Especificación de componentes   &rarr; &rarr;   Pruebas unitarias             &uarr; ',
                ' &darr;                                    Codificación                            &uarr;           ',
            ]),
        new Item(Keys.METODOLOGIAS_RUP,
            [
                '- Diseñado y documentado para usar UML ',
                '- Es considerado bastante pesado, pero muy versatil y adaptable ',
                '- Cada miembro del equipo puede acceder a la misma base de conocimientos, mejorando la productividad ya que todos tienen en mente la misma meta ',
                '',
                '            Requerimiento                ',
                '                  &rarr;                   ',
                '  Evaluación &uarr;        &darr; Implementación ',
                '                  &larr;                   ',
                '               Prueba                    ',
                '',
                '<strong>Roles</strong>',
                '<strong>- Analistas:</strong> Acciones que van desde la toma de requisitos, hasta la refinación ',
                '<strong>- Desarrolladores:</strong> Profesionales como arquitectos, diseñadores, Administradores de bases de datos, Integrador ',
                '<strong>- Gestores:</strong> Jefes de proyecto, Jefes de pruebas, Encargado de despliegues ',
                '<strong>- Apoyo:</strong> Documentador, Artistas graficos, Desarrollador de cursos ',
                '<strong>- Pruebas:</strong> Analista de pruebas, Diseñador de pruebas, Encargado de las pruebas ',
                '',
                '<strong>Directrices</strong>',
                '<strong>- Requisitos de gestión:</strong> Documentar las funcionalidades del sistema, sus limitaciones, requisitos del negocio, etc.. ',
                '<strong>- Arquitectura basada en componentes:</strong> Crea un sistema facilmente extensible, haciendo referencia al uso de POO a la hora programar ',
                '<strong>- Uso de elementos visuales:</strong> Es una forma de comprender mejor el sistema de manera general, normalmente mediante diagramas UML ',
                '<strong>- Comprobar la calidad:</strong> La calidad debe estar siempre presente en todas las fases del proceso ',
                '',
                '<strong>Fases</strong>',
                '<strong>- Diseño:</strong> Fase inicial de la cual se generan los elementos necesarios para fases proximas',
                '<strong>- Elaboración:</strong> Descripción del producto y de los costos/beneficios de las fases proximas ',
                '<strong>- Construcción:</strong> Desarrollo del software como tal, e incluyen las pruebas del mismo ',
                '<strong>- Transición:</strong> Se lleva a cabo el plan de despliegue y seguimiento del software ',
            ]),
        new Item(Keys.METODOLOGIAS_KAIZEN,
            [
                '- <em>Kai</em> y <em>Zen</em> Terminos japoneses que significan respectivamente acción de cambio y mejora continua ',
                '- Consiste en eliminar las ineficiencias de tu sistema productivo, todos los dias se debe mejorar algo ',
                '1 <strong>Planificar:</strong> Debes ser consciente de tu situación, analizar los problemas y definir un plan de acción con lo que quieres mejorar ',
                '2 <strong>Hacer:</strong>      Desarrollar el plan para cada uno de los aspectos que has identificado ',
                '3 <strong>Comprobar:</strong>  Debes analizar que tu plan si este dando resultados, de lo contrario deberas volver a empezar ',
                '4 <strong>Actuar:</strong>     Si has logrado cumplir los objetivos marcados, entonces es hora de estandarizar y continuar con las mejoras ',
                '',
                '<strong>La importancia de los empleados</strong>',
                '- Una gran ventaja de esta metodologia es que no siempre son necesarias cuantiosas inversiones para obtener resultados',
                '- Debido a que todos los empleados son tomados en cuenta a la hora de tomar decisiones, aportando ideas y soluciones desde diferentes niveles ',
                '- Esto tambien aumentara la productividad y su motivación, lo que a la larga se convierte en un beneficio añadido ',
            ]),
        new Item(Keys.METODOLOGIAS_SCRUMBAN,
            [
                '<strong>Combina las mejores caracteristicas de ambos permitiendo:</strong> ',
                '- Tener la naturaleza preceptiva de scrum ',
                '- El enfoque de calidad y de evitar el desperdicio de Kanban ',
                '- Migrar o mantener metodologias agiles de desarrollo ',
                '- Mejora continua de procesos ',
                '- El mantenimiento y el desarrollo van juntos, y deben ser complementarios ',
                '',
                '<strong>Tener en cuenta:</strong>',
                '- Seguir usando los tableros y labores vigentes ',
                '- No dejar de perseguir la mejora continua ',
                '- Respetar las labores y responsabilidades actuales, mientras se intentan mejorar ',
                '- Al tomar elementos de 2 metodologias diferentes, puede causar ambiguedades o confusiones en el equipo ',
                '',
                '<strong>Cuando usarlo:</strong>',
                '- Mantenimiento de proyectos dirigidos por eventos ',
                '- Gestion de proyectos problematicos ',
                '- Desarrollo de nuevos productos, posteriores al sprint ',
                '- Mejora continua de la gestión '
            ]),
        new Item(Keys.METODOLOGIAS_LEAN,
            [
                '- La idea principal es maximizar el valor de cara al cliente, y minimizar el desperdicio ',
                '- Los procesos claves deben estar enfocados hacia el aumento de valor de manera continua, mientras se optimizan el flujo ',
                ' - de los productos y servicios de manera horizontal, desde departamentos, tecnologias, y personas, hasta llegar a los clientes ',
                '',
                '<strong>Ideas base</strong>',
                '- Entregar valor, entendido desde la perspectiva del cliente ',
                '- Eliminar residuos, donde esto abarca todo aquello que no aporte al producto final ',
                '- Avanzar hacia la excelencia, mediante la mejora continua ',
                '',
                '<strong>Origen</strong>',
                '- Este proceso data desde los años 1940, derivado del sistema de producción de Toyota, y como su fabricación que se ajustaba continuamente, ',
                ' - lograron mejorar significativas en productividad, eficiencia, costos, y cantidad de ciclos ',
                '',
                '<strong>Principios</strong>',
                '<strong>- Identifique el valor:</strong> Esto radica en el problema que se esta intentado solucionar, y que el cliente no esta dispuesto a pagar ',
                ' - cualquier actividad o proceso que no aporte valor, por lo se puede remover, para enfocarse en el valor que se desea entregar ',
                '<strong>- Asignar flujos de valor:</strong> Se identifican todas las acciones y personas involucradas, en la entrega del producto final ',
                ' - asi se puede identificar que no aportan valor para el cliente, y por consiguiente puedan ser eliminadas ',
                '<strong>- Creación de flujos:</strong> Una vez idenficado lo valioso, hay que velar por el mantenimiento del flujo de trabajo de cada equipo ',
                ' - evitando cuellos de botella e interrupciones que retrasan o desvian el avance ',
                '<strong>- Sistema de trabajo:</strong> Asi se asegura un flujo de trabajo estable, donde las tareas solo se inician si existe una demanda y/o necesidad real ',
                '<strong>- Mejora continua:</strong> Habiendo cumplido los pasos anteriores, se debe vigilar que se sigan cumpliendo, y en caso de problemas ',
                ' - el sistema no podra mantenerse ni aislado ni estatico, aca es fundamental la participación de las personas para una mejora continua ',
                '',
                '- De la misma manera que otras metodologias, no hay una receta, ni una practica estandarizada, por lo que se debe tomar como una filosofia, ',
                ' - de la gestión que busca mejora los procesos y productos a largo plazo, de manera sistematica y gradual, que se visualiza ',
                ' - segun la interpretación del lider, que es además el encargado de ejecutarla '
            ]),
        new Item(Keys.METODOLOGIAS_SIX_SIGMA_HOSHIN_KANRI,
            [
                '- La mejora continua no es imposible, y tampoco es alcanzable de manera instantanea, para garantizar resultados sostenibles, debe ser un proceso continuo ',
                '- Igual que un proceso continuo se deben tener pasos y objetivos que alcanzar antes de continuar con la siguiente etapa ',
                '',
                '<strong>- 5S:</strong> Antes de optimizar el proceso, es necesario optimizar y estandarizar el entorno ',
                '<strong>- Kaizen:</strong> Cambios ordenados, pequeños y constantes que involucran al equipo completo y genera inercia ',
                '<strong>- Lean:</strong> Maxima eficiencia con el minimo de desperdicio, reduciendo constantemente las MUDAS (desperdicio) ',
                '<strong>- Six-Sigma:</strong> Con la maxima eficiencia alcanzada el producto se puede perfeccionar mediante analisis estadisticos y reduciendo la variabilidad ',
                '<strong>- Hoshin Kanri:</strong> Despliegue e información de nuevas politicas, cada mejora por pequeña que sea, debe estar alineada con los objetivos estrategicos ',
            ])
    ];

export const TESTING_ADVANCED =
    [
        new Item(Keys.TESTING_ADVANCED_CAJA_NEGRA_CAJA_BLANCA,
            [
                '<strong>Caja Blanca:</strong> Son tests que se realizan sabiendo la estructura y funcionamiento interno del codigo ',
                '- Muy usado en las pruebas unitarias ya que se conoce el proposito y el funcionamiento a detalle ',
                '',
                '<strong>Caja Negra:</strong> Solo se conocen las entradas y salidas del proceso, teniendo todo su funcionamiento interno oculto ',
                '- Generalmente son pruebas desde la interfaz grafica o de aceptación ',
                '',
                '- Generalmente los tests de caja blanca son hechos por los desarrolladores, y los de caja negra por las personas que conocen del negocio ',
                '- Tambien se suelen mencionar los test de Caja gris, que se considerarian un punto medio, ',
                ' - donde la persona encargada conoce del negocio y de su implementación, más no a profundidad para probar detalles particulares ',
            ]),
        new Item(Keys.TESTING_ADVANCED_VALOR_LIMITE,
            [
                '- Esta tecnica se basa en la heuristica de que los errores son más probables en los valores extremos de las entradas ',
                '- Los valores escogidos son aquellos que se encuentran por encima o debajo de las clases de equivalencia ',
                '- Los casos de prueba con esta tecnica son especialmente utiles para detectar errores de manera temprana en sistemas criticos ',
                '- Se pueden considerar una frontera entre el comportamiento normal del sistema y un punto de error conocido/desconocido para el sistema ',
                '- Dependiendo del tipo de dato de la entrada, se suele escoger las pruebas para que cumplan los siguientes escenarios: ',
                '',
                ' <strong>n</strong>   Valor en el rango normal                 <em>Ejemplo:</em>                      <strong>Dias de la semana</strong>     ',
                ' <strong>n-1</strong> Valor cercano al limite minimo           | Otro  | Domingo  | Lunes Martes Miercoles Jueves Viernes | Sabado   | Otro  |',
                ' <strong>n+1</strong> Valor cercano al limite maximo           | Error | Limite   |             Rango Normal              | Limite   | Error |',
                '                                              |       | Inferior |                                       | Superior |       |                 ',
            ]),
        new Item(Keys.TESTING_CLASES_EQUIVALENCIA,
            [
                '- Esta tecnica considera que todas las entradas del programa se pueden clasificar en 2 tipos, y solo pueden pertecer a uno ',
                '- Es bastante util ya que ayuda a reducir los casos de prueba sin dejar de realizar pruebas con una cobertura exhaustiva ',
                '',
                '<strong>Valores Validos:</strong> Entradas que No deberian provocar ningun error ó mal funcionamiento del sistema ',
                '<strong>Valores No Validos:</strong> Entradas que inducen al error ó casos no cobijados durante el desarrollo ',
                '',
                '- Todos los elementos de una partición teoricamente deben comportar igual, por lo que solo basta escoger uno para probar, tipos: ',
                '&bull; Distintos tipos de Rangos, como fechas, valores numericos, edad, probabilidades, etc.. ',
                '&bull; Valores especificos ',
                '&bull; Conjuntos de valores ',
                '&bull; Condiciones binarias etc.. ',
                '',
                '- De acuerdo a cada tipo se deberia sacar las clases de equivalencias validas e invalidas ',
                '- Si se da el caso, tambien se deberian probar los valores limite del sistema ',
            ]),
        new Item(Keys.TESTING_GRAFOS_CAUSA_EFECTO,
            [
                '- Estos grafos representan una relación logica entre distinas causas y sus posibles efectos ',
                '- Donde una causa (entradas) pueden generar en diversos efectos (salidas) ',
                '- Estas entradas y salidas tambien se pueden combinar para elaborar complejas reglas de negocio ',
                '- Estos tests siempre deben centrarse en la mitigación de riesgos y la cobertura de los requisitos ',
            ]),
        new Item(Keys.TESTING_ADVANCED_TYPES_TESTS,
            [
                '<strong>Pruebas Funcionales</strong>',
                '',
                '<strong>- Unitarias:</strong> Son pruebas de funciones especificas del sistema que se pueden tomar como una parte individual de la generalidad ',
                '<strong>- Integración:</strong> Se juntan partes especificas y se prueban como un grupo en especifico ',
                '<strong>- Extremo a extremo:</strong> Se prueba todo el sistema como un todo, su funcionamiento general y no particular ',
                '<strong>- Humo:</strong> Se concentran en verificar que con cada cambio que se haga el sistema siga funcionando bien de manera general ',
                '<strong>- Camino feliz:</strong> Aca solo se crean casos que se conocen y que no deberian fallar ',
                '<strong>- Aceptación:</strong> Realizadas por el cliente con el proposito de aceptar, o no el producto ',
                '<strong>- Alfa:</strong> Estan enfocadas a identificar posibles problemas antes de un release (lanzamiento) ',
                '<strong>- Beta:</strong> Se realizan en un ambiente real, desde la perspectiva de un usuario para satisfacer a los clientes ',
                '',
                '<strong>Pruebas NO Funcionales</strong>',
                '',
                '<strong>- Penetración:</strong> Son pruebas de seguridad, con el objetivo de penetrar los puntos debiles del sistema   ',
                '<strong>- Carga:</strong> Tienen el objetivo de averiguar cuanta carga de trabajo puede manejar un sistema sin degradaciones importantes ',
                '<strong>- Estres:</strong> La intención es saber en que punto un sistema deja de funcionar y porque ',
                '<strong>- GUI:</strong> Se prueba la interfaz grafica del usuario y que esta se adapte al publico enfocado, además de que funcione ',
                '<strong>- Ad-hoc:</strong> No tienen ninguna base o referencia por lo que su impredecibilidad puede romper las cosas ',
                '<strong>- Recuperación:</strong> Valida la capacidad del sistema para recuperarse de posibles fallos ',
                '<strong>- Regresión:</strong> Cualquier cambio de una funcionalidad no debe afectar lo que ya estaba funcionando ',
                '<strong>- Compatibilidad(software):</strong> Se prueba que el software actual soporte las versiones previas ',
                '<strong>- Compatibilidad(Hardware):</strong> Se prueban diferentes entornos de hardware para saber donde y como puede correr ',
                '<strong>- Internalización:</strong> Que tambien se adapta un sistema para su uso en diferentes contextos geograficos ',
            ]),
        new Item(Keys.TESTING_ADVANCED_OUTSIDE_INSIDE,
            [
                '- En el TDD se suelen encontrar 2 enfoques diferentes ',
                '',
                '<strong>Escuela clasica (Inside-out)</strong> Tiene en cuenta conceptos originales de Kent Beck, Stephen Freeman y Nat Pryce como: ',
                '- Triangulación: Que se basa en obtener varios casos especificos, con los cuales se pueda implementar una solución generica ',
                '- Verificación: Que se centra en usar los objetos reales previamente configurados, con interacciones reales ',
                '',
                '<strong>Escuela de Londres (Outside-in):</strong> Su proposito sigue siendo el mismo pero la manera de alcanzarlo es diferente ',
                '- Verificar el comportamiento y las interacciones de los objetos más que sus estados ',
                '- Asi se puede ahorrar todo el trabajo de la creación de los objetos y solo usar dobles(mocks)',
            ]),
        new Item(Keys.TESTING_ADVANCED_CASOS_DE_PRUEBA,
            [
                '- Entre más complejo sea un software, mayor sera la posibilidad de sufrir defectos ',
                '- Un caso de prueba es un conjunto de condiciones y variables, bajo un mismo ambiente que determinara si, ',
                ' - alguna caracteristica esta completa o parcialmente satisfactoria ',
                '',
                '- Para lograr esto, deberia crearse al menos un caso de prueba por cada requisito definido: ',
                '&bull; Los ciclos de pruebas deben ser fluidos y eficientes ',
                '&bull; Deben estar escritos de manera clara y comprensible ',
                '&bull; La ejecución debe ser facil o estar guiada de no poder serlo ',
                '&bull; Tener las entradas y salidas debidamente especificadas ',
                '&bull; Definir los comportamientos esperados y como invocarlos ',
                '',
                '<strong>Estados</strong>',
                '<strong>- Exitoso:</strong> Todos los pasos y el comportamiento ha sido el esperado ',
                '<strong>- Fallido:</strong> Si alguno de los pasos es erroneo ',
                '<strong>- Bloqueado:</strong> Si este no se puede realizar debido a una secuencia especifica no posible, o fallos previos ',
                '<strong>- N/A:</strong> Ya no aplica debido a cambios en la funcionalidad o los requisitos asociados ',
                '',
                '<strong>Pasos a tener en cuenta</strong>',
                '&bull; Identificar los requirimientos a probar y enumerar los casos de cada requisito ',
                '&bull; Realizar una matriz de trazabilidad para vincular los requerimientos y sus casos de prueba',
                '&bull; Escribir una descripción general del caso, que permita a personas con o sin conocimientos previos entender la prueba ',
                '&bull; Conocer los prerrequisitos a tener en cuenta para la prueba ',
                '&bull; Definir la prioridad de cada caso (alta, media, baja) ',
                '&bull; Secuencia de pasos y su descripción para realizar la prueba ',
                '&bull; Descripción de los resultados, sea satisfactorios o no ',
            ]),
        new Item(Keys.TESTING_ADVANCED_USES_CASES,
            [
                '- Descripción del conjunto de interacciones del sistema con uno o varios actores para alcanzar un objetivo ',
                '- Este debe incluir las multiples rutas posibles (escenarios) que el usuario puede tomar ',
                '- Aca se ha de tener en cuenta factores como que proceso se va a realizar, que actor lo va ejecutar y como lo hara ',
                '- Estos detallan una o varias funcionalidades del sistema y como se agrupan para obtener un resultado final ',
            ]),
        new Item(Keys.TESTING_ADVANCED_SMELLS_CODES1,
            [
                '<strong>Convenciones de nombres:</strong>',
                '<strong>- Mistaken identity:</strong> Cuando el nombre de una prueba es contrario a lo que esta haciendo ',
                '<strong>- Anonymous test case:</strong> Cuando su nombre no describe lo que se esta probando ',
                '<strong>- Testy test:</strong> Cuando una prueba tiene la redundancia de que indica que es una prueba ',
                '<strong>- Ni verbos ni sustantivos:</strong> Esta tiene el nombre del concepto pero no del comportamiento previsto ',
                '',
                '<strong>Estructurales:</strong>',
                '<strong>- Todo es una propiedad:</strong> Cuando variables temporales se mantienen como variables de instancia ',
                '<strong>- Falta de parametrizacion:</strong> Cuando se llaman metodos fuera del metodo de tests o se hace un 2x1 en un mismo test ',
                '<strong>- Test de integracion enmascarado:</strong> Demasiadas capas estan involucradas en un test ',
                '<strong>- El Parasito:</strong> Los tests deben ser independientes y nunca depender de otros tests previos ',
                '<strong>- Pruebas cuajadas:</strong> Union inapropiada de varios tests o division innecesaria ',
                '',
                '<strong>Inicializacion y desmontaje (setup, teardown)</strong>',
                '<strong>- The First and Last Rites:</strong> Metodos repetivos en cada prueba al iniciar y finalizarla, en vez de una configuracion comun ',
                '<strong>- Oversharing on setup:</strong> Uso excesivo de datos compartidos que no todos los tests necesitan ',
                '<strong>- Test setup is somewhere else:</strong> La parte del Given y el When estan en otro lugar, la prueba solo hace las validaciones ',
                '<strong>- Well, My Setup Works:</strong> El test se puede desviar o duplicar el codigo de produccion innecesariamente por no compartir configuraciones ',
                '<strong>- Data-ja vu:</strong> Los datos que pueden ser inmutables y compartidos se instancian innecesariamente con cada test ',
                '<strong>- Limpieza dolorosa:</strong> Cuando se necesita crear o destruir un recurso cosotoso y la separacion del test con este es debil o muy larga ',
                '',
                '<strong>Codificacion</strong>',
                '<strong>- Herp Derp:</strong> Cuando algo que es parte fundamental del test esta como comentario pero no codificado ',
                '<strong>- Sobre refactorizar:</strong> Se ha aplicado tando DRY al codigo de pruebas que ha perdido significado y legibilidad ',
                '<strong>- Boilerplate hell:</strong> No se puede entender el tests ya que hay demasiado codigo, indicando la falta de fabricacion de datos ',
                '<strong>- Half a helper method:</strong> Cuando hay metodos de utilidad que no preparan todas las cosas como las necesita el test ',
                '<strong>- Automatizacion:</strong> Si el codigo de tests es autogenerado, es necesario revisarlo para saber que no es inutil o esta mal ',
                '',
                '<strong>Datos</strong>',
                '<strong>- What are we Testing ?</strong> Los datos del tests no son claros en lo que son o hacen ',
                '<strong>- Missing test data factory:</strong> Cuando cada tests construye sus propios datos en vez de tener un metodo comun para esto ',
                '<strong>- Unworldly Test Data:</strong> Son datos que sirven para el contexto de la prueba pero no son reales ',
                '<strong>- Wheel of fortune</strong> Los datos aleatorios pueden conducir al fallo de las pruebas, haciendolas erraticas ',
                '<strong>- Time Bomb Data:</strong> Cuando se prueban informacion con fechas, si no se tiene cuidado estos datos pueden volverse erraticos ',
            ]),
        new Item(Keys.TESTING_ADVANCED_SMELLS_CODES2,
            [
                '<strong>Aserciones - frameworks</strong>',
                '<strong>- Chat logging:</strong> Se usan mensajes por consola o logs para suplir el fallo de una asercion ',
                '<strong>- Bumbling assertions:</strong> Se escogen a voluntad afirmaciones poco sofisticadas y de facil verificacion ',
                '<strong>- Assertion diversion:</strong> Cuando se escoge la asercion erronea para que el fallo de la prueba sea más facil de entender ',
                '<strong>- Equality Sledgehammer Assertion:</strong> Se crean aserciones demasiado completas para no pensar en una mas general e indicativa ',
                '<strong>- Martini Assertion:</strong> En vez de verificar todo, se verifica lo que sea y como sea para que el test pase ',
                '<strong>- Conditional assertions:</strong> Sobreesfuerzo en la verificacion donde las aserciones son dinamicas de acuerdo a la ejecucion del codigo de pruebas ',
                '<strong>- Fuzzy assertions:</strong> La falta de control en el sistema conlleva a no predecir resultados exactos si no coincidencias parciales ',
                '',
                '<strong>Pruebas<strong>',
                '<strong>- The True Believer:</strong> La prueba convence al autor de que el codigo esta bien y no que tal vez esta erroneo ',
                '<strong>- Assert the world:</strong> Las aserciones prueban todo, hasta detalles sin sentido ',
                '<strong>- Circumstantial evidence:</strong> Las aserciones comprueban comportamientos indirectos ',
                '<strong>- Blinkered assertions:</strong> Las afirmaciones fallan en comprobar el panorama general al centrarse en subconjuntos de detalles ',
                '',
                '<strong>Locura por los mocks</strong>',
                '<strong>- Overmocking:</strong> Son pruebas de caja blanca que siempre pasan ya que todo es perfecto ',
                '<strong>- Mock madness:</strong> Cuando se abusa de los mocks hasta para crear simples objetos primitivos como POJOs',
                '<strong>- Remote Control Mocking:</strong> La clase que depende de un servicio se prueba con la dependencia simulada y no el servicio en si ',
                '<strong>- The telltale heart:</strong> Cuando existe codigo de produccion que solo cobra sentido en la ejecucion de los tests ',
                '',
                '<strong>Inestables</strong>',
                '<strong>- The Inhuman Centipede:</strong> No solo sucede cuando existe una prueba dependiente de otra, si no que hay una secuencia especifica para que no fallen ',
                '<strong>- Is There Anybody There ? </strong> Prueba o codigo inestable que dañan la compilacion ocasionalmente ',
                '<strong>- The Leaky Cauldron:</strong> Prueba sensible a condiciones creadas por otras pruebas o que corrompe a otras ',
                '<strong>- The Soloist:</strong> Solo funciona cuando nadie más se esta ejecutando ',
                '<strong>- The Bandwidth Demander:</strong> Si el sistema esta lento este test fallara, debido a procesos internos pesados ',
                '<strong>- The Temporal Tip Toe:</strong> Un test que utiliza el tiempo para coordinar eventos concurrentes, y aprovecha la suerte de tener tiempos perfectos ',
                '',
                '<strong>Implementacion</strong>',
                '<strong>- I wrote it like this:</strong> Probando la implementación conocida, en vez del resultado ',
                '<strong>- Contortionist testing:</strong> Debido a que las pruebas fueron escritas despues del codigo, este debe esforzarse para funcionar ',
                '<strong>- The Hans Moretti Sword Box:</strong> Entre mas tests se agreguen a los puntos testeables, menos se evitaran las vias no descubiertas del codigo ',
            ]),
        new Item(Keys.TESTING_ADVANCED_MUTATION,
            [
                '- Es una tecnica de pruebas para encontrar fallas en las variaciones de un software y determinar la efectividad de las pruebas ',
                '- Una mutación es una prueba con una ligera modificación del codigo, si estas llegan a pasar el mutante sobrevivio, por lo que el codigo esta mal ',
                '- Entre menos mutaciones sobrevivan, mejor sera la calidad del codigo probado ',
                '- Tambien se ha de tener en cuenta que pueden existir mutantes equivalentes, que hacen lo mismo que el codigo original, solo que con otra sintaxis ',
                '',
                '<strong>Casos:</strong>',
                '- Cambiar valores usados en el codigo original, como empezar un ciclo en 1 y no en 0, etc... ',
                '- Eliminar, intercambiar o duplicar bloques de codigo declarados ',
                '- Decisiones al comparar valores, ya sea intercambiando un == por un != por ejemplo',
                '',
                '<strong>Ventajas:</strong>',
                '- Permiten cubrir gran parte de la logica a probar ',
                '- Detecta errores de facil alusión ',
                '- Verifica la efectividad de nuestro conjunto de pruebas y si es necesario aumentarlas o corregirlas ',
                '',
                '<strong>Desventajas:</strong>',
                '- Consumen una gran cantidad de recursos ',
                '- Se deben matar los mutantes que no tienen sentido o no son validos en el contexto de la prueba ',
                '',
                '<strong>Supuestos en lo que se basan:</strong>',
                '- Programadores competentes: Si un programador es capaz de escribir y probar segmentos pequeños, tambien lo hara con más grandes ',
                '- Efectos del acoplamiento: Si se combinan 2 formas para formar un programa y ambas son buenas, entonces lo combinación tambien lo sera '
            ]),
        new Item(Keys.TESTING_ADVANCED_ANTI_PATTERNS,
            [
                '- <em>TDD</em> es una practica conocida para realizar pruebas, por lo que no esta excenta de malas practicas y antipatrones en su uso',
                '- Existen una gran variedad de malas practicas y codesmells, por lo que estos solo se consideran una aproximación inicial ',
                '',
                '<strong>The Liar:</strong> Toda prueba que se ejecuta, pero esta probando algo totalmente diferente, generando falsa seguridad',
                '',
                '<strong>Excesive Settup:</strong> Es comun cuando existe una mala arquitectura e importan más la pasos previos, que las verificaciones y el testing ',
                '',
                '<strong>The Giant:</strong> Una unica prueba, que prueba multiples escenarios, con muchos asserts no relacionados, son dificiles de entender y más de modificar',
                '',
                '<strong>The Mockery:</strong> Donde el sistema a probar, ha sido reemplazado por un mock, asi pasan por temas de cobertura, sin probar nada de verdad ',
                '',
                '<strong>Generous Leftover:</strong> Son pruebas que dejan restos sin limpiar y hacen que pruebas subsiguientes fallen, pero estas no fallan de manera individual ',
                '',
                '<strong>The Hidden Dependency:</strong> Es una prueba que requiere de forma secreta, alguna configuración o particularidad del entorno, que no esta presente',
                '',
                '<strong>The Stranger:</strong> Es una prueba totalmente valida y posiblemente bien estructurada, con el defecto de que no esta relacionada directamente con el <em>SUT</em>',
            ]),
        new Item(Keys.TESTING_ADVANCED_APDEX,
            [
                '- Es un estandar de la industria para medir la satisfacción de los usuarios con el tiempo de respuesta de las aplicaciones y servicios Web, ',
                ' - en lugar de metricas tradicionales que se pueden distorsionar, como el tiempo de respuesta promedio ',
                '- Esta puntuación es un valor de relación entre la cantidad de solicitudes satisfechas y toleradas, y el total realizadas ',
                '- Cada solicitud satisfecha cuenta como una solicitud',
                '- Cada solicitud tolerada cuenta como la mitad de una solicitud satisfecha ',
                '- La puntuación varia de 0 a 1, siendo 0 el peor y 1 el mejor',
                '- Esta medición esta hecha para aplicaciones de alto rendimiento, de lo contrario los datos provocaran resultados inestables ',
                '',
                '- Es necesario definir un umbral de manera arbitraria <strong>T</strong> y asi saber que peticiones recaen en cada definición ',
                '<strong>Satisfecho:</strong> El tiempo de respuesta es menor o igual a T, indicando que no existen problemas ',
                '<strong>Tolerancia:</strong> El tiempo de respuesta es mayor que T y menor o igual que 4T, algo que un usuario final podria notar ',
                '<strong>Frustrado:</strong> El tiempo de respuesta es mayor a 4T o la solicitud devuelve un error del lado del servidor, insatisfacción ',
                '',
                '- Una tasa de error alta puede provocar que tenga una tasa promedio satisfactoria, pero una puntuación Apdex baja ',
                '- Tambien se pueden dividir las puntuaciones especificas en calificaciones, para hacerlas más entendibles e informativas ',
                ' - Excelente(1 - 0.94)     ',
                ' - Buena(0.93 - 0.85)      Apdex Score = <u> (Satisfied + Tolerating/2) </u>',
                ' - Regular(0.84 - 0.70)                         Total samples               ',
                ' - Mala(0.69 - 0.49)',
                ' - Inaceptable(0.48 - 0)',
            ]),
        new Item(Keys.TESTING_ADVANCED_COSTS,
            [
                '- Las pruebas son fundamentales para garantizar la calidad y la confiabilidad, pero estas tienen multiples aspectos a tener en cuenta ',
                '- Estos conceptos estan interconectados y se afectan directamente e indirectamente por lo que se intentan equilibrar los costos y la calidad ',
                '',
                '<strong>Complejidad:</strong> La complejidad del producto/sistema juega un papel directamente proporcional en el tiempo y esfuerzo realizados ',
                '<strong>Alcance:</strong> Es la amplitud profundidad y detalles a considerar al realizar las pruebas ',
                '<strong>Duración:</strong> Periodos largos de prueba afectan el tiempo y los recursos invertidos además de la minuciosidad del proceso ',
                '<strong>Recursos:</strong> La disponibilidad y asignación de recursos no puede ser ilimitada, tampoco debe caer en el extremo de ser deficiente ',
                '<strong>Herramientas:</strong> Las herramientas más completas suelen ser de paga y son necesarias si se requieren resultados más precisos y detallados ',
                '',
                '<strong>Entornos de pruebas:</strong> Un entorno simulado generalmente requiere menos recursos en comparación a un entorno real y/o productivo ',
                '<strong>Cobertura:</strong> Entre más escenarios y más casos se prueben, se requerira más tiempo y recursos ',
                '<strong>Gestion de Datos:</strong> Generar datos realistas o incluso adquirirlos, puede representar un costo adicional ',
                '<strong>Ejecución de pruebas:</strong> Factores como la cantidad, complejidad, repeticiones, el tiempo requerido, tienen un costro intrinseco ',
                '<strong>Informes:</strong> Analizar los resultados y generar valor mediante informes va incrementando el costo de acuerdo a la complejidad necesitada ',
                '<strong>Mantenimiento:</strong> Las actualizaciones periodicas, la correción de errores y la adaptación a los cambios siempre estaran presentes ',
                '',
                '<strong>Diseño de casos y escenarios de pruebas:</strong> Son las especificaciones de las entradas y salidas esperadas, con las condiciones para su ejecución, ',
                ' - de manera que cubra la mayor cantidad de funcionalidades, caracteristicas, y casos extremos del producto/sistema ',
                '<strong>Planeación:</strong> Estos casos no solo se ejecutan, se deben realizar de manera controlada y si es posible siguiendo un plan, ',
                ' - asi registrar los resultados y monitorear la ejecución se simplifican ',
            ]),
        new Item(Keys.TESTING_ADVANCED_ISOLATION,
            [
                '<strong>Principio de Aislación:</strong> Indica que las pruebas deben ser aisladas y no depender unas de otras, evitando fallas en cascada y que el orden sea relevante ',
                '<strong>Patron de Pruebas hermetico:</strong> Cada prueba es una isla, que no afecta a las demás y de igual manera es autosuficiente ',
                '',
                '- La configuración puede ser reutilizada más no modificada, al mismo tiempo que deben poder existir escenarios individuales ',
                '- La destrucción o desmontaje de recursos siempre debe suceder despues de cada test para no afectar a los siguientes ',
                '- Aunque el entorno sea compartido, este siempre debe ser el mismo para cada prueba y si se requieren variaciones deben estar contenidas ',
                '- Un conjunto de pruebas con problemas de Aislación, dificilmente sera automatizado, además de que genera retrasos y desperdicio de recursos ',
                '',
                '<strong>Detectar pruebas mal aisladas</strong>',
                '- La ejecución individual falla, pero en una suite o conjunto no',
                '- La prueba falla de manera aleatoria ',
                '- Es dependiente de otra prueba ó de un orden de ejecución especificos, Smell code <strong>The Leaky Cauldron</strong> ó <em>caldero chorreante</em>',
                '- La transición hacia un nuevo ambiente rompe una o varias pruebas ',
                '- No soportan ser ejecutadas en paralelo, aun si estan diseñadas para permitirlo '
            ]),
        new Item(Keys.TESTING_ADVANCED_CHARGE,
            [
                '- Hoy en dia todas las aplicaciones deben ser escalables y estables, estos requisitos no funcionales tienen un gran impacto en la usabilidad ',
                '- Asi se garantiza que el software funcione de manera fluida y eficiente, con multiples cargas de trabajo ',
                '- De esta manera la experiencia de usuario no se ve afectada de manera negativa y se evitan daños en la reputación de la marca ',
                '',
                '<strong>¿ Porque se necesitan ?</strong>',
                '- Validar el rendimiento de la aplicación, de manera que que se comporte normal con cargas normales y cargas maximas ',
                '- Identificar cuellos de botella, fugas de memoria y otros problemas durante la fase de desarrollo ',
                '- Optimizar la escalabilidad de manera que se pueda manejar el crecimiento en base a la demanda sin degradaciones importantes ',
                '- Mitigar riesgos financieros en caso de tiempos de inactividad o fallos por eventos con mucha demanda ',
                '',
                '<strong>¿ Que debe tener una herramienta y como deberia ser ?',
                '- Creación de scripts de prueba ya sean mediante codigo ó interfaz grafica, de manera que se puedan simular escenarios reales ',
                '- Recopilación de metricas, como tiempos de respuestas, tasa de errores, utilización de recursos, latencia, etc.. ',
                '- Monitoreo en tiempo real de manera que permita detectar problemas sobre la marcha ',
                '- Escalabilidad de manera que pueda soportar niveles de carga variables, desde pocos usuarios hasta cientos o miles ',
                '- Integraciones con otras herramientas, ya sea para CI/CD, monitoreo, entre otras ',
                '- Informes y analisis detallados en base a la información recolectada ',
                '- Soporte para mutiples protocolos: Http, Ftp, Udp, Sockets, eventos, etc... dando soporte a multiples tipos de aplicaciones ',
                '- Reutilización de scripts o escenarios en diferentes fases, escenarios y entornos de prueba ',
                '',
                '<strong>Criterios de selección:</strong>',
                '- Compatibilidad con el ambiente y las tecnologias en que esta construida la aplicación a probar ',
                '- Facilidad de uso ó que tengan una curva de aprendizaje pequeña ',
                '- Costos, como si se tiene una versión gratuita ó los costos de los planes son bajos ',
                '- La comunidad y el soporte son invaluables para optimizar el uso de la herramienta, en especial en casos desconocidos ',
                '',
                '<strong>Tipos de pruebas:</strong>',
                '<strong>- Prueba de carga:</strong> Evalua la capacidad para funcionar bajo las cantidades de usuarios esperada ',
                '<strong>- Prueba de estres:</strong> Miden la estabilidad de la aplicación en condiciones extremas ',
                '<strong>- Prueba de resistencia:</strong> Rendimiento de la aplicación durante periodos prolongados ',
                '<strong>- Prueba de volumen:</strong> Capacidad de la aplicacion para manejar grandes cantidades de datos ',
                '<strong>- Prueba de escalabilidad:</strong> Mide como aumenta/disminuyen los recursos de la aplicación segun la demanda ',
                '',
                '<strong>Algunas herramientas conocidas:</strong>',
                '<strong>- Jmeter:</strong> Open-source y diseñada para pruebas de carga y de resistencia, con una interfaz grafica amigable ',
                '<strong>- Gatling:</strong> Open-source con scripts <em>DSL</em> compatibles con Scala y Java, con un enfoque asincronico de alto rendimiento ',
                '<strong>- K6:</strong> Open-source sin interfaz grafica, pero con scripts simples y eficientes, especialmente en entornos de la nube ',
                '<strong>- BlazeMeter:</strong> Basado en la nube como una extensión avanzada de Jmeter para empresas, con una gran compatibilidad de protocolos e integraciones ',
            ]),
        new Item(Keys.TESTING_ADVANCED_ARCH_UNIT,
            [
                '- La relación entre arquitectura y mantenibilidad es un tema de estudio en la industria del software ',
                '- Siempre puede existir codigo que no se adhiera a nuestras reglas arquitectonicas ó que este fuera de contexto ',
                '- En este caso dentro del amplio contexto que involucra la arquitectura, hace referencia a la organización en paquetes de nuestro codigo ',
                '',
                '- En una arquitectura basica <strong>MVC</strong> se pueden encontrar las siguientes reglas en base a solamente como estan organizadas las carpetas ',
                ' - La capa de presentación solo puede depender del servicio ',
                ' - La capa de servicio solo puede depender de las clases de persistencia ',
                ' - La capa de persistencia no puede depender de nadie más ',
                '',
                '- De manera que se pueden crear reglas en que cierto paquete solo contenga clases de otro ó otros paquetes determinados ',
                '- Las clases de los frameworks usados y del lenguaje en si, suelen excluirse ya que estas son transversales a todo el proyecto ',
                '- Aunque tambien pueden existir capas que no pueden contener dependencias externas de ningun tipo, como el dominio en <strong>DDD</strong>',
                '',
                '<strong>Casos de Uso comunes</strong>',
                '- Buscar problemas de dependencias ciclicas   - Definir capas y que capas pueden usarse entre si',
                '- Validar estandares de nombramiento          - Verificar clases deprecadas para limpieza',
                '- Uso de anotaciones indebidas                - Mantener convenciones de codigo',
            ]),
        new Item(Keys.TESTING_ADVANCED_ENVIRONMENT,
            [
                '- Durante todo el Ciclo de vida del desarrollo, las pruebas son fundamentales y ayudan a garantizar la calidad de las aplicaciones ',
                '',
                '<strong>¿ Qué es un ambiente de pruebas ?</strong>',
                '- Es la combinación de hardware, software, datos y configuraciones para ejecutar pruebas de distintas indoles ',
                '- Esta configuración no es universal y debe adaptarse a lo que dicte el software y la necesidad ',
                '- En caso de necesitar casos con datos o configuraciones especificas, se puede contar con conjuntos de datos de pruebas ',
                '- Cuando se tienen pipelines y/o CI/CD estos agregan ó omiten pasos y etapas segun el codigo y en que ambiente se va a desplegar ',
                '',
                '<strong>Desarrollo:</strong> Ambiente donde se crean o actualizan las aplicaciones por parte de los desarrolladores ',
                '- Suele ser un ambiente compartido por lo que el codigo de multiples desarrolladores puede llegar a coexistir ',
                '',
                '<strong>Testing:</strong> Aca los encargados de calidad se encargan de probar las nuevas caracteristicas y realizar las pruebas pertinentes ',
                '- Aca se hacen multiples tipos de pruebas, empezando por pruebas individuales de los componentes, de integración, hasta End to End (E2E)',
                '',
                '<strong>Staging:</strong> Es una replica casi exacta de producción, de manera que se puedan hacer pruebas reales sin afectar a los usuarios reales ',
                '- Como este ambiente cuenta con los mismos recursos, se pueden hacer pruebas relacionadas al volumen de datos, de carga, de rendimiento o de estres ',
                '',
                '<strong>Producción:</strong> Al estar disponible para los usuarios finales, no significa que las pruebas se han terminado ',
                '- Se pueden realizar despliegues para grupos de usuarios especificos y que ayuden a probar la aplicación para encontrar errores ',
                '- Tambien existe la posibilidad de usar <em>feature-flags</em> de manera que se puedan habilitar/deshabilitar sin contratiempos ',
            ]),
        new Item(Keys.TESTING_ADVANCED_PERFORMANCE,
            [
                '- Las pruebas de performance generan multiples datos que analizar y ciertas metricas son claves para generar conclusiones acertadas ',
                '- Estas metricas requieren tener experiencia con conocimientos basicos de matematicas y estadisticas ',
                '- Los graficos son muy importantes para la compresión y analisis de los datos, estas nos ayudan a discernir e identificar patrones ',
                '',
                '<strong>Promedio:</strong> Es la suma de todos los valores, divido la cantidad total de estos mismos ',
                '- El promedio puede ser engañoso, es suceptible a valores extremos por lo que valores muy altos y muy bajos pueden dar la sensación de un nivel <em>aceptable</em> ',
                '',
                '<strong>Desviación estandar:</strong> Es una medida de la dispersión con respecto al promedio, es decir, cuánto varían los valores con respecto a su promedio ',
                '- Entre más separados esten los datos, indica que el sistema no es constante, especialmente durante escenarios de mucha carga ',
                '- Este valor es complementario al promedio, entre más alta sea, más valor pierde el promedio para la toma de decisiones ',
                '',
                '<strong>Percentiles:</strong> Son bastante útiles, ya que proporcionan una medida bajo la cual se encuentra un porcentaje de la muestra ',
                '- Si se llega a escoger algun percentil para generar criterios de aceptación, todo valor por arriba pierde importancia ',
                '- Es practico evaluar multiples percentiles y muchas herramientas ya lo hacen por defecto, los más comunes son: ',
                '&bull;  P25: El 25% de los datos se encuentran por debajo ',
                '&bull;  P50: El 50% de los datos se encuentran por debajo, este suele coincidir con la mediana(mitad de los datos)',
                '&bull;  P75: El 75% de los datos se encuentran por debajo ',
                '&bull;  P95: El 95% de los datos se encuentran por debajo ',
                '&bull; P100: El 100% de los datos se encuentran por debajo, este suele ser el valor maximo ',
            ]),
        new Item(Keys.TESTING_ADVANCED_SHIFT_LEFT_SHIFT_RIGHT,
            [
                '<strong>Shift-Left Testing</strong> es un enfoque que se aleja del modelo de <em>cascada</em> y se integra mucho mejor con las <em>metodologias agiles</em> ',
                '- La calidad es un ejercicio constante, y no deberia estar ceñida a una sola etapa del desarrollo de software ',
                '- Esto trae cambios que no siempre son faciles de implementar, ya que se realizan pruebas desde etapas iniciales y a lo largo de todo el proyecto ',
                '- Metodologias como <strong>TDD</strong>, <strong>BDD</strong> y <strong>CI/CD</strong> promueven este enfoque, modificando la visión tradicional del control de calidad ',
                '- Se busca incorporar actividades de calidad desde el inicio, con el fin de mitigar la mayor cantidad de riesgos posibles, incluso desde los requisitos ',
                '',
                '<strong>Shift-Right Testing</strong> en cambio se refiere a acciones a tomar más adelante durante el desarrollo, generalmente en fases posteriores a los lanzamientos ',
                '- Junto al concepto de <strong>DevOps</strong> se han integrado practicas de entrega, configuración y monitoreo de aplicaciones ',
                '- Su nivel de riesgo es mayor ya que los problemas pueden afectar directamente a los usuarios ',
                '- Aca tambien se pueden contar las diversas estrategias de despliegues que existen, como <em>Canary Release</em>, <em>A/B Testing</em>',
                '- El beneficio de este enfoque es que esta centrado en las funcionalidades reales y casos reales, con pocas o nulas suposiciones ',
                '',
                '- Ambos enfoques no son mutuamente excluyentes, se pueden juntar para obtener retroalimentaciones valiosas antes de cada lanzamiento incrementando ',
                ' - la experiencia en cada despliegue para futuros comportamientos y funcionalidades, logrando pruebas continuas con impacto positivo para cada contexto ',
            ])
    ];
